# HW_200_55_找数字
小扇和小船今天又玩起来了数字游戏，小船给小扇一个正整数n (1<=n<=1e9)，小扇需要找到一个比n大的数字m，使得m和n对应的二进制中1的个数要相同（如4对应二进制100,8对应二进制1000,1的个数都为1），现在求m的最小值。

### 输入描述:
输入：第一行输入一个正整数n(1<=n<=1e9)。

### 输出描述:
输出：输出一个正整数m。

### 示例1
输入 2

输出 4

说明
2的二进制10,4的二进制位100，1的个数相同，且4是满足条件的最小数

### 示例2
输入 7

输出 11

说明
7的二进制111,11的二进制位1011，1的个数相同，且11是满足条件的最小数

### 解：

可能会超时

```go
package main

import (
	"fmt"
	"math/bits"
)

func findNextWithSameBitCount(n int) int {
	countOnes := bits.OnesCount(uint(n))
	for m := n + 1; ; m++ {
		if bits.OnesCount(uint(m)) == countOnes {
			return m
		}
	}
}

func main() {
	testCases := []int{2, 7, 10, 1000000000}

	for _, n := range testCases {
		result := findNextWithSameBitCount(n)
		fmt.Println(result)
	}
}

```

方法2：

```go
package main

import (
	"fmt"
)

func findNextWithSameBitCount(num int) int {
	var ans int = num
	// 从低位数起，连续的0的个数cnt0，接下来连续1的个数cnt1
	cnt0, cnt1 := 0, 0
	// 找到低位连续的0的个数
	for (num & 1) == 0 {
		cnt0++
		num >>= 1
	}
	// 找到低位连续的0之后，连续的1的个数
	for (num & 1) == 1 {
		cnt1++
		num >>= 1
	}

	// ans先右移(cnt0 + cnt1)位，再左移(cnt0 + cnt1)位
	// 把原ans中最低的(cnt0 + cnt1)位都重置为0
	k := cnt0 + cnt1
	ans >>= k
	ans <<= k

	// 将第k = cnt0 + cnt1 + 1 位从0修改为1
	k = cnt0 + cnt1
	mask := (1 << k)
	ans |= mask

	// 把从低位开始的连续的 k = cnt1 - 1 位 从0修改为1
	k = cnt1 - 1
	mask = (1 << k) - 1
	ans |= mask

	return ans
}
func main() {
	// Test the function with some inputs.
	testCases := []int{2, 7, 300, 1000}

	for _, n := range testCases {
		result := findNextWithSameBitCount(n)
		fmt.Println(result) //count is %d (binary: %b).\n", n, n, result, result)
	}
}
```

从例子进行分析
我们可以先举一些例子，通过这些例子来归纳出符合要求的m的最小值的规律。

n为2的k次幂
n为2的k次幂。譬如

n = 0b1000
1
显然，n的二进制表示中有且只有1个1。

由于m必须比n更大，所以m中的1不能够放在比第k位更低位的位置，只能够放在比第k位更高位的位置。故

m = 0b10000
1
是正确答案。

n的二进制表示形如1...10...0
n的二进制表示形如1...10...0，即低位包含了若干个连续0（其个数设为cnt0），而高位包含了若干个连续的1（其个数设为cnt1）。譬如

n = 0b11100
1
其中，cnt0 = 2，cnt1 = 3，二进制的位数len_bin_n = cnt0 + cnt1 = 5。

显然，为了找到一个更大的二进制数，这个更大的二进制数的位数一定会比n多一位。

因为如果二进制的位数不变，我们只改动最低位的cnt0个0的情况，一定会使得1的个数变得比n多。

所以，只能固定m的二进制位数len_bin_m = cnt0 + cnt1 + 1 = 6，构造一个包含cnt0 + 1个0，cnt1个1的二进制数，且其最高位为1。即

m = 0b1xxxxx
1
其中xxxxx，我们需要填入cnt0 + 1 = 3个0和cnt1 - 1 = 2个1。

无论xxxxx怎么填入，由于m的二进制位数已经大于n了，所以一定存在m > n成立。

为了找到尽可能小的m，尚未填入的数字xxxxx也要尽可能地小。

故填入的最终结果为，xxxxx = 00011，即

m = 0b100011
1
n为任意一个正整数
现在讨论n为任意一个正整数的情况。

任意一个正整数，其二进制数必然由三部分组成：

从低位起包含了若干个连续0（其个数设为cnt0）
连续的0之后包含了若干个连续的1（其个数设为cnt1）
剩下的高位的0或1。
譬如

n = 0b10010101011100
1
其中，cnt0 = 2，cnt1 = 3（只看最低位的情况）。

特别注意，cnt0是可以为0的，即表示n是一个奇数，其最低位是1而不是0。

但cnt1不能为0，如果cnt1为0，就说明n = 0，不符合题目的要求。

如果不看高位的情况，n低位的cnt0 + cnt1 + 1位的情况，实际上和上一个例子的情况是完全一样的。即

n = 0b011100    # 等价于 n = 0b11100
1
为了找到一个比n更大但尽可能小的m，n的高位是不去修改的，而只需要修改低位的cnt0 + cnt1 + 1位即可。其过程就跟前面类似，最终得到

n = 0b10010101011100
m = 0b10010101100011
1
2
整体贪心思路
在讨论n为任意一个正整数的时候，其实我们已经涵盖了所有的情况，这实际上也是一个贪心策略。

以例子

n = 0b10010101011100
1
为例，制定找到m的策略。

计算n的二进制数最低位的连续的0的个数cnt0
计算n的二进制数连续的0之后，接下来的连续的1的个数cnt1
cnt0 = 2
cnt1 = 3
1
2
将最低位连续的cnt0+cnt1+1位均改为0。
ans = 0b10010101011100
↓
ans = 0b10010101000000
1
2
3
将第cnt0 + cnt1位改为1。
ans = 0b10010101000000
↓
ans = 0b10010101100000
1
2
3
将最低位连续的cnt1 - 1位均改为1。
ans = 0b10010101100000
↓
ans = 0b10010101100011
1
2
3
那剩下的工作，就是如何通过位运算操作或字符串数组模拟实现上述过程了。

位运算操作
在明确上述贪心策略之后，本题完全可以通过将原输入num转化为仅包含"0"和"1"的字符串数组，并使用遍历模拟的方式来实现。

num的取值范围是1 <= num <= 1e9，num的二进制数的位数的上限只有log(2, 1e9) ≈ 27，也就是转化为字符串或字符串数组的长度只有100不到，因此对其操作的时间复杂度是很低的。

对字符串数组的操作比较简单，故在此略去不表，感兴趣的同学可以自行实现。接下来仅介绍位运算操作。

这里所使用到的位运算操作技巧，都可以在python常用内置函数、方法、技巧汇总中找到对应的总结。

寻找cnt0和cnt1
cnt0和cnt1的计算非常简单，我们只需要不断判断num的最低位情况并且不断右移删除最低位即可。

直接使用两个while循环，当

num & 1 == 0成立时，说明num的最低位是0
num & 1 == 1成立时，说明num的最低位是1
cnt0 = 0
cnt1 = 0

while num & 1 == 0:
    cnt0 += 1
    num >>= 1

while num & 1 == 1:
    cnt1 += 1
    num >>= 1
1
2
3
4
5
6
7
8
9
10
将最低位连续的cnt0 + cnt1 + 1位均改为0
我们可以通过先右移k位，再左移k位的方式，将一个数的最低位连续的k位均设置为0。

其中k = cnt0 + cnt1 + 1，故

k = cnt0 + cnt1 + 1
ans >>= k
ans <<= k
1
2
3
由于在上述分析中，我们知道第cnt0 + cnt1 + 1位一定是0，所以取k = cnt0 + cnt1也是可以的。

k = cnt0 + cnt1
ans >>= k
ans <<= k
1
2
3
将第cnt0 + cnt1 + 1位改为1
我们需要找到mask = 1 << k，其中k = (cnt0 + cnt1)，令mask和ans进行或运算。譬如

ans = 0b10010101000000
|
msk = 0b00000000100000
=
ans = 0b10010101100000
1
2
3
4
5
故代码为

k = cnt0 + cnt1
mask = (1 << k)
ans |= mask
1
2
3
将最低位连续的cnt1 - 1位均改为1
我们需要找到mask = (1 << k) - 1，其中k = (cnt1 - 1)，令mask和ans进行或运算。譬如

ans = 0b10010101100000
|
msk = 0b00000000000011
=
ans = 0b10010101100011
1
2
3
4
5
其中最后的-1操作，是为了让mask的末尾包含(cnt1 - 1)个1，即

msk = 0b00000000000100
↓
msk = 0b00000000000011
1
2
3
故代码为

k = cnt1 - 1
mask = (1 << k) - 1
ans |= mask