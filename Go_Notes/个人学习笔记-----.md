###  1.1.1. Go编译

- 词法与语法分析
  - 意义:解析源代码文件,将文件中字符串序列转换成Token序列
  - 把执行词法分析的程序称为词法解析器(lexer)
  - 语法解析的结果就是抽象语法树(AST)
  - 每个AST都对应一个单独的Go语言文件,这个抽象语法树中包括当前文件属于的包名,定义的常量,结构体和函数等
  - 如果发生错误,被语法解析器发现并将消息打印在标准输出上,编译过程直接中止
  - Go语言早期用lex做词法分析,后续还是使用Go语言实现词法分析器,自己写的词法分析器分析自己
- 类型检查和AST转换
  - 编译器对语法树中定义和使用的类型进行检查
  - 遍历抽象节点树,保证当前节点上不会出现类型错误
  - 不仅对类型进行检查,还会对内置函数进行展开和改写,比如`make`关键字在这个阶段会根据子树的结构被替换成`makeslice` 或者 `makechan` 等函数
- 通用SSA(静态单赋值)生成
  - 使用SSA特性,分析代码中无用变量和片段进行优化
  - 类型检查之后,就对Go语言项目全部函数进行编译,生成中间代码
  - 关键字和内置函数的功能其实是由语言的编译器和运行时共同完成的
- 机器代码生成
  - 根据机器不同,生成不同的机器码

### 1.1.2. 函数

#### 调用惯例

- C语言的函数的参数是通过寄存器和栈传递的
  - x86_64的机器,6个(含6个)的参数会按照顺序分别使用 edi、esi、edx、ecx、r8d 和 r9d 六个寄存器传递，超过 6 个的剩余参数会通过栈进行传递
  - 函数的返回是通过eax 寄存器进行传递的,所以不支持多个返回值
- Go语言传递和接收参数使用的都是栈
  - 但是需要注意,函数入参和出参的内存空间都需要调用方再栈上进行分配
  - 好处:
    - 能够降低实现的复杂度(不需要考虑超过寄存器个数的参数应该如何传递)
    - 更方便的兼容不同的硬件(不同cpu的寄存器差别比较大)
    - 函数可以具有多个返回值(栈上的内存地址相比寄存器的个人是无限的,使用寄存器支持多个返回值也会非常困难,超出寄存器多个返回值也需要使用栈来传递)
  - 通过堆栈传递参数,入栈的顺序都是从右到左
  - 函数返回通过堆栈传递并由调用者预先分配内存空间

#### 参数的传递

- 无论是传递基本类型,结构体还是指针,都会对传递的参数进行拷贝
- 指针作为参数传入某一个函数的时候,其实在函数内部会对指针进行复制,也就是会同时出现两个指针指向原有的内存空间,所以Golang传指针也是传值
- 调用函数都是传值,接收方会对入参进行复制再计算

### 1.1.3. 接口

其本质就是引入一个中间层对不同的模块进行解耦,上层的模块就不需要依赖某一个具体的实现! Go语言中的接口`interface` 不仅是一组方法,还是一种内置的类型

Go语言中所有的接口的实现都是隐式的

#### 接口类型

> interface{}类型并不表示任意类型, interface{}类型的变量再运行期间的类型只是interface{}
>
> go/src/runtime/runtime2.go#144

##### 带有一组方法的接口

- 表示成 `iface`结构体

```go
type iface struct {
    tab  *itab
    data unsafe.Pointer
}
Copy
```

##### itab结构体

```go
// layout of Itab known to compilers
// allocated in non-garbage-collected memory
// Needs to be in sync with
// ../cmd/compile/data-sync/gc/reflect.go:/^func.dumptypestructs.
type itab struct {
    inter *interfacetype
    _type *_type
    hash  uint32 // copy of _type.hash. Used for type switches.
    _     [4]byte
    fun   [1]uintptr // variable sized. fun[0]==0 means _type does not implement inter.
}
Copy
```

- `interfacetype` 是对 `_type`类型的简单封装
- `hash` 对 `_type.hash`的拷贝, 它会从 `interface` 到具体类型的切换时用于 快速判断目标类型和接口中类型是否一致
- `fun` 数组其实是一个动态大小的数组,如果数组中内容为空表示 `_type`没有实现`inter`接口,虽然这是一个大小固定的数组,但是在使用时会直接通过指针获取其中的数据并不会检查数组的边界,所以该数组中保存的元素数量是不确定的

##### 不带有任何方法的`interface{}`类型

- 表示成`eface`结构体
- 很常见,实现成一种特殊的类型

```go
type eface struct {
    _type *_type
    data  unsafe.Pointer
}
Copy
```

- `_type` 类型有点复杂.. 不看了..

#### 动态派发

运行期间选择具体的多态操作执行的过程,在Go语言中,对于一个接口类型的方法调用,会在运行期间决定具体调用该方法的哪个实现

动态派发会出现一些消耗,但一般项目中不可能只存在动态派发的调用,荔港南湾,如果开启默认的编译器优化,动态派发开销还会降低,所以对整体性能影响很小

结构体指针换成结构体,消耗区别有点大,原因是 Go 函数调用是值传递,会出现参数拷贝,所以对于大结构体,参数拷贝会消耗非常多资源,所以应该用指针来传递大结构体

### 1.1.4. 数组与切片

#### 数组

- 数组是由相同类型元素的集合组成的数据结构
- 数组大小在初始化之后就无法改变
- 编译期间,数组类型`Array`包含两个结构,一个是元素类型`Elem`, 另一个是数组的大小上限`Bound`,这两字段组成了数组类型
- 数组创建可以显式指定数组的大小,也可以根据源代码自定推断数组的大小,不过后者在编译期间会被转换前一种 -

##### 数组上限推导

- 显式创建,变量类型会在编译进行到 类型检查 阶段就会被推断出来
- 非显式创建,会在 编译进行 类型检查 时候也会创建一个 `Array` 类型,不过`Bound = -1` 后面会推到该数组大小
- 所以`[...]T`类型的声明不是在运行是被推导的,会在类型检查期间就被推断出正确的数组大小

##### 语句转换

- `[...]T{1, 2, 3}`与`[3]T{1, 2, 3}` 运行的时候 是等价的,理由如上
- 根据数组元素不同,会有不同的优化
  - 当元素数量小于或者等于4个时,会直接将数组中的元素放置在栈上
  - 当元素数量大于4个时,会将数组中的元素放置到静态区并在运行时取出
- 总结: 数组元素个数小于等于4个,所有变量会直接在栈上初始化,如果数组数量大于4个,变量就会在静态存储区初始化然后拷贝到栈上,转换后的代码才会进入 中间代码生成 和机器码生成阶段,最后生成可执行的二进制文件

##### 访问和赋值

- 数组在内存中其实就是一连串的内存空间,表示数组的方法就是一个指向数组开头的指针
- 数组访问越界的判断也是在编译期间由静态类型检查完成的
- 数组的赋值和更新 也会在生成SSA期间就计算出数组当前元素的内存地址,然后修改当前内存地址的内容
- 数组的寻址或者赋值都是编译阶段完成,没有运行时的参与

#### 切片

- 切片其实就是动态数组,长度不固定
- 切片在编译期间应该只会包含切片中的元素类型 `Slice{Elem: elem}`
- 切片的操作基本都是在编译期间完成的,除了访问切片的长度,容量或者其中的元素之外,使用`range`遍历切片时也是在编译期间被转换成了形式更简单的代码

##### 切片结构

```go
type SliceHeader struct {
    Data uintptr // 指向数组的指针
    Len  int // 当前切片长度
    Cap  int // 切片的容量
}
Copy
```

##### 切片初始化

- 字面量
  - `slice := []int{1, 2, 3}` -
- 关键字
  - slice := make([]int, 10)

##### 切片追加

- 追加`append` 会根据`inplace` 在中间代码生成阶段转换不同流程,一种是追加之后,不需要赋值回原有的变量`append(slice, 1, 2, 3)`,一种是需要赋值给原有的变量`slice = apennd(slice, 1, 2, 3)`

- 先对切片结构体进行解构获取数组指针,大小和容量,如果新切片大小大于容量,那么会使用

  ```go
  growslice
  ```

  对切片进行扩容并将新的元素依次加入切片并创建新的切片

  - 如果期望容量大于当前容量的两倍就会使用期望容量

  - 如果当前切片容连小于1024就会将容连翻倍

  - 如果当前切片容量大于1024就会每次增加25%的容量,知道新容量大于期望容量

    ```go
    func growslice(et *_type, old slice, cap int) slice {
    newcap := old.cap
    doublecap := newcap + newcap
    if cap > doublecap {
      newcap = cap
    } else {
      if old.len < 1024 {
          newcap = doublecap
      } else {
          for 0 < newcap && newcap < cap {
              newcap += newcap / 4
          }
          if newcap <= 0 {
              newcap = cap
          }
      }
    }
    Copy
    ```

- 确定了切片的容量,就可以算内存占用了, 内存占用= 目标容量* 元素大小

##### 切片拷贝

- `copy(a, b)` 会在编译期间转换成`slicecopy`函数
- 切片中全部元素通过`memmove`或者数组指针的方式将整块内存中的内容拷贝到目标的内存区域,所以大切片拷贝需要注意性能影响,不过比一个个的复制要有更好的性能

##### 数组和切片总结

- 数组大多都是在 编译期间都转换成内存的直接读写
- 切片很多功能都需要运行时的支持

### 1.1.5. 哈希表

- 哈希表示键值之间隐射关系

- 哈希函数
  - 理想状态是 不同的键映射到不同的唯一索引上,要求哈希函数的输出范围大于输入范围,但是实际使用时这种理想状态是不可能实现的

#### 哈希冲突解决

- 开放寻址法
  - 在一堆数组对元素进行探测和比较以判断待查找的目标键是否存在当前的哈希表中
  - 初始化哈希表时会创建一个新的数组,如果哈希表写入新的数据发生了冲突,就会将键值对写入到下一个不为空的位置
  - 查找时,按照我的理解,应该是先哈希key,找到对应的位置上,然后对比key,如果不一样,继续往下找,除非找到对应的key或者内存为空为止
  - 数组中元素数量与数组大小的比值叫做装载因子,随着装载因子增加,线性探索的评价用时就会逐渐增加,到百分之七十之后性能明显下降,一旦到百分之百,整个哈希表就会完全失效
- 拉链法
  - 实现比较简单,存储节点的内存是动态申请的,比较节省空间
  - 就是数组加上链表组合起来实现哈希表,数组中每个元素都是一个链表
  - 插入时,先对key进行hash,找到数组上对应的点(桶),然后遍历桶里的链表,如果有相同的就修改,没有就加在链表最末尾
  - 性能比较好的哈希表中,每个桶里大约有0或者1个元素,偶尔会有2到3个,很少会超过这个数

#### 结构

```go
type hmap struct {
    count     int // 用于记录当前哈希表元素数量,这个元素让我们不在需要去遍历整个哈希表来获取长度
    flags     uint8
    B         uint8  // 表示当前哈希表持有的 `buckets` 数量,因为哈希表扩容是以2倍进行的,所以这里会使用对数来存储, 简单理解成 `len(buckets) == 2^B` 
    noverflow uint16
    hash0     uint32 // 哈希的种子,这个值会在调用哈希函数时作为参数传入进去,主要作用是为哈希函数的结果引入一定的随机性

    buckets    unsafe.Pointer
    oldbuckets unsafe.Pointer // 哈希在扩容时用于保存之前的 `buckets`的字段,它的大小是当前`buckets`的一半
    nevacuate  uintptr

    extra *mapextra
}
Copy
```

#### 字面量

- 编译时用`maplit`进行初始化

- 当哈希表中元素数量小于等于25个时,编译器会调用`addMapEntries`将结构体转成单独的键值对,比如 hash["a"] = 1, hash["b"] = 2

- 当元素数量超过25个,会在编译期间创建两个数组分别存储键和值的信息,这些键值会通过一个for循环假如目标的哈希

  ```go
  hash := make(map[string]int, 26)
  vstatk := []string{"1", "2", "3", ... ， "26"}
  vstatv := []int{1, 2, 3, ... , 26}
  for i := 0; i < len(vstak); i++ {
    hash[vstatk[i]] = vstatv[i]
  }
  Copy
  ```

#### 运行时

- 编译期间`make`转换成`makemap`来创建哈希表
- 根据`B`算出需要创建的桶数量,在内存里分配一片连续空间用于存储数据,创建过程中,还会创建一些用于保存溢出数据的桶,数量 2^(B-4)个
- 哈希表的桶最多只能存储8个元素,如果超过8个,效率会下降,所以会进行扩容或者使用额外的桶存储溢出的数据,不会让桶里数据超过8个

#### 访问

- 类型检查阶段,类似`hash[key]`的`OINDEX`操作都会被转换成`OINDEXMAP`操作,中间代码生成阶段,在`walkexpr`中将这些`OINDEXMAP`转成

  ```go
  v     := hash[key] // => v     := *mapaccess1(maptype, hash, &key)
  v, ok := hash[key] // => v, ok := mapaccess2(maptype, hash, &key)
  Copy
  ```

- 当接收参数就一个时,使用`mapaccess1`函数,如果多加一个是否存在的布尔值就会使用`mapaccess2`

- 在这个函数中我们首先会通过哈希表设置的哈希函数、种子获取当前键对应的哈希，再通过 bucketMask 和 add 函数拿到该键值对所在的桶和哈希最上面的 8 位数字，这 8 位数字最终就会与桶中存储的 tophash 作对比，每一个桶其实都存储了 8 个 tophash，就是编译期间的 topbits 字段，每一次都会与桶中全部的 8 个 uint8 进行比较，这 8 位的 tophash 其实就像是一级缓存，它存储的是哈希最高的 8 位，而选择桶时使用了桶掩码使用的是最低的几位，这种方式能够帮助我们快速判断当前的键值对是否存在并且减少碰撞,每一个桶都是一整片的内存空间，当我们发现某一个 topbits 与传入键的 tophash 匹配时，通过指针和偏移量获取哈希中存储的键并对两者进行比较，如果相同就会通过相同的方法获取目标值的指针并返回。另一个同样用于访问哈希表中数据的 mapaccess2 函数其实只是在 mapaccess1 的基础上同时返回了一个标识当前数据是否存在的布尔值

#### 写入

- 当哈希表没有处于扩容状态并且装载因子超过了6.5或者存在了太多溢出的桶,调用`hashGrow`对当前哈希表进行扩容
- 装载因子是同时由 `loadFactorNum` 和 `loadFactDen` 两个参数决定的，前者在 Go 源代码中的定义是 13 后者是 2，所以装载因子就是 6.5
- 如果桶满了,会调用 `newoverflow` 创建一个新的桶或者使用`hmap`预先在`noverflow`中创建好的桶来保存数据,新创建的桶的指针会被追加到已有桶中,与此同时,溢出桶的创建会增加哈希表的`noverflow`计数器
- 如果哈希表存储的键值是指针类型,其实就会被当前的键值对分别申请一块新的内存空间,并在插入的位置通过`eypedmemmove`将键移动到申请的内存空间,最后返回键对应的地址

#### 扩容

- 如果扩容是溢出的桶太多,那么就是 `sameSizeGrow`
- 如果是一次不改变大小的扩容,`evacDst`结构体只会初始化一个,当哈希表容量翻倍时,一个桶中的元素会被分流到新创建的两个桶中,这两个桶会被`evacDst`数组引用

#### 删除

- `delete`关键字,将某一个键对应的元素从哈希表中删除,无论该键对应的值是否存在,这个内建的函数都不会返回任何的结果
- 如果在删除期间遇到哈希表的扩容,就会对即将操作的桶进行分流,随后找到桶中的目标元素并根据数据的类型调用`memclrHasPointers` 或者 `memclrNoHeapPointers` 函数完成键值对的删除
- `delete`在类型检查阶段被转换成`ODELETE`操作,然后在 `SSA中间代码生成`时被转换成`mapdelete`函数簇

#### 哈希表总结

- Go语言用拉链法来解决哈希碰撞
- 哈希在每一个桶中存储键对应哈希的前8位,当对哈希进行操作时,这些 `tophash`就成了一级缓存帮助哈希快速遍历桶中元素
- 每个桶只能存储8个键值对,一旦某个桶超过8个,新的键值对会被存储到哈希的溢出桶中
- 当键值对数量的增加,装载因子升高,到一定范围后,会出发扩容操作,扩容时将桶的数量分配,元素再分配的过程也是在调用写操作时增量进行的,不会造成性能的瞬时巨大波动

### 1.1.6. 字符串

- Go语言中的字符串是一个只读的字节数组切片
- 如果代码中存在的字符串,会被编译期间标记成只读数据`SRODATA`,但这只是表示这个字符串会被分配到只读的内存空间并且这段内存不会被修改,但是运行时,依然可以将这段内存拷贝到其他的堆或者栈上,同时将变量的类型修改成 `[]byte`,在修改之后通过类型转换变成`string`,如果想直接修改`string`类型变量的内存空间,是不支持的!

#### 结构

- 在运行时,用`StringHeader`结构体进行表示, 在运行时包的内部其实有一个私有的结构`stringHeader`, 它有着相同的结构,只是用于存储数据的`Data`字段使用了`unsafe.Pointer`类型

```go
type StringHeader struct {
    Data uintptr
    Len  int
}
Copy
```

##### 解析

- 解析器在 词法分析 时就完成的

- 两种字面量的方式可以声明字符串,一种是 双引号,一种是 使用反引号

  - 双引号用于简单的 单行的字符串,内部出现双引号需要用

     

    ```go
    \
    ```

     

    符号避免编译器的解析错误

    - 标准字符串使用双引号表示开头和结尾

    - 标准字符串中需要使用反斜线`\`来`escape`双引号

    - 标准字符串中不能出现隐式的换行符号

      ```go
      \n
      ```

      ```go
      str := "start
      end"
      Copy
      ```

  - 反引号 可以摆脱单行的限制,内部可以直接使用

    ```go
    "
    ```

    ,写

    ```go
    JSON
    ```

    或者其他数据时候非常方便

    - 只需要把非反引号的所有字符都划分到当前字符串的范围中

##### 拼接

- 使用`+`符号,编译器在检查阶段将`OADD`节点转换成`OADDSTR`类型的节点,然后在SSA中间代码生成的阶段调用`addstr`函数
- `addstr`函数在编译期间合选择合适的函数对字符串进行拼接,如果拼接字符串小于或者等于5个,那么活直接调用`concatstring{2,3,4,5}` 等一系列函数,如果超过5个就会直接选择`concatstrings`传入一个数组切片
- 不管选择哪个函数,最终都调用`concatstrings`,这个函数会先对传入的切片参数进行遍历,首先会过滤空字符串比国内获取拼接后的字符串长度

##### 类型转换

- `string(bytes)`会在编译期间转换成`slicebytetostring`的函数调用

- 字符串到字节数组转换使用

  ```go
  stringtoslicebyte
  ```

  - 使用传入的缓冲区或者根据字符串的长度调用`rawbyteslice`创建一个新的字节切片,`copy`关键字会将字符串中的内容拷贝到新的字节数组中

##### 字符串总结

- 字符串内容是只读,切片是可读写的,所以相互转换都是对内容进行拷贝,拷贝性能会因为字符串数组和字节长度的增长而增长,所以需要转换需要注意性能问题

### 1.1.7. for 和 range

- `for` 和 `for...range` 经过优化后,变成一样

- 结果是????

```go
func main() {
    arr := []int{1, 2, 3}
    for _, v := range arr {
        arr = append(arr, v)
    }
    fmt.Println(arr)
}
Copy
```

- 只遍历了切片里的元素,追加并不会导致循环次数增加,然后最后停了下来

```go
func main() {
    arr := []int{1, 2, 3}
    newArr := []*int{}
    for _, v := range arr {
        newArr = append(newArr, &v)
    }
    for _, v := range newArr {
        fmt.Println(*v)
    }
}
Copy
```

- 结果是 , 如何避免

- for 经典循环
- for...range 范围循环 编译器会在编译期间将带有`range`的循环变成普通的经典循环,这个过程发生在 SSA中间代码 阶段,所有的`range`都会被`walkrange` 函数转换成只包含基本表达式的语句,不包含任何复杂的结构

##### 遍历数组和切片

- 对于所以的`range`循环,Go语言都会在编译期间将原切片或者数组赋值给一个新的变量`ha`,在赋值的过程中其实就发生了拷贝,所以我们遍历的切片其实已经不是原有的切片变量了!
- 当同时遍历索引和元素的`range`循环时,Go语言会额外创建一个新的`v2`变量存储切片中的元素,循环中使用的这个变量v2会在每一次迭代中都被重新赋值,在赋值时也发生了拷贝, 所以我们想要访问数组中元素所在的地址,不应该直接获取`range`返回的`v2`变量的地址`&v2`,想要解决这个问题应该使用`&a[index]`这种方式获取数组中元素对应的地址

##### 遍历哈希

- 哈希表遍历会随机(`fastrand`函数)选择开始的位置,然后依次遍历桶中的元素,桶中元素如果被遍历完,就会遍历当前桶对应的溢出桶,溢出桶都遍历结束之后才会遍历哈希中下一个桶,直到所有的桶都被遍历完

##### 遍历字符串

- 遍历过程中会获取字符串中索引对应的字节,然后将字节转换成`rune`,我们在遍历字符串时拿到的值都是`rune`类型的变量

##### 遍历通道

- 循环会使用`<-ch`从管道中取出等待处理的值,这个操作会调用`chanrecv2`并阻塞当前的协程,当`chanrecv2`返回时会根据`hb`来判断当前的值是否存在,如果不存在就意味着当前的管道已经被关闭了,在正常情况下都会为`v1`赋值并清除`hv1`中的数据,然后会陷入下一次的阻塞等待接受新的数据

### 1.1.8. defer

- 作用域结束之后执行函数的关键字
- `defer`实现是由编译器和运行时共同完成的

```go
func main() {
    {
        defer fmt.Println("defer runs")
        fmt.Println("block ends")
    }

    fmt.Println("main ends")
}
Copy
```

- 不是在当前代码块的作用域时执行的, `defer`只会在当前函数和方法返回之前被调用

```go
type Test struct {
    value int
}

func (t Test) print() {
    println(t.value)
}

func main() {
    test := Test{}
    defer test.print()
    test.value += 1
}
Copy
```

稍微改动一下

```go
type Test struct {
    value int
}

func (t *Test) print() {
    println(t.value)
}

func main() {
    test := Test{}
    defer test.print()
    test.value += 1
}
Copy
```

- 还是进行的值传递,不过发生复制的是指向`test`的指针,上面那个复制的是结构体,这段是复制的指针,修改`test.value`时,`defer`捕获的指针其实就能够访问到修改后的变量了

##### 实现原理

```go
type _defer struct {
    siz     int32
    started bool
    sp      uintptr
    pc      uintptr
    fn      *funcval
    _panic  *_panic
    link    *_defer
}
Copy
```

- `sp`和`pc`分别指向了栈指针和调用方的程序计数器,`fn`存储的就是向`defer`关键字中传入的函数
- `defer` 关键字在编译期间的SSA阶段才被`stmt`函数处理的,中间详情不表
- 运行时,每一个`defer`关键字都会被转换成`deferproc`,这个函数里会为`defer`创建一个新的`_defer`结构体并设置它的`fn`,`pc`和`sp`参数,并将`defer`相关的函数都拷贝到紧挨着结构体的内存空间中

##### 总结

- `defer`关键字会在编译阶段被转换成`deferproc`的函数并在函数返回之前插入`deferreturn`指令,在运行期间,每一次`deferproc`的调用都会将一个新的`_defer`结构体追加到当前Goroutine持有的链表头,而`deferreturn`会从Goroutine中取出`_defer`结构并以此执行,所有的`_defer`结构执行成功之后当前函数才返回!

### 1.1.9. panic 和 recover

- panic 能改变程序的控制流,当函数调用执行panic,它会立刻停止执行函数其他的代码,而是会运行其中的`defer`函数,执行成功返回到调用方
- 调用导致panic和直接调用`panic`类似,执行所有的`defer`函数并返回到它的调用方,这个过程会一直进行到当前的Goroutine的调用栈不包含任何的函数,这时整个程序才会崩溃
- `panic`导致的`恐慌`状态其实可以被`defer`中的`recover`中止,`recover`是一个只在`defer`中能够发挥作用的函数,在正常的控制流程中,`recover`会直接返回`nil`并没有任何的作用,如果当前的Goroutine发生了`恐慌`,`recover`就能够捕获到`panic`抛出的错误并阻止`恐慌`的继续传播

##### 数据结构

```go
type _panic struct {
    argp      unsafe.Pointer // 指向`defer`调用时参数的指针
    arg       interface{} // 调用`panic`时传入的参数
    link      *_panic // 指向更早调用的`_panic`结构
    recovered bool // 当前的`_panic`是否被`recover` 恢复
    aborted   bool // 表示当前的`panic`是否被强行终止
}
Copy
```

1. 获取当前`panic`调用所在的Goroutine协程
2. 创建并初始化一个 `_panic`结构体
3. 从当前Goroutine的链表获取一个`_defer`结构体
4. 如果当前的`_defer`存在,调用`reflectcall`执行`_defer`中的代码
5. 将下一位的`_defer`结构设置到Goroutine上并返回到3
6. 调用`fatalpanic`中止整个程序(会在中止整个程序之前可能会通过`printpanics`打印出全部的`panic`消息以及调用时传入的参数)

##### panic和recover总结

- 编译过程中会将`panic`和`recover` 分别转换成`gopanic` 和`gorecover`函数,同时将`defer`转换成`deferproc` 函数并在调用`defer`的函数和方法末尾增加`deferreturn`的指令

- 在运行过程中遇到`gopanic`方法时,会从当前Goroutine中取出`_defer`的链表并通过`reflectcall`调用用于收尾的函数

- 如果在

  ```go
  reflectcall
  ```

  调用时遇到了

  ```go
  gorecover
  ```

  就会直接将当前的

   

  ```go
  _panic.recovered
  ```

  标记成

  ```go
  true
  ```

  并返回

  ```go
  panic
  ```

  传入的参数(在这时

  ```go
  recover
  ```

  就能够获取到

  ```go
  panic
  ```

  的信息)

  - 在这次调用结束后,`gopanic`会从`_defer`结构体中取出程序计数器`pc`和栈指针`sp`并调用`recovery`方法进行恢复
  - `recovery`会根据传入的`pc`和`sp`跳转到`deferproc`函数
  - 编译器自动生成的代码会发现`deferproc`的返回值不为`0`,这时就会直接跳到`deferreturn`函数中并恢复到正常的控制流程(依次执行剩余的`defer`并正常退出)

- 如果没有遇到`gorecover`就会一次遍历所有的`_defer`结构,并在最后调用`fatalpanic`中止程序,打印`panic`参数并返回错误码`2`


## 1.2. 定时器

```go
type timer struct {
    tb *timersBucket
    i  int

    when   int64
    period int64
    f      func(interface{}, uintptr)
    arg    interface{}
    seq    uintptr
}
Copy
```

- `timer` 就是 Golang 定时器内部表示,每一个`timer` 其实都存在堆中

- `tb` 就是用于存储当前定时器的桶

- `i` 是当前定时器在堆中的索引,可以通过这两个变量找到当前定时器在堆中的位置

- `when` 表示当前定时器(Timer) 被唤醒的时间

- `period` 表示两次被唤醒的间隔,每当定时器被唤醒时都会调用`f(args,now)` 函数并传入`args` 和当前时间作为参数

- 这里的`timer`作为一个私有结构体其实只是定时器的运行时表示,`time` 包对外暴露的定时器是如下结构

  ```go
  type Timer struct {
    C <-chan Time
    r runtimeTimer
  }
  Copy
  ```

- `Timer` 定时器必须通过`NewTimer` 或者 `AfterFunc` 函数进行创建,其中的`runtimeTimer` 其实就是上面的`timer`结构体, 当定时器失效时,失效的时间就会被发送给当前定时器持有的Channel`C`, 订阅管道中消息的Goroutine就会接收到当前定时器失效的时间

##### 创建

- ```go
  time
  ```

   

  包对外提供了两种创建定时器的方法

  - `NewTimer` 接口创建用于通知触发时间的Channel,调用 `startTimer` 方法并返回一个创建指向`Timer`结构体的指针

  - `AfterFunc` 也提供了相似的结构,与上面不同的是,它只会在定时器到期时调用传入的方法

  - ```go
    startTimer
    ```

    是创建定时器的入口,所有的定时器的创建和重启基本上都需要这个函数

    - 调用`addTimer`函数,首先通过`assignBucket`方法为当前定时器选择一个`timersBucket` 桶,根据当前的Goroutine所在处理器P的id选择一个合适的桶,随后调用`addTimerLocked`方法将当前定时器加入桶中
    - `addtimerLocked` 会先将最新加入的定时器加到队列的末尾,随后调用`siftipTimer`将当前定时器与四叉树(或者四叉堆)中的父节点进行比较,保证父节点的到期时间一定小于子节点

##### 触发

- 定时器的触发都是由`timerproc`中的一个双层`for`循环控制的,外层的`for`循环主要负责对当前的`Goroutine` 进行控制,它不仅会负责锁的获取和释放,还会在合适的时机触发当前Goroutine的休眠
- 内部循环
  - 如果桶中不包含任何定时器就会直接返回并陷入休眠等待定时器加入当前桶
  - 如果四叉树最上面的定时器还没有到期会通过`notetsleepg`方法陷入休眠等待最近定时器的到期
  - 如果四叉树最上面的定时器已经到期
    - 当定时器 `preiod > 0` 就会设置下一次会触发定时器的时间并将当前定时器向下移动到对应位置
    - 当定时器`preios <= 0` 就会将当前定时器从四叉树中移除
  - 在每次循环的最后都会从定时器中取出定时器中的函数,参数 和序列号并调用函数触发该计数器
- 使用`NewTimer`创建的定时器,传入的函数时`sendTime`,它会将当前时间发送到定时器持有的Channel中,而使用`AfterFunc` 创建的定时器,在内层循环中调用的函数就会是调用方法传入的函数了

##### 休眠

- `timeSleep` 会创建一个新的`timer`结构体,在初始化的过程中我们会传入当前Goroutine 应该被唤醒的时间以及唤醒时需要调用的函数`goroutineReady`,随后会调用 `goparklock` 将当前GOroutine陷入休眠状态,当定时器到期时也会调用 `goroutineReady` 方法唤醒当前的Goroutine
- `time.Sleep` 方法其实只是创建了一个会在到期时唤醒当前Goroutine的定时器并通过`goparkunlock`将当前的协程陷入休眠状态等待定时器触发的唤醒

##### Ticker

- 除了只用于一次的定时器(Timer)之外,Go语言的`time`包中还提供了用于多次通知的`Ticker`计时器,计时器中包含了一个用于接受通知的Channel 和一个定时器,这个两个字段组成了用于连续多次触发事件的计时器
- 想要在Go中创建一个计时器只有两种方法,一种是使用`NewTicker`方法显示的创建`Ticker`计时器指针,另一种可以直接通过`Tick`方法获取一个会定期发送消息的Channel
- 每一个`NewTicker`方法开启的计时器都需要在不需要使用时调用`Stop`进行关闭,如果不显示调用`Stop`方法,创建的计时器就没有办法被垃圾回收,而通过`Tick`创建的计时器由于只对外提供了Channel,所以是一定没有办法关闭的,我们一定要谨慎使用这一接口创建计时器

##### 性能分析

- 定时器在内部使用四叉树的方式进行实现和存储,高并发的场景下会有比较明显的性能问题

## 1.3. 同步原语与锁

- 锁的主要作用就是保证多个线程或者Goroutine在访问同一片内存时不会出现混乱的问题
- 锁其实是一种并发编程中的同步原语(Synchronization Promitives)

#### 基本原语

- Go语言在 `sync` 包中提供了用于同步的一些基本原语,包括常见的互斥锁`Mutex` 与读写互斥锁 `RWMutex`以及 `Once`, `WaitGroup`

##### Mutex

- Go语言中的互斥锁在`sync`中, 由`state` 和`sema` 组成, `state` 表示 当前互斥锁的状态, 而`sema` 真正用于控制锁状态的信号量, 这两个加起来只占8字节空间的结构体就表示了Go语言中的互斥锁

  ```go
  type Mutex struct {
    state int32
    sema  uint32
  }
  Copy
  ```

- 互斥锁的状态是用`int32`来表示的,但是锁的状态并不是互斥的,它的最低三位分别表示`mutexLocked`,`mutexWoken`,`mutexStarving`,剩下的位置都用来表示当前有多少个Goroutine等待互斥锁被释放

- 互斥锁在被创建出来时,所有的状态位的默认值都是`0`,当互斥锁被锁定时,`mutexLocked` 就会被置成`1`,当互斥锁被在正常模式下被唤醒`mutexWoken`就会被置成`1`,`mutexStarving`用于表示当前的互斥锁进入了状态,最后的几位是在当前互斥锁上等待的Goroutine个数

##### 饥饿模式 ✦ ✦ ✦ ✦

- 饥饿模式是在Go语音`1.9`版本引入的特性,主要功能就是保证互斥锁的获取的`公平性`
- 互斥锁可以同时处于两种不同的模式,也就是正常模式和饥饿模式, 在正常模式下,所有锁的等待者都会按照先进先出的顺序获得锁,但是如果一个刚刚被唤醒的 Goroutine 遇到了新的Goroutine 进程也调用了 Lock 方法时,大概率获取不到锁,为了减少这种情况的出现,防止Goroutine被 饿死, 一旦 Goroutine超过1ms 没有获取到锁,它就会将当前互斥锁切换饥饿模式
- 在饥饿模式中,互斥锁会被直接交给等待队列最前面的 Goroutine,新的Goroutine在这时不能获取锁,也不会进入自旋的状态,它们只会在队列的末尾等待,如果一个Goroutine获得了互斥锁并且它是队列中最末尾的协程或者它等待的时间少于1ms,那么当前的互斥锁就会被切换回正常模式
- 相比于饥饿模式,正常模式下的互斥锁能够提供更好的性能,饥饿模式的主要作用就是避免一些Goroutine由于陷入等待无法获取锁而造成较高的尾延迟,这也是对`Mutex`的一个优化

##### 加锁

> 饥饿模式不会进入进入自旋,那么如果是正常模式转成饥饿模式,自旋还有么??????

- 互斥锁`Mutex`的加锁是靠`Lock` 方法完成的,最新的 Go语言源代码中已经将`Lock` 方法进行了简化,方法的主干只保留了最常见,简单并且快速的情况,当锁的状态是 `0` 时直接将`mutexLocked` 位置成 `1`

- 当`Lock` 方法被调用时`Mutex`的状态不是 `0` 时就会进入 `lockSlow` 方法尝试通过自旋或者其他方法等待锁的释放并获取互斥锁

- 自旋其实是在多线程同步的过程中使用的一种机制,当前的进程在进入自旋的过程中会一直保持CPU的占用,持续检查某个条件是否为真,在多核的CPU上,自旋的优点是避免了Goroutine的切换,如果使用恰当会对性能带来非常大的增益

- 在 Go语言 的

   

  ```go
  Mutex
  ```

  互斥锁中,只有在普通模式下才可能进入自旋,除了模式的限制之外,

   

  ```go
  runtime_canSpin
  ```

   

  方法中会判断当前方法是否可以进入自旋,进入自旋的条件非常苛刻

  - 运行在多CPU的机器上
  - 当前Goroutine 为了获取该锁进入自旋的次数小于四次
  - 当前机器上至少存在一个正在运行的处理器`P`并且处理的运行队列是空的

- `runtime_SemacquireMutex` 方法主要作用就是通过`Mutex`的使用互斥锁中的信号量保证资源不会被两个Goroutine获取,从这里我们就能看出`Mutex`其实就是对更底层的信号量进行封装,对外提供更加易用的API,`runtime_SemacquireMutex` 会在方法中不断调用 `goparkunlock`将当前 Goroutine陷入休眠等待信号量可以被获取,

- 一旦当前Goroutine 可以获取信号量,就证明互斥锁已经被解锁,该方法就会立刻返回,`Lock`方法的剩余代码也会继续执行下去了,当前互斥锁处于饥饿模式时,如果该Goroutine是队列中最后的一个Goroutine 或者等待锁的时间小于 `starvationThresho1dNs(1ms)` 当前Goroutine 就会直接获得互斥锁并且从饥饿模式中退出并获得锁

##### 解锁

- 互斥锁的解锁过程相比之下就非常简单,`Unlock` 方法会直接使用`atomic` 包提供的`AddInt32`,如果返回的新状态不等于 `0` 就会进入 `unlockSlow` 方法
- `unlockSlow` 方法首先会对锁的状态进行校验,如果当前互斥锁已经被解锁过了就会直接抛出异常`sync: unlock of unlocked mutex` 中止当前程序,在正常情况下会根据当前互斥锁的状态是正常模式还是饥饿模式进入不同的分支!
- 如果当前互斥锁的状态是饥饿模式就会直接调用`runtime_Semrelease` 方法直接将当前锁交给下一个正在正在尝试获取锁的等待者,等待者会在被唤醒之后设置`mutexLocked`状态,由于此时仍然处于`mutexStarving`,所以新的Goroutine也无法获得锁
- 在正常模式下,如果当前互斥锁不存在等待者或者最低三位表示的状态都是0, 那么当前方法就不需要唤醒其他Goroutine可以直接返回,当有 Goroutine 正在处于等待状态时,还是会通过`runtime_Semrelease` 唤醒对应的 Goroutine并移交锁的所有权

##### 总结

- 如果互斥锁处于初始化状态,就会直接置位`mutexLocked`加锁
- 如果互斥锁处于`mutexLocked` 并且在普通模式下工作,就会进入自旋,执行30次`PAUSE`指令消耗CPU时间等待锁的释放
- 如果当前Goroutine等待锁的时间超过了1ms,互斥锁就会被切换到饥饿模式
- 互斥锁在正常情况下会通过`runtime_SemacquireMutex`方法将调用`Lock`的 Goroutine 切换至休眠状态,等待持有信号量的Goroutine唤醒当前协程
- 如果当前Goroutine 是互斥锁上的最后一个等待的协程或者等待的时间小于1ms,当前的Goroutine会将互斥锁切回正常模式
- 如果互斥锁已经被解锁,那么调用`Unlock`会直接抛出异常
- 如果互斥锁处于饥饿模式,会直接将锁的所有权交给队列中的下一个等待者,等待者会负责设置`mutexLocked`标志位
- 如果互斥锁处于普通模式,并没有Goroutine等待锁的释放或者已经有被唤醒的Goroutine获得了锁就会直接返回,在其他情况下会通过`runtime_Semrelease`唤醒对应的Goroutine

#### RWMutex

- 读写互斥锁在Go语音中的实现是 `RWMutex`,其中不仅包含一个互斥锁,还持有两个信号量,分别用于写等待读和读等待写

  ```go
  type RWMutex struct {
    w           Mutex
    writerSem   uint32
    readerSem   uint32
    readerCount int32
    readerWait  int32
  }
  Copy
  ```

- `readerCount` 存储了当前正在执行的读操作的数量,最后的`readerWait`表示当写操作被阻塞时等待的读操作个数

##### 读锁

- 读锁的加锁非常简单,通过`atomic.AddInt32`方法为`readerCount`加一,如果该方法返回了负数说明当前有Goroutine获得了写锁,当前Goroutine就会调用`runtime_SemacquireMutex`陷入休眠等待唤醒
- 如果没有写操作获取当前互斥锁,当前方法就会在`readerCount`加一后返回,当Goroutine想要释放读锁时会调用`RUnlock`方法,该方法会减少正在读资源的`readerCount`,当前方法如果遇到了返回值小于零的情况,说明有一个正在进行的写操作,在这时就应该通过`rUnlockSlow`方法减少当前写操作等待的读操作数`readerWait`并在所有都被释放之后出发写操作的信号量`writerSem`,`writerSem`被触发之后,尝试获取读写锁的进程就会被唤醒并获得锁

##### 读写锁

- 当资源的使用者想要获取读写锁时,就需要通过`Lock` 方法了,在`Lock` 方法中首先调用了读写互斥锁持有的`Mutex`的`Lock`方法保证其他获取读写锁的Goroutine 进入等待状态,随后的`atomic.AddInt32(&rw.readerCount, -rwmutexMaxReaders)` 其实是为了堵塞后续的读操作
- 如果当时仍然有其他Goroutine持有互斥锁的读锁,该Goroutine就会调用`runtime_SemacquireMutex`进入休眠状态,等待读锁释放时触发`writerSem`信号量将当前协程唤醒
- 对资源的读写操作完成之后就会将通过`atomic.AddInt32(&rw.readerCount, rwmutexMaxReaders)` 变回正数并通过for循环出发所有由于获取读锁而陷入等待的`Goroutine`
- 最后,`RWMutex` 会释放持有的互斥锁让其他的协程能够重新获取读写锁

##### 总结

- `readerSem` - 读写锁释放时通知由于获取读锁等待的Goroutine
- `writerSem` - 读锁释放时通知由于获取读写锁等待的Goroutine
- `w`互斥锁 - 保证写操作之间的互斥
- `readerCount` - 统计当前进行读操作的协程数,触发写锁时会将其减少`rwmutexMaxReaders`阻塞后续的读操作
- `readerWait` - 当前读写锁等待的进行读操作的协程数,在出发`Lock`之后的每次`RUnlock`都会将其减一,当它归零时该Goroutine就会获得读写锁
- 当读写锁被释放`Unlock`时首先通知所有的读操作,然后才会释放持有的互斥锁,这样能够保证读操作不会被连续的写操作`饿死`

#### WaitGroup

- `WaitGroup` 是Go语言`sync` 包中比较常见的同步机制,它可以用于等待一系列的Goroutine的返回,一个比较常见的使用场景是批量执行RPC或者调用外部服务

- 通过`WaitGroup` 我们可以在多个Goroutine之间非常轻松的同步信息,原本顺序执行的代码也可以在多个Goroutine中并发执行,加快了程序处理的速度

  ```go
  type WaitGroup struct {
    noCopy noCopy
  
    state1 [3]uint32
  }
  Copy
  ```

- `noCopy` 的主要作用就是保证`WaitGroup` 不会被开发者通过再赋值的方式进行拷贝,进而导致一些诡异的行为

- `copyLock` 包就是一个用于检测类似错误的分析器,它的原理就是在 编译期间 检查被拷贝的变量中是否包含的`noCopy` 或者`sync` 关键字

- 除了`noCopy`之外,`WaitGroup` 结构体中还包含一个总共占用12字节大小的数组,这个数组中会存储当前结构体持有的状态和信号量,在64位与32位机器上表现也非常不同

- `WaitGroup`提供了私有方法 `state`能够帮助我们从`state1`字段中取出它的状态和信号量

- `WaitGroup` 对外暴露的接口只有三个`Add`,`Wait`和`Done`,其中`Done` 只是调用了`wg.Add(-1)`

- `Add`方法的主要作用就是更新`WaitGroup`中持有的计数器`counter`,64位状态的高32位,虽然`Add`方法传入的参数可以为负数,但是一个`WaitGroup`的计数器只能是非负数,当调用`Add`方法导致计数器归零并且还有等待的Goroutine时,就会通过`runtime_Semrelease` 唤醒处于等待状态的所有Goroutine

- 另一个`WaitGroup`的方法`Wait`就会在当前计数器中保存的数据大于0 时修改等待Goroutine 的个数`waiter`并调用 `runtime_Semacquire`陷入睡眠状态

- 陷入睡眠的`Goroutine` 就会等待`Add`方法在计数器为 0 时唤醒

###### 总结

- `Add`不能在和`Wait` 方法在 Goroutine 中并发调用,一旦出现就会造成程序崩溃
- `WaitGroup` 必须在 `Wait` 方法返回之后才能被重新使用
- `Done` 只是对`Add` 方法的简单封装,我们可以向`Add`方法传入任意负数(需要保持计数器非负)快速将计数器归零以唤醒其他等待的Goroutine
- 可以同时有多个Goroutine等待当前`WaitGroup` 计数器的归零,这些Goroutine也会被同时唤醒


#### Cond

- Go语言在标准库中提供的`Cond` 其实是一个条件变量,通过`Cond`我们可以让一系列的 Goroutine 都在触发某个事件或者条件时才被唤醒,每一个`Cond`结构体都包含一个互斥锁`L`

  ```go
  type Cond struct {
    noCopy noCopy
  
    L Locker
  
    notify  notifyList
    checker copyChecker
  }
  Copy
  ```

- `Cond` 结构体中包含`noCopy` 和 `copyChecker` 两个字段,前者用于保证`Cond` 不会再编译期间拷贝,后者保证在运行期间发生拷贝会直接`panic`,持有的另一个锁`L`其实是一个接口`Locker`,任意实现`Lock`和`Unlock`方法的结构体都可以作为`NewCond`方法的参数

- 结构体中的最后的变量`notifyList` 其实也就是为了实现`Cond`同步机制,该结构体其实就是一个Goroutine的链表

- `Cond` 对外暴露的`Wait` 方法会将当前Goroutine陷入休眠状态,它会先调用`runtime_notifyListAdd`将等待计数器 +1,然后解锁并调用 `runtime_notifyListWait` 等待其他Goroutine的唤醒

- `notifyListWait` 方法的主要作用就是获取当前的Goroutine并将它追加到 `notifyList`链表的最末端

- 除了将当前Goroutine追加到链表的最末端之外,我们还会调用`goparkunlock`陷入睡眠状态,该函数也是在Go语音切换Goroutine 时经常会使用的方法,它会直接让当前处理器的使用权并等待调度器的唤醒

- `Cond`对外提供的`Signal` 和 `Broadcast` 方法就是用来唤醒调用`Wait`陷入休眠的Goroutine,前者会唤醒队列最前面的Goroutine,后者会唤醒队列中全部的Goroutine

- `notifyListNotifyAll`方法会从链表中取出全部的Goroutine并为他们依次调用 `readyWithTime`, 该方法会通过`goready` 将目标的Goroutine 唤醒

- 虽然它会唤醒全部的Goroutine,但是这里唤醒的顺序其实还是按照加入队列的先后顺序,先加入的会先被`goready`唤醒,后加入的Goroutine可能就需要等待调度器的调度

- `notifyListNotifyOne` 函数就只会从 `sudog` 构成的链表中满足 `sudog.ticket == l.notify`的Goroutine并通过`readyWithTime`唤醒

- 在一般情况下我们会选择在不满足特定条件时调用`Wait`陷入休眠,当某些Goroutine检测到当前满足了唤醒的条件,就可以选择使用`Signal`通过一个或者 `Broadcast`通知全部的Goroutine当前条件已经满足,可以继续完成工作了

##### 总结

- 与`Mutex` 相比,`Cond`还是一个不被所有人都清楚和理解的同步机制,它提供了类似队列的FIFO的等待机制,同时也提供了`Signal` 和 `Broadcast` 两种不同的唤醒方法,相比于使用`for{}` 忙碌等待,使用`Cond`能够在遇到长时间条件无法满足时将当前处理器让出的功能,如果我们合理使用还是能够在一些情况下提升性能
- `Wait`方法在调用之前一定要使用`L.Lock` 持有该资源,否则会发生`panic`导致程序崩溃
- `Signal`方法唤醒Goroutine都是队列最前面 等待最久的Goroutine
- `Broadcast`虽是广播通知等待的Goroutine,但是真正被唤醒时也是按照一定顺序的




# Interview 问题

java线程池与go携程池的区别
map与sync.map底层
sync.map高并发怎样
有没有改进它的思路
代码:根据输入的文件名称，打印出文件树状结构。
如何设计一个高并发的系统 



clickhouse 原理  sql注意啥
微服务数据一致性


二维码扫描实现


mutux, rxmutux区别 

https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/

一个表超大数据，分页查询怎么才能尽可能的快，如何优化大分页查询？

慢sql的排查与优化以及解决思路

1. 1. 混合写屏障
   2. java的垃圾回收机制

   简单谈一下java与go，优缺点

1. 1. go协程和java线程的不同


1. 1. GMP

1. 1. 1. 简单讲解一下
      2. 本地队列的数量多少个
      3. golang是否支持抢占式调度？

1. 1. 1. 1. 哪几种场景会进行抢占式调度？

1. 1. 1. 1. 1. 怎么保持cpu一直不被协程占用的呢，满足什么条件会退出呢？通过什么方式来进行切换的？

1. 1. 1.  g0线程(协程)和m0线程一般都担当什么职责？

1. 1. 怎么保持全部协程执行完毕，主协程再退出？
   2. make和new的区别？
   3. 进程、线程、协程之间的区别？

1. 1. 1. 为什么线程的上下文切换比进程快很多？
      2. 线程的资源分配到哪里？
      3. 线程的资源是每个线程独享的吗、还是共享的？

1. 1. GMP中本地队列有256个，一个G绑定一个P的时候，跟它的M不是配对的嘛？当他们都绑定之后，在本地最多可以执行多少个g？可以说在p中最多可以存储多少个g来执行？一个p中最多可以存储多少个g？肯定是高于256个，至于多几个，多在什么地方知道吗？本地存储到多少个队列的时候会全局队列里放？
   2. 当我在执行本地队列里的goroutine的时候，比如说本地队列的256是满的，这个时候我去输出我执行的goroutine，他是全部从本地队列去拿还是会夹杂着全局队列？（限定一下，当我在执行的时候，把goMaxProxy限定为1，打300个goroutine进去，输出的时候会输出到全局队列吗？前256会有全局队列吗）
   3. GC

1. 1. 1. 说一下GC
      2. JAVA的GC用的什么算法 
      3. GC在哪几种场景下会触发？

1. java

1. 1. aio、bio、nio的区别？https://blog.csdn.net/meism5/article/details/89469101
   2. 阻塞、非阻塞？
   3. 同步、异步？

1. go和java对比

1. 1. go struct和java 类有什么不一样的？
   2. 一个struct想要复用另外一个struct的成员的话怎么做？
   3.  java里面实现接口和go实现接口有啥区别？



1. 1. **进程和线程的区别？**

1. 1. 1. 调度：进程是资源管理的基本单位，线程是程序执行的基本单位。

并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行
切换：线程上下文切换比进程上下文切换要快得多。
拥有资源： 进程是拥有资源的一个独立单位，线程不拥有系统资源，但是可以访问隶属于进程的资源。
系统开销： 创建或撤销进程时，系统都要为之分配或回收系统资源，如内存空间，I/O设备等，OS所付出的开销显著大于在创建或撤销线程时的开销，进程切换的开销也远大于线程切换的开销。

1. 1. **go里边的协程？**

1. 1. 1. 进程：是应用程序的启动实例，每个进程都有独立的内存空间，不同的进程通过进程间的通信方式来通信。

线程：从属于进程，每个进程至少包含一个线程，线程是 CPU 调度的基本单位，多个线程之间可以共享进程的资源并通过共享内存等线程间的通信方式来通信。

协程：为轻量级线程，与线程相比，协程不受操作系统的调度，协程的调度器由用户应用程序提供，协程调度器按照调度策略把协程调度到线程中运行

1. 1. **编译的几个环节？**
1）先要识别出句子中的一个个单词；

（2）分析句子的语法结构；

（3）根据句子的含义进行初步翻译；

（4）对译文进行修饰；

（5）写出最后的译文。


计数器

```go
package statistics

import (
	"sync"
)

var GpsClient = new(dataMap)

var CanClient = new(dataMap)

type statistic interface {
	IncSuccess() uint64
	IncError() uint64
	GetSuccess() uint64
	GetError() uint64
	GetCount() uint64
}

type dataMap struct {
	dataType string
	success  uint64
	error    uint64
	sync.Mutex
}

func (d *dataMap) IncSuccess() uint64 {
	d.Lock()
	defer d.Unlock()
	d.success ++
	return d.success
}

func (d *dataMap) IncError() uint64 {
	d.Lock()
	defer d.Unlock()
	d.error ++
	return d.error
}

func (d *dataMap) GetSuccess() uint64 {
	d.Lock()
	defer d.Unlock()
	return d.success
}

func (d *dataMap) GetError() uint64 {
	d.Lock()
	defer d.Unlock()
	return d.error
}

func (d *dataMap) GetCount() uint64 {
	d.Lock()
	defer d.Unlock()
	count := d.success + d.error
	return count
}
```

```go
/**
	功能：实现一个计数器模块，不依赖外部三方模块和存储，
	要求进程内协程安全、异步、高性能按指标 key-value 统计。
 */
package main

import (
	"fmt"
	"time"
	"./statistics"
)

func main(){
	go Task()

	for {
		func() {
			fmt.Printf("can: success = %d \n",statistics.CanClient.IncSuccess())
			fmt.Printf("can: error = %d \n",statistics.CanClient.IncError())
		}()

		time.Sleep(time.Second)
		fmt.Printf("can: error = %d \n",statistics.CanClient.GetError())
		fmt.Printf("can: count = %d \n",statistics.CanClient.GetCount())
	}

}

func Task() {
	for {
		func() {
			fmt.Printf("gps:success = %d\n", statistics.GpsClient.IncSuccess())
		}()
		time.Sleep(time.Second)
		fmt.Printf("gps count = %d \n", statistics.GpsClient.GetCount())
	}
}
```


输出是什么
fmt.Printf("string size: %d\n", unsafe.Sizeof("Y4ergesdgergw4ge4saefgsadgf"))



限流策略：令牌桶，漏桶


unsafe包 ------ TBD


## 零、go与其他语言

### 0、什么是[面向对象](https://so.csdn.net/so/search?q=面向对象&spm=1001.2101.3001.7020)

在了解 Go 语言是不是面向对象（简称：OOP） 之前，我们必须先知道 OOP 是啥，得先给他 “下定义”

根据 Wikipedia 的定义，我们梳理出 OOP 的几个基本认知：

- 面向对象编程（OOP）是一种基于 “对象” 概念的编程范式，它可以包含数据和代码：数据以字段的形式存在（通常称为属性或属性），代码以程序的形式存在（通常称为方法）。
- 对象自己的程序可以访问并经常修改自己的数据字段。
- 对象经常被定义为类的一个实例。
- 对象利用属性和方法的私有/受保护/公共可见性，对象的内部状态受到保护，不受外界影响（被封装）。

基于这几个基本认知进行一步延伸出，面向对象的三大基本特性：

- 封装
- 继承
- 多态

### 1、Go语言和Java有什么区别? 

1、Go上不允许函数重载，必须具有方法和函数的唯一名称，而Java允许函数重载。

2、在速度方面，Go的速度要比Java快。

3、Java默认允许多态，而Go没有。

4、Go语言使用HTTP协议进行路由配置，而Java使用Akka.routing.ConsistentHashingRouter和Akka.routing.ScatterGatherFirstCompletedRouter进行路由配置。

5、Go代码可以自动扩展到多个核心，而Java并不总是具有足够的可扩展性。

6、Go语言的继承通过匿名组合完成，基类以Struct的方式定义，子类只需要把基类作为成员放在子类的定义中，支持多继承;而Java的继承通过extends关键字完成，不支持多继承。

### 2、Go 是面向对象的语言吗？

是的，也不是。原因是：

1. Go 有类型和方法，并且允许面向对象的编程风格，但没有类型层次。
2. Go 中的 "接口 "概念提供了一种不同的方法，我们认为这种方法易于使用，而且在某些方面更加通用。还有一些方法可以将类型嵌入到其他类型中，以提供类似的东西，但不等同于子类。
3. Go 中的方法比 C++ 或 Java 中的方法更通用：它们可以为任何类型的数据定义，甚至是内置类型，如普通的、"未装箱的 "整数。它们并不局限于结构（类）。
4. Go 由于缺乏类型层次，Go 中的 "对象 "比 C++ 或 Java 等语言更轻巧。

### 3、Go 实现面向对象编程

#### 封装

面向对象中的 “封装” 指的是可以隐藏对象的内部属性和实现细节，仅对外提供公开接口调用，这样子用户就不需要关注你内部是怎么实现的。

**在 Go 语言中的属性访问权限，通过首字母大小写来控制：**

- 首字母大写，代表是公共的、可被外部访问的。
- 首字母小写，代表是私有的，不可以被外部访问。

Go 语言的例子如下：

```go
type Animal struct {
	name string
}

func NewAnimal() *Animal {
 	return &Animal{}
}

func (p *Animal) SetName(name string) {
 	p.name = name
}

func (p *Animal) GetName() string {
 	return p.name
}
```



在上述例子中，我们声明了一个结构体 Animal，其属性 name 为小写。没法通过外部方法，在配套上存在 Setter 和 Getter 的方法，用于统一的访问和设置控制。

以此实现在 Go 语言中的基本封装。

#### 继承

面向对象中的 “继承” 指的是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1661876060993-91ac09c4-3a79-4b38-a09e-6450552a3bfe.png)

从实际的例子来看，就是动物是一个大父类，下面又能细分为 “食草动物”、“食肉动物”，这两者会包含 “动物” 这个父类的基本定义。

从实际的例子来看，就是动物是一个大父类，下面又能细分为 “食草动物”、“食肉动物”，这两者会包含 “动物” 这个父类的基本定义。

**在 Go 语言中，是没有类似** **extends** **关键字的这种继承的方式，在语言设计上采取的是组合的方式**：

```go
type Animal struct {
 	Name string
}

type Cat struct {
 	Animal
 	FeatureA string
}

type Dog struct {
 	Animal
 	FeatureB string
}
```

在上述例子中，我们声明了 Cat 和 Dog 结构体，其在内部匿名组合了 Animal 结构体。因此 Cat 和 Dog 的实例都可以调用 Animal 结构体的方法：

```go
func main() {
 	p := NewAnimal()
 	p.SetName("我是搬运工，去给煎鱼点赞~")

 	dog := Dog{Animal: *p}
 	fmt.Println(dog.GetName())
}
```

同时 Cat 和 Dog 的实例可以拥有自己的方法：

```go
func (dog *Dog) HelloWorld() {
 	fmt.Println("脑子进煎鱼了")
}

func (cat *Cat) HelloWorld() {
 	fmt.Println("煎鱼进脑子了")
}
```

上述例子能够正常包含调用 Animal 的相关属性和方法，也能够拥有自己的独立属性和方法，在 Go 语言中达到了类似继承的效果。

#### 多态

多态

面向对象中的 “多态” 指的同一个行为具有多种不同表现形式或形态的能力，具体是指一个类实例（对象）的相同方法在不同情形有不同表现形式。

多态也使得不同内部结构的对象可以共享相同的外部接口，也就是都是一套外部模板，内部实际是什么，只要符合规格就可以。

**在 Go 语言中，多态是通过接口来实现的：**

```go
type AnimalSounder interface {
 	MakeDNA()
}

func MakeSomeDNA(animalSounder AnimalSounder) {		// 参数是AnimalSounder接口类型
 	animalSounder.MakeDNA()
}
```

在上述例子中，我们声明了一个接口类型 AnimalSounder，配套一个 MakeSomeDNA 方法，其接受 AnimalSounder 接口类型作为入参。

因此在 Go 语言中。只要配套的 Cat 和 Dog 的实例也实现了 MakeSomeDNA 方法，那么我们就可以认为他是 AnimalSounder 接口类型：

```go
type AnimalSounder interface {
 	MakeDNA()
}

func MakeSomeDNA(animalSounder AnimalSounder) {
 	animalSounder.MakeDNA()
}

func (c *Cat) MakeDNA() {
 	fmt.Println("煎鱼是煎鱼")
}

func (c *Dog) MakeDNA() {
 	fmt.Println("煎鱼其实不是煎鱼")
}

func main() {
 	MakeSomeDNA(&Cat{})
 	MakeSomeDNA(&Dog{})
}
```

当 Cat 和 Dog 的实例实现了 AnimalSounder 接口类型的约束后，就意味着满足了条件，他们在 Go 语言中就是一个东西。能够作为入参传入 MakeSomeDNA 方法中，再根据不同的实例实现多态行为。

------

在日常工作中，基本了解这些概念就可以了。若是面试，可以针对三大特性：“封装、继承、多态” 和 五大原则 “单一职责原则（SRP）、开放封闭原则（OCP）、里氏替换原则（LSP）、依赖倒置原则（DIP）、接口隔离原则（ISP）” 进行深入理解和说明。

## **一、基础部分**

### 0、为什么选择golang

**0、高性能-协程**
golang 源码级别支持协程，实现简单；对比进程和线程，协程占用资源少，能够简洁高效地处理高并发问题。

**1、学习曲线容易-****代码极简**

Go语言语法简单，包含了类C语法。因为Go语言容易学习，所以一个普通的大学生花几个星期就能写出来可以上手的、高性能的应用。在国内大家都追求快，这也是为什么国内Go流行的原因之一。

Go 语言的语法特性简直是太简单了，简单到你几乎玩不出什么花招，直来直去的，学习曲线很低，上手非常快。

**2、效率：快速的编译时间，开发效率和运行效率高**

开发过程中相较于 Java 和 C++呆滞的编译速度，Go 的快速编译时间是一个主要的效率优势。Go拥有接近C的运行效率和接近PHP的开发效率。

C 语言的理念是信任程序员，保持语言的小巧，不屏蔽底层且底层友好，关注语言的执行效率和性能。而 Python 的姿态是用尽量少的代码完成尽量多的事。于是我能够感觉到，Go 语言想要把 C 和 Python 统一起来，这是多棒的一件事啊。

**3、出身名门、血统纯正**

之所以说Go出身名门，从Go语言的创造者就可见端倪，Go语言绝对血统纯正。其次Go语言出自Google公司，Google在业界的知名度和实力自然不用多说。Google公司聚集了一批牛人，在各种编程语言称雄争霸的局面下推出新的编程语言，自然有它的战略考虑。而且从Go语言的发展态势来看，Google对它这个新的宠儿还是很看重的，Go自然有一个良好的发展前途。

**4、自由高效：组合的思想、无侵入式的接口**

Go语言可以说是开发效率和运行效率二者的完美融合，天生的并发编程支持。Go语言支持当前所有的编程范式，包括过程式编程、面向对象编程、面向接口编程、函数式编程。程序员们可以各取所需、自由组合、想怎么玩就怎么玩。

**5、强大的标准库-****生态**

背靠谷歌，生态丰富，轻松 go get 获取各种高质量轮子。用户可以专注于业务逻辑，避免重复造轮子。

这包括互联网应用、系统编程和网络编程。Go里面的标准库基本上已经是非常稳定了，特别是我这里提到的三个，网络层、系统层的库非常实用。Go 语言的 lib 库麻雀虽小五脏俱全。Go 语言的 lib 库中基本上有绝大多数常用的库，虽然有些库还不是很好，但我觉得不是问题，因为我相信在未来的发展中会把这些问题解决掉。

**6、部署方便：二进制文件，Copy部署**

部署简单，源码编译成执行文件后，可以直接运行，减少了对其它插件依赖。不像其它语言，执行文件依赖各种插件，各种库，研发机器运行正常，部署到生产环境，死活跑不起来 。

**7、简单的并发**

并行和异步编程几乎无痛点。Go 语言的 Goroutine 和 Channel 这两个神器简直就是并发和异步编程的巨大福音。像 C、C++、Java、Python 和 JavaScript 这些语言的并发和异步方式太控制就比较复杂了，而且容易出错，而 Go 解决这个问题非常地优雅和流畅。这对于编程多年受尽并发和异步折磨的编程者来说，完全就是让人眼前一亮的感觉。Go 是一种非常高效的语言，高度支持并发性。Go是为大数据、微服务、并发而生的一种编程语言。

Go 作为一门语言致力于使事情简单化。它并未引入很多新概念，而是聚焦于打造一门简单的语言，它使用起来异常快速并且简单。其唯一的创新之处是 goroutines 和通道。Goroutines 是 Go 面向线程的轻量级方法，而通道是 goroutines 之间通信的优先方式。

创建 Goroutines 的成本很低，只需几千个字节的额外内存，正由于此，才使得同时运行数百个甚至数千个 goroutines 成为可能。可以借助通道实现 goroutines 之间的通信。Goroutines 以及基于通道的并发性方法使其非常容易使用所有可用的 CPU 内核，并处理并发的 IO。相较于 Python/Java，在一个 goroutine 上运行一个函数需要最小的代码。

**8、稳定性**

Go拥有强大的编译检查、严格的编码规范和完整的软件生命周期工具，具有很强的稳定性，稳定压倒一切。那么为什么Go相比于其他程序会更稳定呢？这是因为Go提供了软件生命周期（开发、测试、部署、维护等等）的各个环节的工具，如go tool、gofmt、go test。

**9、跨平台**
很多语言都支持跨平台，把这个优点单独拿出来，貌似没有什么值得称道的，但是结合上述优点，它的综合能力就非常强了。

### golang 缺点

**①右大括号不允许换行，否则编译报错**

**②不允许有未使用的包或变量**

**③错误处理原始，虽然引入了defer、panic、recover处理出错后的逻辑，函数可以返回多个值，但基本依靠返回错误是否为空来判断函数是否执行成功，if err != nil语句较多，比较繁琐，程序没有java美观。**(官方解释：提供了多个返回值，处理错误方便，如加入异常机制会要求记住一些常见异常，例如IOException，go的错误Error类型较统一方便)
**④[]interface{}不支持下标操作**

**⑤struct没有构造和析构，一些资源申请和释放动作不太方便**

**⑥仍然保留C/C++的指针操作，取地址&，取值\***


### **6、能介绍下 rune 类型吗？**

相当int32

golang中的字符串底层实现是通过byte数组的，中文字符在unicode下占2个字节，在utf-8编码下占3个字节，而golang默认编码正好是utf-8

byte 等同于int8，常用来处理ascii字符

rune 等同于int32,常用来处理unicode或utf-8字符

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1659259378747-48538a44-1ccb-47ac-9492-0b569d219e2b.png)

### **7、 golang 中解析 tag 是怎么实现的？反射原理是什么？(中高级肯定会问，比较难，需要自己多去总结)**

**参考如下连接**

[golang中struct关于反射tag_paladinosment的博客-CSDN博客_golang 反射tagblog.csdn.net/paladinosment/article/details/42570937](https://link.zhihu.com/?target=https%3A//blog.csdn.net/paladinosment/article/details/42570937)

type User struct { 	name string `json:name-field` 	age  int } func main() { 	user := &User{"John Doe The Fourth", 20} 	field, ok := reflect.TypeOf(user).Elem().FieldByName("name") 	if !ok { 		panic("Field not found") 	} 	fmt.Println(getStructTag(field)) } func getStructTag(f reflect.StructField) string { 	return string(f.Tag) }

Go 中解析的 tag 是通过反射实现的，反射是指计算机程序在运行时（Run time）可以访问、检测和修改它本身状态或行为的一种能力或动态知道给定数据对象的类型和结构，并有机会修改它。反射将接口变量转换成反射对象 Type 和 Value；反射可以通过反射对象 Value 还原成原先的接口变量；反射可以用来修改一个变量的值，前提是这个值可以被修改；tag是啥:结构体支持标记，name string `json:name-field` 就是 `json:name-field` 这部分

**gorm json yaml gRPC protobuf gin.Bind()都是通过反射来实现的**

### **8、调用函数传入结构体时，应该传值还是指针？ （Golang 都是传值）**

Go 的函数参数传递都是值传递。所谓值传递：指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。参数传递还有引用传递，所谓引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数

因为 Go 里面的 map，slice，chan 是引用类型。变量区分值类型和引用类型。所谓值类型：变量和变量的值存在同一个位置。所谓引用类型：变量和变量的值是不同的位置，变量的值存储的是对值的引用。但并不是 map，slice，chan 的所有的变量在函数内都能被修改，不同数据类型的底层存储结构和实现可能不太一样，情况也就不一样。

### 9、goroutine什么情况下会阻塞

在 Go 里面阻塞主要分为以下 4 种场景：

1. 由于原子、互斥量或通道操作调用导致 Goroutine 阻塞，调度器将把当前阻塞的 Goroutine 切换出去，重新调度 LRQ 上的其他 Goroutine；
2. 由于网络请求和 IO 操作导致 Goroutine 阻塞。Go 程序提供了网络轮询器（NetPoller）来处理网络请求和 IO 操作的问题，其后台通过 kqueue（MacOS），epoll（Linux）或 iocp（Windows）来实现 IO 多路复用。通过**使用 NetPoller 进行网络系统调用**，调度器可以防止 Goroutine 在进行这些系统调用时阻塞 M。这可以让 M 执行 P 的 LRQ 中其他的 Goroutines，而不需要创建新的 M。执行网络系统调用不需要额外的 M，**网络轮询器使用系统线程**，它时刻处理一个有效的事件循环，有助于减少操作系统上的调度负载。用户层眼中看到的 Goroutine 中的“block socket”，实现了 goroutine-per-connection 简单的网络编程模式。实际上是通过 Go runtime 中的 netpoller 通过 Non-block socket + I/O 多路复用机制“模拟”出来的。
3. 当调用一些系统方法的时候（如文件 I/O），如果系统方法调用的时候发生阻塞，这种情况下，网络轮询器（NetPoller）无法使用，而进行系统调用的 G1 将阻塞当前 M1。调度器引入 其它M 来服务 M1 的P。
4. 如果在 Goroutine 去执行一个 sleep 操作，导致 M 被阻塞了。Go 程序后台有一个监控线程 sysmon，它监控那些长时间运行的 G 任务然后设置可以强占的标识符，别的 Goroutine 就可以抢先进来执行。



### **11、讲讲 Go 的 defer 底层数据结构和一些特性？**

答：每个 defer 语句都对应一个_defer 实例，多个实例使用指针连接起来形成一个单连表，保存在 gotoutine 数据结构中，每次插入_defer 实例，均插入到链表的头部，函数结束再一次从头部取出，从而形成后进先出的效果。

**defer 的规则总结**：

延迟函数的参数是 defer 语句出现的时候就已经确定了的。

延迟函数执行按照后进先出的顺序执行，即先出现的 defer 最后执行。

延迟函数可能操作主函数的返回值。

申请资源后立即使用 defer 关闭资源是个好习惯。


### 13、go出现panic的场景

### https://www.cnblogs.com/paulwhw/p/15585467.html

- - 数组/切片越界
  - 空指针调用。比如访问一个 nil 结构体指针的成员
  - 过早关闭 HTTP 响应体
  - 除以 0
  - 向已经关闭的 channel 发送消息
  - 重复关闭 channel
  - 关闭未初始化的 channel
  - 未初始化 map。注意访问 map 不存在的 key 不会 panic，而是返回 map 类型对应的零值，但是不能直接赋值
  - 跨协程的 panic 处理
  - sync 计数为负数。
  - 类型断言不匹配。`var a interface{} = 1; fmt.Println(a.(string))` 会 panic，建议用 `s,ok := a.(string)`


### 16、go如何实现类似于java当中的继承机制？

https://zhuanlan.zhihu.com/p/88480107

说到继承我们都知道，在Go中没有extends关键字，也就意味着Go并没有原生级别的继承支持。这也是为什么我在文章开头用了**伪继承**这个词。本质上，Go使用interface实现的功能叫组合，Go是使用组合来实现的继承，说的更精确一点，是使用组合来代替的继承，举个很简单的例子:

**通过组合实现了继承：**

```go
type Animal struct {
    Name string
}

func (a *Animal) Eat() {
    fmt.Printf("%v is eating", a.Name)
    fmt.Println()
}

type Cat struct {
    *Animal
}

cat := &Cat{
    Animal: &Animal{
        Name: "cat",
    },
}
cat.Eat() // cat is eating
```

首先，我们实现了一个Animal的结构体，代表动物类。并声明了Name字段，用于描述动物的名字。

然后，实现了一个以Animal为receiver的Eat方法，来描述动物进食的行为。

最后，声明了一个Cat结构体，组合了Cat字段。再实例化一个猫，调用Eat方法，可以看到会正常的输出。

可以看到，Cat结构体本身没有Name字段，也没有去实现Eat方法。唯一有的就是组合了Animal父类，至此，我们就证明了已经通过组合实现了继承。

**总结：**

- 如果一个 struct 嵌套了另一个匿名结构体，那么这个结构可以直接访问匿名结构体的属性和方法，从而实现继承。
- 如果一个 struct 嵌套了另一个有名的结构体，那么这个模式叫做组合。
- 如果一个 struct 嵌套了多个匿名结构体，那么这个结构可以直接访问多个匿名结构体的属性和方法，从而实现多重继承。

### 17、怎么去复用一个接口的方法？

https://www.yisu.com/zixun/452409.html

### 18、go里面的 _ 

1. **忽略返回值**

1. 1. 比如某个函数返回三个参数，但是我们只需要其中的两个，另外一个参数可以忽略，这样的话代码可以这样写：

```go
v1, v2, _ := function(...)
v1, _, _ := function(...)
```

1. **用在变量(特别是接口断言)**

```go
type T struct{}
var _ X = T{}
//其中 I为interface
```

上面用来判断 type T是否实现了X,用作类型断言，如果T没有实现接口X，则编译错误.

1. **用在import package**

```go
import _ "test/food"
```

引入包时，会先调用包中的初始化函数，这种使用方式仅让导入的包做初始化，而不使用包中其他功能

### 19、goroutine创建的时候如果要传一个参数进去有什么要注意的点？

https://www.cnblogs.com/waken-captain/p/10496454.html

### 20、写go单元测试的规范？

1.  **单元测试文件命名规则 ：**

单元测试需要创建单独的测试文件，不能在原有文件中书写，名字规则为 xxx_test.go。这个规则很好理解。

1.  **单元测试包命令规则** 

单元测试文件的包名为原文件的包名添加下划线接test，举例如下：

```go
// 原文件包名：

package xxx

// 单元测试文件包名：

package xxx_test
```

1.  **单元测试方法命名规则** 

单元测试文件中的测试方法和原文件中的待测试的方法名相对应，以Test开头，举例如下：

```go
// 原文件方法：
func Xxx(name string) error 
 
// 单元测试文件方法：
func TestXxx()
```

1.  **单元测试方法参数** 

单元测试方法的参数必须是t *testing.T，举例如下：

```go
func TestZipFiles(t *testing.T) { ...
```

### 21、单步调试？

https://www.jianshu.com/p/21ed30859d80

### 22、导入一个go的工程，有些依赖找不到，改怎么办？

https://www.cnblogs.com/niuben/p/16182001.html

### 23、[值拷贝 与 引用拷贝，深拷贝 与 浅拷贝](https://www.cnblogs.com/yizhixiaowenzi/p/14664222.html)

map，slice，chan 是引用拷贝；引用拷贝 是 浅拷贝

其余的，都是 值拷贝；值拷贝 是 深拷贝

#### 深浅拷贝的本质区别：

是否真正获取对象实体，而不是引用

**深拷贝：**

拷贝的是数据本身，创造一个新的对象，并在内存中开辟一个新的内存地址，与原对象是完全独立的，不共享内存，修改新对象时不会影响原对象的值。释放内存时，也没有任何关联。

**值拷贝：**

接收的是  整个array的值拷贝，所以方法对array中元素的重新赋值不起作用。

```go
package main  

import "fmt"  

func modify(a [3]int) {  
    a[0] = 4  
    fmt.Println("modify",a)             // modify [4 2 3]
}  

func main() {  
    a := [3]int{1, 2, 3}  
    modify(a)  
    fmt.Println("main",a)                  // main [1 2 3]
}  
```

**浅拷贝：**

拷贝的是数据地址，只复制指向的对象的指针，新旧对象的内存地址是一样的，修改一个另一个也会变。释放内存时，同时释放。

**引用拷贝：**

函数的引用拷贝与原始的引用指向同一个数组，所以对数组中元素的修改，是有效的

```go
package main  
  
import "fmt"  
  
func modify(s []int) {  
    s[0] = 4  
    fmt.Println("modify",s)          // modify [4 2 3]
}  
  
func main() {  
    s := []int{1, 2, 3}  
    modify(s)  
    fmt.Println("main",s)              // main [4 2 3]
}
```

### 24、[精通Golang项目依赖Go modules](https://www.topgoer.cn/docs/golangxiuyang/golangxiuyang-1cmee13oek1e8)

### 25、Go 多返回值怎么实现的？

答：Go 传参和返回值是通过 FP+offset 实现，并且存储在调用函数的栈帧中。FP 栈底寄存器，指向一个函数栈的顶部;PC 程序计数器，指向下一条执行指令;SB 指向静态数据的基指针，全局符号;SP 栈顶寄存器。

### 26、Go 语言中不同的类型如何比较是否相等？

答：像 string，int，float interface 等可以通过 reflect.DeepEqual 和等于号进行比较，像 slice，struct，map 则一般使用 reflect.DeepEqual 来检测是否相等。

### 27、Go中init 函数的特征?

答：一个包下可以有多个 init 函数，每个文件也可以有多个 init 函数。多个 init 函数按照它们的文件名顺序逐个初始化。应用初始化时初始化工作的顺序是，从被导入的最深层包开始进行初始化，层层递出最后到 main 包。不管包被导入多少次，包内的 init 函数只会执行一次。应用初始化时初始化工作的顺序是，从被导入的最深层包开始进行初始化，层层递出最后到 main 包。但包级别变量的初始化先于包内 init 函数的执行。

### 28、Go中 uintptr和 unsafe.Pointer 的区别？

答：unsafe.Pointer 是通用指针类型，它不能参与计算，任何类型的指针都可以转化成 unsafe.Pointer，unsafe.Pointer 可以转化成任何类型的指针，uintptr 可以转换为 unsafe.Pointer，unsafe.Pointer 可以转换为 uintptr。uintptr 是指针运算的工具，但是它不能持有指针对象（意思就是它跟指针对象不能互相转换），unsafe.Pointer 是指针对象进行运算（也就是 uintptr）的桥梁。

## 二、slice

### **2、**[**讲讲 Go 的 slice 底层数据结构和一些特性？**](https://www.topgoer.cn/docs/gozhuanjia/gozhuanjiaslice)

答：Go 的 slice 底层数据结构是由一个 array 指针指向底层数组，len 表示切片长度，cap 表示切片容量。slice 的主要实现是扩容。对于 append 向 slice 添加元素时，假如 slice 容量够用，则追加新元素进去，slice.len++，返回原来的 slice。当原容量不够，则 slice 先扩容，扩容之后 slice 得到新的 slice，将元素追加进新的 slice，slice.len++，返回新的 slice。对于切片的扩容规则：当切片比较小时（容量小于 1024），则采用较大的扩容倍速进行扩容（新的扩容会是原来的 2 倍），避免频繁扩容，从而减少内存分配的次数和数据拷贝的代价。当切片较大的时（原来的 slice 的容量大于或者等于 1024），采用较小的扩容倍速（新的扩容将扩大大于或者等于原来 1.25 倍），主要避免空间浪费，网上其实很多总结的是 1.25 倍，那是在不考虑内存对齐的情况下，实际上还要考虑内存对齐，扩容是大于或者等于 1.25 倍。

（关于刚才问的 slice 为什么传到函数内可能被修改，如果 slice 在函数内没有出现扩容，函数外和函数内 slice 变量指向是同一个数组，则函数内复制的 slice 变量值出现更改，函数外这个 slice 变量值也会被修改。如果 slice 在函数内出现扩容，则函数内变量的值会新生成一个数组（也就是新的 slice，而函数外的 slice 指向的还是原来的 slice，则函数内的修改不会影响函数外的 slice。）

### 3、golang中数组和slice作为参数的区别？slice作为参数传递有什么问题？

https://blog.csdn.net/weixin_44387482/article/details/119763558

1. 当使用数组作为参数和返回值的时候，传进去的是值，在函数内部对数组进行修改并不会影响原数据
2. 当切片作为参数的时候穿进去的是值，也就是值传递，但是当我在函数里面修改切片的时候，我们发现源数据也会被修改，这是因为我们在切片的底层维护这一个匿名的数组，当我们把切片当成参数的时候，会重现创建一个切片，但是创建的这个切片和我们原来的数据是共享数据源的，所以在函数内被修改，源数据也会被修改
3. 数组还是切片，在函数中传递的时候如果没有指定为指针传递的话，都是值传递，但是切片在传递的过程中，有着共享底层数组的风险，所以如果在函数内部进行了更改的时候，会修改到源数据，所以我们需要根据不同的需求来处理，如果我们不希望源数据被修改话的我们可以使用copy函数复制切片后再传入，如果希望源数据被修改的话我们应该使用指针传递的方式

### 4、从数组中取一个相同大小的slice有成本吗？

或者这么问：从切片中取一个相同大小的数组有成本吗？

从数组中截取切片：https://blog.csdn.net/weixin_42117918/article/details/81913036



## **三、map相关**

### 3、 map 中删除一个 key，它的内存会释放么？（常问）

如果删除的元素是值类型，如int，float，bool，string以及数组和struct，map的内存不会自动释放

如果删除的元素是引用类型，如指针，slice，map，chan等，map的内存会自动释放，但释放的内存是子元素应用类型的内存占用

将map设置为nil后，内存被回收。

**这个问题还需要大家去搜索下答案，我记得有不一样的说法，谨慎采用本题答案。**


### 6、map 的数据结构是什么？

https://www.topgoer.cn/docs/gozhuanjia/gozhuanjiamap

答：golang 中 map 是一个 kv 对集合。底层使用 hash table，用链表来解决冲突 ，出现冲突时，不是每一个 key 都申请一个结构通过链表串起来，而是以 bmap 为最小粒度挂载，一个 bmap 可以放 8 个 kv。在哈希函数的选择上，会在程序启动时，检测 cpu 是否支持 aes，如果支持，则使用 aes hash，否则使用 memhash。每个 map 的底层结构是 hmap，是有若干个结构为 bmap 的 bucket 组成的数组。每个 bucket 底层都采用链表结构。


**下图展示一个拥有4个bucket的map：**

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1661789793109-401b7c75-c26b-4893-bbf7-1f2dfa69316b.png)

本例中, hmap.B=2， 而hmap.buckets长度是2^B为4. 元素经过哈希运算后会落到某个bucket中进行存储。查找过程类似。

bucket很多时候被翻译为桶，所谓的哈希桶实际上就是bucket。


这里只有一个 tophash 字段，而实际上在使用中值的类型是不固定的，甚至可以是一个自定义结构体的指针类型。这个结构体看起来可能有点让人费解，其实编译器在编译期间会动态创建一个新的同名数据结构，如下所示

```go
type bmap struct {
    topbits  [8]uint8
    keys     [8]keytype
    values   [8]valuetype
    pad      uintptr
    overflow uintptr
}
```

bmap 即 bucket map 的缩写。

每个bucket可以存储8个键值对。

- topbits 是个长度为8的数组，哈希值相同的键（准确的说是哈希值低位相同的键）存入当前bucket时会将哈希值的高位存储在该数组中，以方便后续匹配。
- keys 长度为8的数组，[]keytype，元素为：具体的key值。
- values 长度为8的数组，[]valuetype，元素为：键值对的key对应的值。
- pad 对齐内存使用的，不是每个bmap都有会这个字段，需要满足一定条件
- overflow 指针指向的是下一个bucket，据此将所有冲突的键连接起来。

下图展示bucket存放8个key-value对：

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1661789834784-c60b0cb4-96be-4c4c-8978-2bfc9ca716b9.png)

#### [解决哈希冲突（四种方法）](https://blog.csdn.net/qq_48241564/article/details/118613312)

#### 哈希冲突

当有两个或以上数量的键被哈希到了同一个bucket时，我们称这些键发生了冲突。Go使用链地址法来解决键冲突。
由于每个bucket可以存放8个键值对，所以同一个bucket存放超过8个键值对时就会再创建一个键值对，用类似链表的方式将bucket连接起来。

下图展示产生冲突后的map：

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1661789900886-a77838be-46c8-4254-999b-b6e217721fbf.png)

bucket数据结构指示下一个bucket的指针称为overflow bucket，意为当前bucket盛不下而溢出的部分。事实上哈希冲突并不是好事情，它降低了存取效率，好的哈希算法可以保证哈希值的随机性，但冲突过多也是要控制的，后面会再详细介绍。

#### 负载因子

负载因子用于衡量一个哈希表冲突情况，公式为：

负载因子 = 键数量/bucket数量

例如，对于一个bucket数量为4，包含4个键值对的哈希表来说，这个哈希表的负载因子为1.

哈希表需要将负载因子控制在合适的大小，超过其阀值需要进行rehash，也即键值对重新组织：

- 哈希因子过小，说明空间利用率低
- 哈希因子过大，说明冲突严重，存取效率低

每个哈希表的实现对负载因子容忍程度不同，比如Redis实现中负载因子大于1时就会触发rehash，而Go则在在负载因子达到6.5时才会触发rehash，因为Redis的每个bucket只能存1个键值对，而Go的bucket可能存8个键值对，所以Go可以容忍更高的负载因子。

### 7、是怎么实现扩容？

#### map 的容量大小

底层调用 makemap 函数，计算得到合适的 B，map 容量最多可容纳 6.52^B 个元素，6.5 为装载因子阈值常量。装载因子的计算公式是：装载因子=填入表中的元素个数/散列表的长度，装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。底层调用 makemap 函数，计算得到合适的 B，map 容量最多可容纳 6.52^B 个元素，6.5 为装载因子阈值常量。装载因子的计算公式是：装载因子=填入表中的元素个数/散列表的长度，装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。

#### 触发 map 扩容的条件

为了保证访问效率，当新元素将要添加进map时，都会检查是否需要扩容，扩容实际上是以空间换时间的手段。
触发扩容的条件有二个：

1. 负载因子 > 6.5时，也即平均每个bucket存储的键值对达到6.5个。
2. overflow数量 > 2^15时，也即overflow数量超过32768时。

#### 增量扩容

当负载因子过大时，就新建一个bucket，新的bucket长度是原来的2倍，然后旧bucket数据搬迁到新的bucket。
考虑到如果map存储了数以亿计的key-value，一次性搬迁将会造成比较大的延时，Go采用逐步搬迁策略，即每次访问map时都会触发一次搬迁，每次搬迁2个键值对。

下图展示了包含一个bucket满载的map(为了描述方便，图中bucket省略了value区域):

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1661789723150-6a635c5e-5d5a-4173-972f-ac0fd0326ffe.png)

当前map存储了7个键值对，只有1个bucket。此地负载因子为7。再次插入数据时将会触发扩容操作，扩容之后再将新插入键写入新的bucket。

当第8个键值对插入时，将会触发扩容，扩容后示意图如下：

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1661789723181-66b62c5f-34bb-4427-8c68-446e7e05b4de.png)

hmap数据结构中oldbuckets成员指身原bucket，而buckets指向了新申请的bucket。新的键值对被插入新的bucket中。
后续对map的访问操作会触发迁移，将oldbuckets中的键值对逐步的搬迁过来。当oldbuckets中的键值对全部搬迁完毕后，删除oldbuckets。

搬迁完成后的示意图如下：

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1661789723183-d1c03c9d-b6a9-4dd7-8410-a2674f1f1c0c.png)

数据搬迁过程中原bucket中的键值对将存在于新bucket的前面，新插入的键值对将存在于新bucket的后面。
实际搬迁过程中比较复杂，将在后续源码分析中详细介绍。

#### 等量扩容

所谓等量扩容，实际上并不是扩大容量，buckets数量不变，重新做一遍类似增量扩容的搬迁动作，把松散的键值对重新排列一次，以使bucket的使用率更高，进而保证更快的存取。
在极端场景下，比如不断地增删，而键值对正好集中在一小部分的bucket，这样会造成overflow的bucket数量增多，但负载因子又不高，从而无法执行增量搬迁的情况，如下图所示：

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1661789747828-6f31463b-a48d-4a4d-877b-828f7f6abc9d.png)

上图可见，overflow的bucket中大部分是空的，访问效率会很差。此时进行一次等量扩容，即buckets数量不变，经过重新组织后overflow的bucket数量会减少，即节省了空间又会提高访问效率。

### 8、查找过程

查找过程如下：

1. 根据key值算出哈希值
2. 取哈希值低位与hmap.B取模确定bucket位置
3. 取哈希值高位在tophash数组中查询
4. 如果tophash[i]中存储值也哈希值相等，则去找到该bucket中的key值进行比较
5. 当前bucket没有找到，则继续从下个overflow的bucket中查找。
6. 如果当前处于搬迁过程，则优先从oldbuckets查找

注：如果查找不到，也不会返回空值，而是返回相应类型的0值。

### 9、插入过程

新元素插入过程如下：

1. 根据key值算出哈希值
2. 取哈希值低位与hmap.B取模确定bucket位置
3. 查找该key是否已经存在，如果存在则直接更新值
4. 如果没找到将key，将key插入


## 四、接口

### 1、[Go 语言与鸭子类型的关系](http://golang.design/go-questions/interface/duck-typing/)

总结一下，鸭子类型是一种动态语言的风格，在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由它"当前方法和属性的集合"决定。Go 作为一种静态语言，通过接口实现了 鸭子类型，实际上是 Go 的编译器在其中作了隐匿的转换工作。

### 2、[值接收者和指针接收者的区别](http://golang.design/go-questions/interface/receiver/)

#### 方法

方法能给用户自定义的类型添加新的行为。它和函数的区别在于方法有一个接收者，给一个函数添加一个接收者，那么它就变成了方法。接收者可以是值接收者，也可以是指针接收者。

在调用方法的时候，值类型既可以调用值接收者的方法，也可以调用指针接收者的方法；指针类型既可以调用指针接收者的方法，也可以调用值接收者的方法。

也就是说，不管方法的接收者是什么类型，该类型的值和指针都可以调用，不必严格符合接收者的类型。

实际上，当类型和方法的接收者类型不同时，其实是编译器在背后做了一些工作，用一个表格来呈现：

| **-**          | **值接收者**                                                 | **指针接收者**                                               |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 值类型调用者   | 方法会使用调用者的一个副本，类似于“传值”                     | 使用值的引用来调用方法，上例中，qcrao.growUp() 实际上是 (&qcrao).growUp() |
| 指针类型调用者 | 指针被解引用为值，上例中，stefno.howOld() 实际上是 (*stefno).howOld() | 实际上也是“传值”，方法里的操作会影响到调用者，类似于指针传参，拷贝了一份指针 |

#### 值接收者和指针接收者

前面说过，不管接收者类型是值类型还是指针类型，都可以通过值类型或指针类型调用，这里面实际上通过语法糖起作用的。

先说结论：实现了接收者是值类型的方法，相当于自动实现了接收者是指针类型的方法；而实现了接收者是指针类型的方法，不会自动生成对应接收者是值类型的方法。

所以，当实现了一个接收者是值类型的方法，就可以自动生成一个接收者是对应指针类型的方法，因为两者都不会影响接收者。但是，当实现了一个接收者是指针类型的方法，如果此时自动生成一个接收者是值类型的方法，原本期望对接收者的改变（通过指针实现），现在无法实现，因为值类型会产生一个拷贝，不会真正影响调用者。

最后，只要记住下面这点就可以了：

如果实现了接收者是值类型的方法，会隐含地也实现了接收者是指针类型的方法。

#### 两者分别在何时使用

如果方法的接收者是值类型，无论调用者是对象还是对象指针，修改的都是对象的副本，不影响调用者；如果方法的接收者是指针类型，则调用者修改的是指针指向的对象本身。

使用指针作为方法的接收者的理由：

- 方法能够修改接收者指向的值。
- 避免在每次调用方法时复制该值，在值的类型为大型结构体时，这样做会更加高效。

是使用值接收者还是指针接收者，不是由该方法是否修改了调用者（也就是接收者）来决定，而是应该基于该类型的本质。

如果类型具备“原始的本质”，也就是说它的成员都是由 Go 语言里内置的原始类型，如字符串，整型值等，那就定义值接收者类型的方法。像内置的引用类型，如 slice，map，interface，channel，这些类型比较特殊，声明他们的时候，实际上是创建了一个 header， 对于他们也是直接定义值接收者类型的方法。这样，调用函数时，是直接 copy 了这些类型的 header，而 header 本身就是为复制设计的。

如果类型具备非原始的本质，不能被安全地复制，这种类型总是应该被共享，那就定义指针接收者的方法。比如 go 源码里的文件结构体（struct File）就不应该被复制，应该只有一份实体。

### 3、[iface 和 eface 的区别是什么](http://golang.design/go-questions/interface/iface-eface/)

iface 和 eface 都是 Go 中描述接口的底层结构体，区别在于 iface 描述的接口包含方法，而 eface 则是不包含任何方法的空接口：interface{}。

从源码层面看一下：

```plain
type iface struct {
    tab  *itab
    data unsafe.Pointer
}

type itab struct {
    inter  *interfacetype
    _type  *_type
    link   *itab
    hash   uint32 // copy of _type.hash. Used for type switches.
    bad    bool   // type does not implement interface
    inhash bool   // has this itab been added to hash?
    unused [2]byte
    fun    [1]uintptr // variable sized
}
```

iface 内部维护两个指针，tab 指向一个 itab 实体， 它表示接口的类型以及赋给这个接口的实体类型。data 则指向接口具体的值，一般而言是一个指向堆内存的指针。

再来仔细看一下 itab 结构体：_type 字段描述了实体的类型，包括内存对齐方式，大小等；inter 字段则描述了接口的类型。fun 字段放置和接口方法对应的具体数据类型的方法地址，实现接口调用方法的动态分派，一般在每次给接口赋值发生转换时会更新此表，或者直接拿缓存的 itab。

这里只会列出实体类型和接口相关的方法，实体类型的其他方法并不会出现在这里。

另外，你可能会觉得奇怪，为什么 fun 数组的大小为 1，要是接口定义了多个方法可怎么办？实际上，这里存储的是第一个方法的函数指针，如果有更多的方法，在它之后的内存空间里继续存储。从汇编角度来看，通过增加地址就能获取到这些函数指针，没什么影响。顺便提一句，这些方法是按照函数名称的字典序进行排列的。

再看一下 interfacetype 类型，它描述的是接口的类型：

```plain
type interfacetype struct {
    typ     _type
    pkgpath name
    mhdr    []imethod
}
```

可以看到，它包装了 _type 类型，_type 实际上是描述 Go 语言中各种数据类型的结构体。我们注意到，这里还包含一个 mhdr 字段，表示接口所定义的函数列表， pkgpath 记录定义了接口的包名。

这里通过一张图来看下 iface 结构体的全貌：

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1671113733638-8e2e9037-11a8-49af-8dd3-dfd37d7f5d21.png)

接着来看一下 eface 的源码：

```plain
type eface struct {
    _type *_type
    data  unsafe.Pointer
}
```

相比 iface，eface 就比较简单了。只维护了一个 _type 字段，表示空接口所承载的具体的实体类型。data 描述了具体的值。

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1671113735267-6bcdb7c8-dd73-432c-b933-d218fc1b7480.png)

### 4、[接口的动态类型和动态值](http://golang.design/go-questions/interface/dynamic-typing/)

从源码里可以看到：iface包含两个字段：tab 是接口表指针，指向类型信息；data 是数据指针，则指向具体的数据。它们分别被称为动态类型和动态值。而接口值包括动态类型和动态值。

【引申1】接口类型和 nil 作比较

接口值的零值是指动态类型和动态值都为 nil。当仅且当这两部分的值都为 nil 的情况下，这个接口值就才会被认为 接口值 == nil。

### 5、[编译器自动检测类型是否实现接口](http://golang.design/go-questions/interface/detect-impl/)

### 6、[接口的构造过程是怎样的](http://golang.design/go-questions/interface/construct/)

### 7、[类型转换和断言的区别](http://golang.design/go-questions/interface/assert/)

我们知道，Go 语言中不允许隐式类型转换，也就是说 = 两边，不允许出现类型不相同的变量。

类型转换、类型断言本质都是把一个类型转换成另外一个类型。不同之处在于，类型断言是对接口变量进行的操作。

#### **类型转换**

对于类型转换而言，转换前后的两个类型要相互兼容才行。类型转换的语法为：

<结果类型> := <目标类型> ( <表达式> )

```plain
func main() {
    var i int = 9

    var f float64
    f = float64(i)
    fmt.Printf("%T, %v\n", f, f)

    f = 10.8
    a := int(f)
    fmt.Printf("%T, %v\n", a, a)
}
```

#### 断言

前面说过，因为空接口 interface{} 没有定义任何函数，因此 Go 中所有类型都实现了空接口。当一个函数的形参是 interface{}，那么在函数中，需要对形参进行断言，从而得到它的真实类型。

断言的语法为：

<目标类型的值>，<布尔参数> := <表达式>.( 目标类型 ) // 安全类型断言 

<目标类型的值> := <表达式>.( 目标类型 ) //非安全类型断言

类型转换和类型断言有些相似，不同之处，在于类型断言是对接口进行的操作。

```plain
type Student struct {
    Name string
    Age int
}

func main() {
    var i interface{} = new(Student)
    s, ok := i.(Student)
    if ok {
        fmt.Println(s)
    }
}
```

断言其实还有另一种形式，就是用在利用 switch 语句判断接口的类型。每一个 case 会被顺序地考虑。当命中一个 case 时，就会执行 case 中的语句，因此 case 语句的顺序是很重要的，因为很有可能会有多个 case 匹配的情况。

### 8、[接口转换的原理](http://golang.design/go-questions/interface/convert/)

通过前面提到的 iface 的源码可以看到，实际上它包含接口的类型 interfacetype 和 实体类型的类型 _type，这两者都是 iface 的字段 itab 的成员。也就是说生成一个 itab 同时需要接口的类型和实体的类型。

<interface 类型， 实体类型> ->itable

当判定一种类型是否满足某个接口时，Go 使用类型的方法集和接口所需要的方法集进行匹配，如果类型的方法集完全包含接口的方法集，则可认为该类型实现了该接口。

例如某类型有 m 个方法，某接口有 n 个方法，则很容易知道这种判定的时间复杂度为 O(mn)，Go 会对方法集的函数按照函数名的字典序进行排序，所以实际的时间复杂度为 O(m+n)。

这里我们来探索将一个接口转换给另外一个接口背后的原理，当然，能转换的原因必然是类型兼容。

1. 具体类型转空接口时，_type 字段直接复制源类型的 _type；调用 mallocgc 获得一块新内存，把值复制进去，data 再指向这块新内存。
2. 具体类型转非空接口时，入参 tab 是编译器在编译阶段预先生成好的，新接口 tab 字段直接指向入参 tab 指向的 itab；调用 mallocgc 获得一块新内存，把值复制进去，data 再指向这块新内存。
3. 而对于接口转接口，itab 调用 getitab 函数获取。只用生成一次，之后直接从 hash 表中获取。

### 9、[如何用 interface 实现多态](http://golang.design/go-questions/interface/polymorphism/)

Go 语言并没有设计诸如虚函数、纯虚函数、继承、多重继承等概念，但它通过接口却非常优雅地支持了面向对象的特性。

多态是一种运行期的行为，它有以下几个特点：

1. 一种类型具有多种类型的能力
2. 允许不同的对象对同一消息做出灵活的反应
3. 以一种通用的方式对待个使用的对象
4. 非动态语言必须通过继承和接口的方式来实现

main 函数里先生成 Student 和 Programmer 的对象，再将它们分别传入到函数 whatJob 和 growUp。函数中，直接调用接口函数，实际执行的时候是看最终传入的实体类型是什么，调用的是实体类型实现的函数。于是，不同对象针对同一消息就有多种表现，多态就实现了。

### 10、[Go 接口与 C++ 接口有何异同](http://golang.design/go-questions/interface/compare-to-cpp/)

接口定义了一种规范，描述了类的行为和功能，而不做具体实现。

C++ 的接口是使用抽象类来实现的，如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 “= 0” 来指定的。例如：

```plain
class Shape
{
   public:
      // 纯虚函数
      virtual double getArea() = 0;
   private:
      string name;      // 名称
};
```

设计抽象类的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。

派生类需要明确地声明它继承自基类，并且需要实现基类中所有的纯虚函数。

C++ 定义接口的方式称为“侵入式”，而 Go 采用的是 “非侵入式”，不需要显式声明，只需要实现接口定义的函数，编译器自动会识别。

C++ 和 Go 在定义接口方式上的不同，也导致了底层实现上的不同。C++ 通过虚函数表来实现基类调用派生类的函数；而 Go 通过 itab 中的 fun 字段来实现接口变量调用实体类型的函数。C++ 中的虚函数表是在编译期生成的；而 Go 的 itab 中的 fun 字段是在运行期间动态生成的。原因在于，Go 中实体类型可能会无意中实现 N 多接口，很多接口并不是本来需要的，所以不能为类型实现的所有接口都生成一个 itab， 这也是“非侵入式”带来的影响；这在 C++ 中是不存在的，因为派生需要显示声明它继承自哪个基类。





## **六、channel相关**

### **2、go channel 的底层实现原理 （数据结构）**

https://juejin.cn/post/7037656471210819614

https://www.topgoer.cn/docs/gozhuanjia/gochan4

#### 数据结构

```go
type hchan struct {
    //channel分为无缓冲和有缓冲两种。
    //对于有缓冲的channel存储数据，借助的是如下循环数组的结构
    qcount   uint           // 循环数组中的元素数量
    dataqsiz uint           // 循环数组的长度
    buf      unsafe.Pointer // 指向底层循环数组的指针
    elemsize uint16 //能够收发元素的大小
    
    
    closed   uint32   //channel是否关闭的标志
    elemtype *_type //channel中的元素类型
    
    //有缓冲channel内的缓冲数组会被作为一个“环型”来使用。
    //当下标超过数组容量后会回到第一个位置，所以需要有两个字段记录当前读和写的下标位置
    sendx    uint   // 下一次发送数据的下标位置
    recvx    uint   // 下一次读取数据的下标位置
    
    //当循环数组中没有数据时，收到了接收请求，那么接收数据的变量地址将会写入读等待队列
    //当循环数组中数据已满时，收到了发送请求，那么发送数据的变量地址将写入写等待队列
    recvq    waitq  // 读等待队列
    sendq    waitq  // 写等待队列
    
    
    lock mutex //互斥锁，保证读写channel时不存在并发竞争问题
}
```

![img](https://cdn.nlark.com/yuque/0/2022/webp/22219483/1661787750459-2608e3a8-f5f9-4d1c-a97f-314d4d83fecf.webp)

总结hchan结构体的主要组成部分有四个：

- 用来保存goroutine之间传递数据的循环链表。=====> buf。
- 用来记录此循环链表当前发送或接收数据的下标值。=====> sendx和recvx。
- 用于保存向该chan发送和从改chan接收数据的goroutine的队列。=====> sendq 和 recvq
- 保证channel写入和读取数据时线程安全的锁。 =====> lock


### **4、向 channel 发送数据和从 channel 读数据的流程是什么样的？**

#### 发送流程：

向一个channel中写数据简单过程如下：

1. 如果等待接收队列recvq不为空，说明缓冲区中没有数据或者没有缓冲区，此时直接从recvq取出G,并把数据写入，最后把该G唤醒，结束发送过程；
2. 如果缓冲区中有空余位置，将数据写入缓冲区，结束发送过程；
3. 如果缓冲区中没有空余位置，将待发送数据写入G，将当前G加入sendq，进入睡眠，等待被读goroutine唤醒；

简单流程图如下：

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1661788117541-f82a3d7e-8b22-46cd-9bd9-dde26f0d290c.png)

#### 接收流程：

从一个channel读数据简单过程如下：

1. 如果等待发送队列sendq不为空，且没有缓冲区，直接从sendq中取出G，把G中数据读出，最后把G唤醒，结束读取过程；
2. 如果等待发送队列sendq不为空，此时说明缓冲区已满，从缓冲区中首部读出数据，把G中数据写入缓冲区尾部，把G唤醒，结束读取过程；
3. 如果缓冲区中有数据，则从缓冲区取出数据，结束读取过程；
4. 将当前goroutine加入recvq，进入睡眠，等待被写goroutine唤醒；

简单流程图如下：

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1661788153163-c386fedf-84b2-42ed-9965-d5d80743650c.png)

#### 关闭channel

关闭channel时会把recvq中的G全部唤醒，本该写入G的数据位置为nil。把sendq中的G全部唤醒，但这些G会panic。

除此之外，panic出现的常见场景还有：

1. 关闭值为nil的channel
2. 关闭已经被关闭的channel
3. 向已经关闭的channel写数据

### **5、讲讲 Go 的 chan 底层数据结构和主要使用场景**

答：channel 的数据结构包含 qccount 当前队列中剩余元素个数，dataqsiz 环形队列长度，即可以存放的元素个数，buf 环形队列指针，elemsize 每个元素的大小，closed 标识关闭状态，elemtype 元素类型，sendx 队列下表，指示元素写入时存放到队列中的位置，recv 队列下表，指示元素从队列的该位置读出。recvq 等待读消息的 goroutine 队列，sendq 等待写消息的 goroutine 队列，lock 互斥锁，chan 不允许并发读写。

**无缓冲和有缓冲区别：** 管道没有缓冲区，从管道读数据会阻塞，直到有协程向管道中写入数据。同样，向管道写入数据也会阻塞，直到有协程从管道读取数据。管道有缓冲区但缓冲区没有数据，从管道读取数据也会阻塞，直到协程写入数据，如果管道满了，写数据也会阻塞，直到协程从缓冲区读取数据。

**channel 的一些特点** 1）、读写值 nil 管道会永久阻塞 2）、关闭的管道读数据仍然可以读数据 3）、往关闭的管道写数据会 panic 4）、关闭为 nil 的管道 panic 5）、关闭已经关闭的管道 panic

**向 channel 写数据的流程：** 如果等待接收队列 recvq 不为空，说明缓冲区中没有数据或者没有缓冲区，此时直接从 recvq 取出 G,并把数据写入，最后把该 G 唤醒，结束发送过程； 如果缓冲区中有空余位置，将数据写入缓冲区，结束发送过程； 如果缓冲区中没有空余位置，将待发送数据写入 G，将当前 G 加入 sendq，进入睡眠，等待被读 goroutine 唤醒；

**向 channel 读数据的流程：** 如果等待发送队列 sendq 不为空，且没有缓冲区，直接从 sendq 中取出 G，把 G 中数据读出，最后把 G 唤醒，结束读取过程； 如果等待发送队列 sendq 不为空，此时说明缓冲区已满，从缓冲区中首部读出数据，把 G 中数据写入缓冲区尾部，把 G 唤醒，结束读取过程； 如果缓冲区中有数据，则从缓冲区取出数据，结束读取过程；将当前 goroutine 加入 recvq，进入睡眠，等待被写 goroutine 唤醒；

**使用场景：** 消息传递、消息过滤，信号广播，事件订阅与广播，请求、响应转发，任务分发，结果汇总，并发控制，限流，同步与异步

## **七、GMP相关**

- https://www.topgoer.cn/docs/golangxiuyang/golangxiuyang-1cmeduvk27bo0
- https://www.mubucm.com/doc/7pukUL_nuCI-刘超

### 0、进程、线程、协程有什么区别？（必问）

进程：是应用程序的启动实例，每个进程都有独立的内存空间，不同的进程通过进程间的通信方式来通信。

线程：从属于进程，每个进程至少包含一个线程，线程是 CPU 调度的基本单位，多个线程之间可以共享进程的资源并通过共享内存等线程间的通信方式来通信。

协程：为轻量级线程，与线程相比，协程不受操作系统的调度，协程的调度器由用户应用程序提供，协程调度器按照调度策略把协程调度到线程中运行

### 1、什么是 GMP？（必问）

答：G 代表着 goroutine，P 代表着上下文处理器，M 代表 thread 线程，

在 GPM 模型，有一个全局队列（Global Queue）：存放等待运行的 G，还有一个 P 的本地队列：也是存放等待运行的 G，但数量有限，不超过 256 个。

GPM 的调度流程从 go func()开始创建一个 goroutine，新建的 goroutine 优先保存在 P 的本地队列中，如果 P 的本地队列已经满了，则会保存到全局队列中。

M 会从 P 的队列中取一个可执行状态的 G 来执行，如果 P 的本地队列为空，就会从其他的 MP 组合偷取一个可执行的 G 来执行，

当 M 执行某一个 G 时候发生系统调用或者阻塞，M 阻塞，

如果这个时候 G 在执行，runtime 会把这个线程 M 从 P 中摘除，然后创建一个新的操作系统线程来服务于这个 P，当 M 系统调用结束时，这个 G 会尝试获取一个空闲的 P 来执行，并放入到这个 P 的本地队列，如果这个线程 M 变成休眠状态，加入到空闲线程中，然后整个 G 就会被放入到全局队列中。

 **G,P,M 的个数问题**：

1. G 的个数理论上是无限制的，但是受内存限制，
2. P 的数量一般建议是逻辑 CPU 数量的 2 倍，

1. 1. 由启动时环境变量$GOMAXPROCS或者是由runtime的方法GOMAXPROCS()决定。这意味着在程序执行的任意时刻都只有$GOMAXPROCS个goroutine在同时运行。

1. M 的数量

1. 1. go语言本身的限制：go程序启动时，会设置M的最大数量，默认10000.但是内核很难支持这么多的线程数，所以这个限制可以忽略。
   2. runtime/debug中的SetMaxThreads函数，设置M的最大数量
   3. 一个M阻塞了，会创建新的M。

1. M与P的数量没有绝对关系，一个M阻塞，P就会去创建或者切换另一个M，所以，即使P的默认数量是1，也有可能会创建很多个M出来。

**work stealing（工作量窃取） 机制**：会优先从全局队列里进行窃取，之后会从其它的P队列里窃取一半的G，放入到本地P队列里。
**hand off （移交）机制**：当前线程的G进行阻塞调用时，例如睡眠，则当前线程就会释放P，然后把P转交给其它空闲的线程执行，如果没有闲置的线程，则创建新的线程

### 2、[为什么要有 P？](https://segmentfault.com/a/1190000040092613)

**带来什么改变**

加了 P 之后会带来什么改变呢？我们再更显式的讲一下。

- 每个 P 有自己的本地队列，大幅度的减轻了对全局队列的直接依赖，所带来的效果就是锁竞争的减少。而 GM 模型的性能开销大头就是锁竞争。
- 每个 P 相对的平衡上，在 GMP 模型中也实现了 Work Stealing （工作量窃取机制）算法，如果 P 的本地队列为空，则会从全局队列或其他 P 的本地队列中窃取可运行的 G 来运行，减少空转，提高了资源利用率。

**为什么要有 P**

这时候就有小伙伴会疑惑了，如果是想实现本地队列、Work Stealing 算法，那为什么不直接在 M 上加呢，M 也照样可以实现类似的组件。为什么又再加多一个 P 组件？

结合 M（系统线程） 的定位来看，若这么做，有以下问题：

- 一般来讲，M 的数量都会多于 P。像在 Go 中，M 的数量默认是 10000，P 的默认数量的 CPU 核数。另外由于 M 的属性，也就是如果存在系统阻塞调用，阻塞了 M，又不够用的情况下，M 会不断增加。
- M 不断增加的话，如果本地队列挂载在 M 上，那就意味着本地队列也会随之增加。这显然是不合理的，因为本地队列的管理会变得复杂，且 Work Stealing 性能会大幅度下降。
- M 被系统调用阻塞后，我们是期望把他既有未执行的任务分配给其他继续运行的，而不是一阻塞就导致全部停止。

因此使用 M 是不合理的，那么引入新的组件 P，把本地队列关联到 P 上，就能很好的解决这个问题。

### 3、调度器的设计策略

**复用线程**：避免频繁的创建、销毁线程，而是对线程的复用。

1）work stealing（工作量窃取）机制

当本线程无可运行的G时，尝试从其他线程绑定的P偷取G，而不是销毁线程。

2）hand off（移交）机制

当本线程因为G进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的线程执行。

**利用并行**：GOMAXPROCS设置P的数量，最多有GOMAXPROCS个线程分布在多个CPU上同时运行。GOMAXPROCS也限制了并发的程度，比如GOMAXPROCS = 核数/2，则最多利用了一半的CPU核进行并行。

**抢占**：在coroutine中要等待一个协程主动让出CPU才执行下一个协程，在Go中，一个goroutine最多占用CPU 10ms，防止其他goroutine被饿死，这就是goroutine不同于coroutine的一个地方。

**全局G队列**：在新的调度器中依然有全局G队列，但功能已经被弱化了，当M执行work stealing从其他P偷不到G时，它可以从全局G队列获取G。

### **3、抢占式调度是如何抢占的？**

**基于协作式抢占**

**基于信号量抢占**

就像操作系统要负责线程的调度一样，Go的runtime要负责goroutine的调度。现代操作系统调度线程都是抢占式的，我们不能依赖用户代码主动让出CPU，或者因为IO、锁等待而让出，这样会造成调度的不公平。基于经典的时间片算法，当线程的时间片用完之后，会被时钟中断给打断，调度器会将当前线程的执行上下文进行保存，然后恢复下一个线程的上下文，分配新的时间片令其开始执行。这种抢占对于线程本身是无感知的，系统底层支持，不需要开发人员特殊处理。

基于时间片的抢占式调度有个明显的优点，能够避免CPU资源持续被少数线程占用，从而使其他线程长时间处于饥饿状态。goroutine的调度器也用到了时间片算法，但是和操作系统的线程调度还是有些区别的，因为整个Go程序都是运行在用户态的，所以不能像操作系统那样利用时钟中断来打断运行中的goroutine。也得益于完全在用户态实现，goroutine的调度切换更加轻量。

**上面这两段文字只是对调度的一个概括，具体的协作式调度、信号量调度大家还需要去详细了解，这偏底层了，大厂或者中高级开发会问。（字节就问了）**

### 4、调度器的生命周期

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1671108479128-e538cce4-0911-4683-ba0a-8a7866e4e2c1.png)

特殊的M0和G0

#### M0

M0是启动程序后的编号为0的主线程，这个M对应的实例会在全局变量runtime.m0中，不需要在heap上分配，M0负责执行初始化操作和启动第一个G， 在之后M0就和其他的M一样了。

#### G0

G0是每次启动一个M都会第一个创建的gourtine，G0仅用于负责调度的G，G0不指向任何可执行的函数, 每个M都会有一个自己的G0。在调度或系统调用时会使用G0的栈空间, 全局变量的G0是M0的G0。

我们来跟踪一段代码

```go
package main 
import "fmt" 
func main() {
    fmt.Println("Hello world") 
}
```

接下来我们来针对上面的代码对调度器里面的结构做一个分析。

也会经历如上图所示的过程：

1. runtime创建最初的线程m0和goroutine g0，并把2者关联。
2. 调度器初始化：初始化m0、栈、垃圾回收，以及创建和初始化由GOMAXPROCS个P构成的P列表。
3. 示例代码中的main函数是main.main，runtime中也有1个main函数——runtime.main，代码经过编译后，runtime.main会调用main.main，程序启动时会为runtime.main创建goroutine，称它为main goroutine吧，然后把main goroutine加入到P的本地队列。
4. 启动m0，m0已经绑定了P，会从P的本地队列获取G，获取到main goroutine。
5. G拥有栈，M根据G中的栈信息和调度信息设置运行环境
6. M运行G
7. G退出，再次回到M获取可运行的G，这样重复下去，直到main.main退出，runtime.main执行Defer和Panic处理，或调用runtime.exit退出程序。

调度器的生命周期几乎占满了一个Go程序的一生，runtime.main的goroutine执行之前都是为调度器做准备工作，runtime.main的goroutine运行，才是调度器的真正开始，直到runtime.main结束而结束。

## 八、锁相关

### 5、goroutine 的自旋占用资源如何解决

自旋锁是指当一个线程在获取锁的时候，如果锁已经被其他线程获取，那么该线程将循环等待，然后不断地判断是否能够被成功获取，直到获取到锁才会退出循环。

**自旋的条件如下：**

1）还没自旋超过 4 次,

2）多核处理器，

3）GOMAXPROCS > 1，

4）p 上本地 goroutine 队列为空。

mutex 会让当前的 goroutine 去空转 CPU，在空转完后再次调用 CAS 方法去尝试性的占有锁资源，直到不满足自旋条件，则最终会加入到等待队列里。

## **九、并发相关**

### 3、如何优雅的实现一个 goroutine 池

（百度、手写代码，本人面传音控股被问道：请求数大于消费能力怎么设计协程池）

这一块能啃下来，offer满天飞，这应该是保证高并发系统稳定性、高可用的核心部分之一。

**建议参考：**

[Golang学习篇--协程池_Word哥的博客-CSDN博客_golang协程池blog.csdn.net/finghting321/article/details/106492915/](https://link.zhihu.com/?target=https%3A//blog.csdn.net/finghting321/article/details/106492915/)

**这篇文章的目录是：**

\1. 为什么需要协程池？

\2. 简单的协程池

\3. go-playground/pool

\4. ants（推荐）

**所以直接研究ants底层吧，省的造轮子。**


## 十三、框架

### Gin

文档：https://gin-gonic.com/zh-cn/docs/introduction/

#### 0、特性

1. **快速**

1. 1. 基于 Radix 树的路由，小内存占用。没有反射。可预测的 API 性能。

1. **支持中间件**

1. 1. 传入的 HTTP 请求可以由一系列中间件和最终操作来处理。 例如：Logger，Authorization，GZIP，最终操作 DB。

1. **Crash 处理**

1. 1. Gin 可以 catch 一个发生在 HTTP 请求中的 panic 并 recover 它。这样，你的服务器将始终可用。例如，你可以向 Sentry 报告这个 panic！

1. **JSON 验证**

1. 1. Gin 可以解析并验证请求的 JSON，例如检查所需值的存在。

1. **路由组**

1. 1. 更好地组织路由。是否需要授权，不同的 API 版本…… 此外，这些组可以无限制地嵌套而不会降低性能。

1. **错误管理**

1. 1. Gin 提供了一种方便的方法来收集 HTTP 请求期间发生的所有错误。最终，中间件可以将它们写入日志文件，数据库并通过网络发送。

1. **内置渲染**

1. 1. Gin 为 JSON，XML 和 HTML 渲染提供了易于使用的 API。

1. **可扩展性**

1. 1. 新建一个中间件非常简单，去查看[示例代码](https://gin-gonic.com/zh-cn/docs/examples/using-middleware/)吧。

#### 1、[gin目录结构](https://blog.csdn.net/qq_34877350/article/details/107959381)

文档：https://blog.csdn.net/qq_34877350/article/details/107959381

```plain
├── gin
│   ├──  Router
│          └── router.go
│   ├──  Middlewares
│          └── corsMiddleware.go
│   ├──  Controllers
│          └── testController.go
│   ├──  Services
│          └── testService.go
│   ├──  Models
│          └── testModel.go
│   ├──  Databases
│          └── mysql.go
│   ├──  Sessions
│          └── session.go
└── main.go
```

- 使用gorm访问数据库
- gin 为项目根目录
- main.go 为入口文件
- Router 为路由目录
- Middlewares 为中间件目录
- Controllers 为控制器目录（MVC）
- Services 为服务层目录，这里把DAO逻辑也写入其中，如果分开也可以
- Models 为模型目录
- Databases 为数据库初始化目录
- Sessions 为session初始化目录
- 文件 引用顺序 大致如下：
- main.go(在main中关闭数据库) - router(Middlewares) - Controllers - Services(sessions) - Models - Databases

#### 2、[Gin框架介绍及使用 - 李文周的博客](https://www.liwenzhou.com/posts/Go/Gin_framework/#autoid-0-0-0)

文档：https://www.liwenzhou.com/posts/Go/Gin_framework/#autoid-0-0-0

#### 3、源码

[Gin源码阅读与分析](https://www.yuque.com/iveryimportantpig/huchao/zd24cb3z2bco5304)：https://www.yuque.com/iveryimportantpig/huchao/zd24cb3z2bco5304

### go-zero

文档：https://go-zero.dev/cn/docs/introduction

go-zero 是一个集成了各种工程实践的 web 和 rpc 框架。通过弹性设计保障了大并发服务端的稳定性，经受了充分的实战检验。

go-zero 包含极简的 API 定义和生成工具 goctl，可以根据定义的 api 文件一键生成 Go, iOS, Android, Kotlin, Dart, TypeScript, JavaScript 代码，并可直接运行。

使用 go-zero 的好处：

- 轻松获得支撑千万日活服务的稳定性
- 内建级联超时控制、限流、自适应熔断、自适应降载等微服务治理能力，无需配置和额外代码
- 微服务治理中间件可无缝集成到其它现有框架使用
- 极简的 API 描述，一键生成各端代码
- 自动校验客户端请求参数合法性
- 大量微服务治理和并发工具包

### 字节-CloudWeGo

文档：https://www.cloudwego.io/zh/docs/

### HTTP-Hertz

文档：https://www.cloudwego.io/zh/docs/hertz/overview/

是一个 Golang 微服务 HTTP 框架，在设计之初参考了其他开源框架 [fasthttp](https://github.com/valyala/fasthttp)、[gin](https://github.com/gin-gonic/gin)、[echo](https://github.com/labstack/echo) 的优势， 并结合字节跳动内部的需求，使其具有高易用性、高性能、高扩展性等特点，目前在字节跳动内部已广泛使用。 如今越来越多的微服务选择使用 Golang，如果对微服务性能有要求，又希望框架能够充分满足内部的可定制化需求，Hertz 会是一个不错的选择。

**特点**

- 高易用性在开发过程中，快速写出来正确的代码往往是更重要的。因此，在 Hertz 在迭代过程中，积极听取用户意见，持续打磨框架，希望为用户提供一个更好的使用体验，帮助用户更快的写出正确的代码。
- 高性能Hertz 默认使用自研的高性能网络库 Netpoll，在一些特殊场景相较于 go net，Hertz 在 QPS、时延上均具有一定优势。关于性能数据，可参考下图 Echo 数据。四个框架的对比:![img](https://cdn.nlark.com/yuque/0/2023/png/22219483/1675414683589-8ae9d18c-b2e6-43bd-943f-7392415e0e74.png)三个框架的对比:![img](https://cdn.nlark.com/yuque/0/2023/png/22219483/1675414685005-e51955bc-2290-48b8-8782-11f6a26f4efc.png)关于详细的性能数据，可参考 https://github.com/cloudwego/hertz-benchmark。
- 高扩展性Hertz 采用了分层设计，提供了较多的接口以及默认的扩展实现，用户也可以自行扩展。同时得益于框架的分层设计，框架的扩展性也会大很多。目前仅将稳定的能力开源给社区，更多的规划参考 [RoadMap](https://github.com/cloudwego/hertz/blob/main/ROADMAP.md)。
- 多协议支持Hertz 框架原生提供 HTTP1.1、ALPN 协议支持。除此之外，由于分层设计，Hertz 甚至支持自定义构建协议解析逻辑，以满足协议层扩展的任意需求。
- 网络层切换能力Hertz 实现了 Netpoll 和 Golang 原生网络库 间按需切换能力，用户可以针对不同的场景选择合适的网络库，同时也支持以插件的方式为 Hertz 扩展网络库实现。

### RPC-Kitex 

文档：https://www.cloudwego.io/zh/docs/kitex/overview/

字节跳动内部的 Golang 微服务 RPC 框架，具有**高性能**、**强可扩展**的特点，在字节内部已广泛使用。如果对微服务性能有要求，又希望定制扩展融入自己的治理体系，Kitex 会是一个不错的选择。

**框架特点**

- **高性能**使用自研的高性能网络库 [Netpoll](https://github.com/cloudwego/netpoll)，性能相较 go net 具有显著优势。
- **扩展性**提供了较多的扩展接口以及默认扩展实现，使用者也可以根据需要自行定制扩展，具体见下面的框架扩展。
- **多消息协议**RPC 消息协议默认支持 **Thrift**、**Kitex Protobuf**、**gRPC**。Thrift 支持 Buffered 和 Framed 二进制协议；Kitex Protobuf 是 Kitex 自定义的 Protobuf 消息协议，协议格式类似 Thrift；gRPC 是对 gRPC 消息协议的支持，可以与 gRPC 互通。除此之外，使用者也可以扩展自己的消息协议。
- **多传输协议**传输协议封装消息协议进行 RPC 互通，传输协议可以额外透传元信息，用于服务治理，Kitex 支持的传输协议有 **TTHeader**、**HTTP2**。TTHeader 可以和 Thrift、Kitex Protobuf 结合使用；HTTP2 目前主要是结合 gRPC 协议使用，后续也会支持 Thrift。
- **多种消息类型**支持 **PingPong**、**Oneway**、**双向 Streaming**。其中 Oneway 目前只对 Thrift 协议支持，双向 Streaming 只对 gRPC 支持，后续会考虑支持 Thrift 的双向 Streaming。
- **服务治理**支持服务注册/发现、负载均衡、熔断、限流、重试、监控、链路跟踪、日志、诊断等服务治理模块，大部分均已提供默认扩展，使用者可选择集成。
- **代码生成**Kitex 内置代码生成工具，可支持生成 **Thrift**、**Protobuf** 以及脚手架代码。









## golang方面
#### 1. go struct能不能比较
因为是强类型语言，所以不同类型的结构不能作比较，但是同一类型的实例值是可以比较的，实例不可以比较，因为是指针类型


#### 3.channnel

##### 切片、map、channel是否并发安全

切片和映射（map）的访问和操作不是并发安全的，需要采取额外的措施来确保并发安全。而通道（channel）则是并发安全的，因为通道在设计时就考虑了并发性。

切片和映射的非并发安全性主要表现在两个方面：

1. 内部结构的修改：切片和映射都有一个内部的结构，包含指向底层数组或哈希表的指针、长度和容量等信息。当多个 goroutine 并发修改这些信息时，可能会导致数据的不一致性，甚至破坏整个数据结构。
2. 并发读写的竞争：当多个 goroutine 并发读写同一个切片或映射时，可能会出现竞争条件，导致数据的不一致性或不可预期的结果。

为了确保切片和映射的并发安全，可以采用以下方法：

1. 互斥锁：使用 sync.Mutex 或 sync.RWMutex 等同步原语，在访问和修改切片或映射时加锁，避免多个 goroutine 同时修改数据结构。

2. 原子操作：使用 sync/atomic 包中的原子操作，可以在不使用互斥锁的情况下进行原子性操作，避免竞争条件。

   

   通道是并发安全的，因为通道内部维护了一个队列，每次只有一个 goroutine 可以向通道发送或接收数据，其他 goroutine 需要等待该操作完成后才能进行下一步操作。这种方式保证了数据的顺序和一致性，避免了竞争条件和数据不一致性的问题。

##### sync.map底层分片原理

sync.map底层使用了分片技术，将整个map分成多个小的map，每个小的map称为一个分片。每个分片都有自己的读写锁，可以独立地进行读写操作，从而提高了并发性能。

具体来说，sync.map将key通过哈希函数映射到不同的分片中，每个分片中包含了一部分key-value对。当进行读写操作时，先根据key计算出对应的分片，然后在该分片中进行操作。这样就可以避免多个goroutine同时访问同一个分片，从而提高了并发性能。

在实现上，sync.map使用了一个数组来存储所有的分片，每个分片都是一个结构体，包含了一个读写锁和一个map。当进行读写操作时，先根据key计算出对应的分片索引，然后在该分片中进行操作。由于每个分片都有自己的读写锁，因此可以并发地进行读写操作，从而提高了并发性能。

总之，sync.map底层使用了分片技术，将整个map分成多个小的map，每个小的map称为一个分片，从而提高了并发性能。

##### channel读写特性

- 给一个 nil channel 发送数据，造成永远阻塞
- 从一个 nil channel 接收数据，造成永远阻塞
- 给一个已经关闭的 channel 发送数据，引起 panic
- 从一个已经关闭的 channel 接收数据，如果缓冲区中为空，则返回一个零值
- 无缓冲的channel是同步的，而有缓冲的channel是非同步的

以上5个特性是死东西，也可以通过口诀来记忆：“空读写阻塞，写关闭异常，读关闭空零”。

##### 从channel读数据

1. 如果等待发送队列sendq不为空，且没有缓冲区，直接从sendq中取出G，把G中数据读出，最后把G唤醒，结束读取过程； 
2. 如果等待发送队列sendq不为空，此时说明缓冲区已满，从缓冲区中首部读出数据，把G中数据写入缓冲区尾部，把G唤 醒，结束读取过程；
3.  如果缓冲区中有数据，则从缓冲区取出数据，结束读取过程；
4. 将当前goroutine加入recvq，进入睡眠，等待被写goroutine唤醒；

##### 关闭channel

关闭channel时会把recvq中的G全部唤醒，本该写入G的数据位置为nil。把sendq中的G全部唤醒，但这些G会panic。 除此之外，panic出现的常见场景还有： 

1. 关闭值为nil的channel
2. 关闭已经被关闭的channel
3. 向已经关闭的channel写数据

##### select监听管道

select的case语句读channel不会阻塞，尽管channel中没有数据。这是由于case语句编译后调用读 channel时会明确传入不阻塞的参数，此时读不到数据时不会将当前goroutine加入到等待队列，而是直接返回。

##### range遍历管道

相当于读，会发生管道阻塞

#### Slice

##### 分配切片的几种方式

make([]T,len)

make([]T,len,cap)

原数组上划分 slice := lice := array[5:7]，创建数组的长度为元素数量，容量为从开始到原数组最后的位置

![image-20220609142603339](C:\Users\fliggy\AppData\Roaming\Typora\typora-user-images\image-20220609142603339.png)

slice := arr[start:end：max]

start 开始位置，end结束位置，max（max不能小于长度，不能大于原数组的长度）

##### 切片扩容

切片的扩容

1. 小于1024 2倍扩容
2. 大于1024 1.25倍扩容

扩容之后，切片指向的底层数组放生变化

![image-20220611161140068](C:\Users\fliggy\AppData\Roaming\Typora\typora-user-images\image-20220611161140068.png)

##### 切片拷贝

使用copy()内置函数拷贝两个切片时，会将源切片的数据逐个拷贝到目的切片指向的数组中，拷贝数量取两个切片长度的最小 值。 

例如长度为10的切片拷贝到长度为5的切片时，将会拷贝5个元素。 也就是说，copy过程中不会发生扩容。

##### 总结

append函数总会返回新的切片，而且如果新切片的容量比原切片的容量更大那么就 意味着底层数组也是新的了。

通过函数传递切片时，不会拷贝整个切片，因为切片本身只是个结构体而已


#### struct中tag

Go的struct声明允许字段附带 Tag 来对字段做一些标记。 该 Tag 不仅仅是一个字符串那么简单，因为其主要用于反射场景， reflect 包中提供了操作 Tag 的方法，所 以 Tag 写法也要遵循一定的规则。

##### tag是struct中的一部分

Go 是如何管理struct字段的。

```go
// A StructField describes a single field in a struct.
type StructField struct {
	// Name is the field name.
    Name string
    ...
    Type Type // field type
    Tag StructTag // field tag string
    ...
}
type StructTag string
```

##### 获取tag

通过反射获取

#### Iota

##### iota规则

iota代表了const声明块的行索引（下标从0开始）

除此之外，const声明还有个特点，即第一个常量必须指定一个表达式，后续的常 量如果没有表达式，则继承上面的表达式。

```go
const (
    bit0, mask0 = 1 << iota, 1<<iota - 1 //const声明第0行，即iota==0
    bit1, mask1 //const声明第1行，即iota==1, 表达式继承上面的语句
    _, _ //const声明第2行，即iota==2
    bit3, mask3 //const声明第3行，即iota==3
)
```

##### 编译原理（理解规则）

```go
ValueSpec struct {
    Doc *CommentGroup // associated documentation; or nil
    Names []*Ident // value names (len(Names) > 0)
    Type Expr // value type; or nil
    Values []Expr // initial values; or nil
    Comment *CommentGroup // line comments; or nil
}
```

其中iota实际每一行对应一个ValueSpec存储

对应一个ValueSpec，表示了这一行中多次的iota定义

const块实际上是spec类型的切片，用于表示const中的多行。 

所以编译期间构造常量时的伪算法如下：

```go
for iota, spec := range ValueSpecs {
    for i, name := range spec.Names {
        obj := NewConst(name, iota...) //此处将iota传入，用于构造常量
        ...
    }
}
```

从上面可以更清晰的看出iota实际上是遍历const块的索引，每行中即便多次使用iota，其值也不会递增。

#### string

##### 数据结构

Go标准库 builtin 给出了所有内置类型的定义。 源代码位于 src/builtin/builtin.go ，其中关于string的描述如下

- string可以为空（长度为0），但不会是nil
- string对象不可以修改

```go
type stringStruct struct {
    str unsafe.Pointer //首地址
    len int //长度
}
```

##### []byte转string

```go
func GetStringBySlice(s []byte) string {
    return string(s)
}

转换过程如下：
1. 根据切片的长度申请内存空间，假设内存地址为p，切片长度为len(b)；
2. 构建string（string.str = p；string.len = len；）
3. 拷贝数据(切片中数据拷贝到新申请的内存空间)
```

##### 字符串拼接

```go
func concatstrings(a []string) string { // 字符串拼接
    length := 0 // 拼接后总的字符串长度
    for _, str := range a {
    	length += len(str)
    }
    s, b := rawstring(length) // 生成指定大小的字符串，返回一个string和切片，二者共享内存空间
    for _, str := range a {
        copy(b, str) // string无法修改，只能通过切片修改
        b = b[len(str):]
    } 
	return s
}

```

##### 为什么字符串不允许修改

因为string通常指向字符串字面量，而字符串字面量存储位置是只读段，而不是堆或栈上，所以才有了string不可修改的约定。

##### []byte转换成string一定会拷贝内存吗？

yte切片转换成string的场景很多，为了性能上的考虑，有时候只是临时需要字符串的场景下，byte切片转换成string时并不 会拷贝内存，而是直接返回一个string，这个string的指针(string.str)指向切片的内存

比如，编译器会识别如下临时场景： 

- 使用m[string(b)]来查找map（map是string为key，临时把切片b转成string）； 
- 字符串拼接，如”<” + “string(b)” + “>”；
- 字符串比较：string(b) == “foo”

#### 常见控制结构

##### defer

###### deffer规则

- 延迟函数的参数在defer语句出现时就已经确定下来了
- 延迟函数执行按后进先出顺序执行，即先出现的defer最后执 行

设计defer的初衷是简化函数返回时资源清理的动作，资源往往有依赖顺序，比如先申请A资源，再根据A资源申请B资源，根据 B资源申请C资源，即申请顺序是:A–>B–>C，释放时往往又要反向进行。这就是把defer设计成LIFO的原因。

- 延迟函数**可能**操作主函数的具名返回值（注意是可能）


##### recover 失效的条件

1. panic时指定的参数为 nil ；（一般panic语句如 panic("xxx failed...") ）
2. 当前协程没有发生panic； 
3. recover没有被defer方法直接调用；

##### select

select是Golang在语言层面提供的**多路IO复用**的机制，其可以检测多个channel是否ready(即是否可读或可写)

##### range

- 遍历过程中每次迭代会对index和value进行赋值，如果数据量大或者value类型为string时，对value的赋值操作可能是多余 的，可以在for-range中忽略value值，使用slice[index]引用value值。
- 另外range会复制对象，在你遍历对象之前，k，v就已经被确定了。这时候如果去修改数组的值，对遍历出来的v没有任何影响

```go
package main

import "fmt"

func main() {
    a := [3]int{0, 1, 2}

    for i, v := range a { // index、value 都是从复制品中取出。

        if i == 0 { // 在修改前，我们先修改原数组。
            a[1], a[2] = 999, 999
            fmt.Println(a) // 确认修改有效，输出 [0, 999, 999]。
        }

        a[i] = v + 100 // 使用复制品中取出的 value 修改原数组。

    }

    fmt.Println(a) // 输出 [100, 101, 102]。
}

	a:= []int{0, 1, 2}

	for i, v := range a { // index、value 都是从复制品中取出。

		if i == 0 { // 在修改前，我们先修改原数组。
			a[1], a[2] = 999, 999
			fmt.Println(a) // 确认修改有效，输出 [0, 999, 999]。
		}

		a[i] = v + 100 // 使用复制品中取出的 value 修改原数组。

	}

	fmt.Println(a) // 输出 [100, 1099, 1099]。
}
//原因就在于虽然切片被拷贝了，但是指向的底层数组并没有发生改变
```

- 遍历过程中可以视情况放弃接收index或value，可以一定程度上提升性能 
- 遍历channel时，如果channel中没有数据，可能会阻塞 
- 尽量避免遍历过程中修改原数据

#### 协程调度

#### 内存对齐

- 起始地址必须是对齐边界倍数
- 长度必须是对齐边界的倍数

保证了，不能有多余的取值操作

- 结构体对齐边界为，结构体字段中最大的对齐边界

![image-20220611165047235](C:\Users\fliggy\AppData\Roaming\Typora\typora-user-images\image-20220611165047235.png)

![image-20220611165030945](C:\Users\fliggy\AppData\Roaming\Typora\typora-user-images\image-20220611165030945.png)

### Linux进程

#### 进程

进程是计算机中已运行程序的实体

#### PID/PPID

pid表示进程id，ppid表示进程父id

