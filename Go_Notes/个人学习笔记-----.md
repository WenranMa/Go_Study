###  1.1.1. Go编译

- 词法与语法分析
  - 意义:解析源代码文件,将文件中字符串序列转换成Token序列
  - 把执行词法分析的程序称为词法解析器(lexer)
  - 语法解析的结果就是抽象语法树(AST)
  - 每个AST都对应一个单独的Go语言文件,这个抽象语法树中包括当前文件属于的包名,定义的常量,结构体和函数等
  - 如果发生错误,被语法解析器发现并将消息打印在标准输出上,编译过程直接中止
  - Go语言早期用lex做词法分析,后续还是使用Go语言实现词法分析器,自己写的词法分析器分析自己
- 类型检查和AST转换
  - 编译器对语法树中定义和使用的类型进行检查
  - 遍历抽象节点树,保证当前节点上不会出现类型错误
  - 不仅对类型进行检查,还会对内置函数进行展开和改写,比如`make`关键字在这个阶段会根据子树的结构被替换成`makeslice` 或者 `makechan` 等函数
- 通用SSA(静态单赋值)生成
  - 使用SSA特性,分析代码中无用变量和片段进行优化
  - 类型检查之后,就对Go语言项目全部函数进行编译,生成中间代码
  - 关键字和内置函数的功能其实是由语言的编译器和运行时共同完成的
- 机器代码生成
  - 根据机器不同,生成不同的机器码

### 1.1.2. 函数

#### 调用惯例

- C语言的函数的参数是通过寄存器和栈传递的
  - x86_64的机器,6个(含6个)的参数会按照顺序分别使用 edi、esi、edx、ecx、r8d 和 r9d 六个寄存器传递，超过 6 个的剩余参数会通过栈进行传递
  - 函数的返回是通过eax 寄存器进行传递的,所以不支持多个返回值
- Go语言传递和接收参数使用的都是栈
  - 但是需要注意,函数入参和出参的内存空间都需要调用方再栈上进行分配
  - 好处:
    - 能够降低实现的复杂度(不需要考虑超过寄存器个数的参数应该如何传递)
    - 更方便的兼容不同的硬件(不同cpu的寄存器差别比较大)
    - 函数可以具有多个返回值(栈上的内存地址相比寄存器的个人是无限的,使用寄存器支持多个返回值也会非常困难,超出寄存器多个返回值也需要使用栈来传递)
  - 通过堆栈传递参数,入栈的顺序都是从右到左
  - 函数返回通过堆栈传递并由调用者预先分配内存空间

#### 参数的传递

- 无论是传递基本类型,结构体还是指针,都会对传递的参数进行拷贝
- 指针作为参数传入某一个函数的时候,其实在函数内部会对指针进行复制,也就是会同时出现两个指针指向原有的内存空间,所以Golang传指针也是传值
- 调用函数都是传值,接收方会对入参进行复制再计算

### 1.1.3. 接口

其本质就是引入一个中间层对不同的模块进行解耦,上层的模块就不需要依赖某一个具体的实现! Go语言中的接口`interface` 不仅是一组方法,还是一种内置的类型

Go语言中所有的接口的实现都是隐式的

#### 接口类型

> interface{}类型并不表示任意类型, interface{}类型的变量再运行期间的类型只是interface{}
>
> go/src/runtime/runtime2.go#144

##### 带有一组方法的接口

- 表示成 `iface`结构体

```go
type iface struct {
    tab  *itab
    data unsafe.Pointer
}
Copy
```

##### itab结构体

```go
// layout of Itab known to compilers
// allocated in non-garbage-collected memory
// Needs to be in sync with
// ../cmd/compile/data-sync/gc/reflect.go:/^func.dumptypestructs.
type itab struct {
    inter *interfacetype
    _type *_type
    hash  uint32 // copy of _type.hash. Used for type switches.
    _     [4]byte
    fun   [1]uintptr // variable sized. fun[0]==0 means _type does not implement inter.
}
Copy
```

- `interfacetype` 是对 `_type`类型的简单封装
- `hash` 对 `_type.hash`的拷贝, 它会从 `interface` 到具体类型的切换时用于 快速判断目标类型和接口中类型是否一致
- `fun` 数组其实是一个动态大小的数组,如果数组中内容为空表示 `_type`没有实现`inter`接口,虽然这是一个大小固定的数组,但是在使用时会直接通过指针获取其中的数据并不会检查数组的边界,所以该数组中保存的元素数量是不确定的

##### 不带有任何方法的`interface{}`类型

- 表示成`eface`结构体
- 很常见,实现成一种特殊的类型

```go
type eface struct {
    _type *_type
    data  unsafe.Pointer
}
Copy
```

- `_type` 类型有点复杂.. 不看了..

#### 动态派发

运行期间选择具体的多态操作执行的过程,在Go语言中,对于一个接口类型的方法调用,会在运行期间决定具体调用该方法的哪个实现

动态派发会出现一些消耗,但一般项目中不可能只存在动态派发的调用,荔港南湾,如果开启默认的编译器优化,动态派发开销还会降低,所以对整体性能影响很小

结构体指针换成结构体,消耗区别有点大,原因是 Go 函数调用是值传递,会出现参数拷贝,所以对于大结构体,参数拷贝会消耗非常多资源,所以应该用指针来传递大结构体

### 1.1.4. 数组与切片

#### 数组

- 数组是由相同类型元素的集合组成的数据结构
- 数组大小在初始化之后就无法改变
- 编译期间,数组类型`Array`包含两个结构,一个是元素类型`Elem`, 另一个是数组的大小上限`Bound`,这两字段组成了数组类型
- 数组创建可以显式指定数组的大小,也可以根据源代码自定推断数组的大小,不过后者在编译期间会被转换前一种 -

##### 数组上限推导

- 显式创建,变量类型会在编译进行到 类型检查 阶段就会被推断出来
- 非显式创建,会在 编译进行 类型检查 时候也会创建一个 `Array` 类型,不过`Bound = -1` 后面会推到该数组大小
- 所以`[...]T`类型的声明不是在运行是被推导的,会在类型检查期间就被推断出正确的数组大小

##### 语句转换

- `[...]T{1, 2, 3}`与`[3]T{1, 2, 3}` 运行的时候 是等价的,理由如上
- 根据数组元素不同,会有不同的优化
  - 当元素数量小于或者等于4个时,会直接将数组中的元素放置在栈上
  - 当元素数量大于4个时,会将数组中的元素放置到静态区并在运行时取出
- 总结: 数组元素个数小于等于4个,所有变量会直接在栈上初始化,如果数组数量大于4个,变量就会在静态存储区初始化然后拷贝到栈上,转换后的代码才会进入 中间代码生成 和机器码生成阶段,最后生成可执行的二进制文件

##### 访问和赋值

- 数组在内存中其实就是一连串的内存空间,表示数组的方法就是一个指向数组开头的指针
- 数组访问越界的判断也是在编译期间由静态类型检查完成的
- 数组的赋值和更新 也会在生成SSA期间就计算出数组当前元素的内存地址,然后修改当前内存地址的内容
- 数组的寻址或者赋值都是编译阶段完成,没有运行时的参与

#### 切片

- 切片其实就是动态数组,长度不固定
- 切片在编译期间应该只会包含切片中的元素类型 `Slice{Elem: elem}`
- 切片的操作基本都是在编译期间完成的,除了访问切片的长度,容量或者其中的元素之外,使用`range`遍历切片时也是在编译期间被转换成了形式更简单的代码

##### 切片结构

```go
type SliceHeader struct {
    Data uintptr // 指向数组的指针
    Len  int // 当前切片长度
    Cap  int // 切片的容量
}
Copy
```

##### 切片初始化

- 字面量
  - `slice := []int{1, 2, 3}` -
- 关键字
  - slice := make([]int, 10)


##### 切片拷贝

- `copy(a, b)` 会在编译期间转换成`slicecopy`函数
- 切片中全部元素通过`memmove`或者数组指针的方式将整块内存中的内容拷贝到目标的内存区域,所以大切片拷贝需要注意性能影响,不过比一个个的复制要有更好的性能

##### 数组和切片总结

- 数组大多都是在 编译期间都转换成内存的直接读写
- 切片很多功能都需要运行时的支持

### 1.1.5. 哈希表

- 哈希表示键值之间隐射关系

- 哈希函数
  - 理想状态是 不同的键映射到不同的唯一索引上,要求哈希函数的输出范围大于输入范围,但是实际使用时这种理想状态是不可能实现的

#### 哈希冲突解决

- 开放寻址法
  - 在一堆数组对元素进行探测和比较以判断待查找的目标键是否存在当前的哈希表中
  - 初始化哈希表时会创建一个新的数组,如果哈希表写入新的数据发生了冲突,就会将键值对写入到下一个不为空的位置
  - 查找时,按照我的理解,应该是先哈希key,找到对应的位置上,然后对比key,如果不一样,继续往下找,除非找到对应的key或者内存为空为止
  - 数组中元素数量与数组大小的比值叫做装载因子,随着装载因子增加,线性探索的评价用时就会逐渐增加,到百分之七十之后性能明显下降,一旦到百分之百,整个哈希表就会完全失效
- 拉链法
  - 实现比较简单,存储节点的内存是动态申请的,比较节省空间
  - 就是数组加上链表组合起来实现哈希表,数组中每个元素都是一个链表
  - 插入时,先对key进行hash,找到数组上对应的点(桶),然后遍历桶里的链表,如果有相同的就修改,没有就加在链表最末尾
  - 性能比较好的哈希表中,每个桶里大约有0或者1个元素,偶尔会有2到3个,很少会超过这个数

#### 结构

```go
type hmap struct {
    count     int // 用于记录当前哈希表元素数量,这个元素让我们不在需要去遍历整个哈希表来获取长度
    flags     uint8
    B         uint8  // 表示当前哈希表持有的 `buckets` 数量,因为哈希表扩容是以2倍进行的,所以这里会使用对数来存储, 简单理解成 `len(buckets) == 2^B` 
    noverflow uint16
    hash0     uint32 // 哈希的种子,这个值会在调用哈希函数时作为参数传入进去,主要作用是为哈希函数的结果引入一定的随机性

    buckets    unsafe.Pointer
    oldbuckets unsafe.Pointer // 哈希在扩容时用于保存之前的 `buckets`的字段,它的大小是当前`buckets`的一半
    nevacuate  uintptr

    extra *mapextra
}
```

#### 字面量

- 编译时用`maplit`进行初始化

- 当哈希表中元素数量小于等于25个时,编译器会调用`addMapEntries`将结构体转成单独的键值对,比如 hash["a"] = 1, hash["b"] = 2

- 当元素数量超过25个,会在编译期间创建两个数组分别存储键和值的信息,这些键值会通过一个for循环假如目标的哈希

  ```go
  hash := make(map[string]int, 26)
  vstatk := []string{"1", "2", "3", ... ， "26"}
  vstatv := []int{1, 2, 3, ... , 26}
  for i := 0; i < len(vstak); i++ {
    hash[vstatk[i]] = vstatv[i]
  }
  Copy
  ```

#### 运行时

- 编译期间`make`转换成`makemap`来创建哈希表
- 根据`B`算出需要创建的桶数量,在内存里分配一片连续空间用于存储数据,创建过程中,还会创建一些用于保存溢出数据的桶,数量 2^(B-4)个
- 哈希表的桶最多只能存储8个元素,如果超过8个,效率会下降,所以会进行扩容或者使用额外的桶存储溢出的数据,不会让桶里数据超过8个

#### 访问

- 类型检查阶段,类似`hash[key]`的`OINDEX`操作都会被转换成`OINDEXMAP`操作,中间代码生成阶段,在`walkexpr`中将这些`OINDEXMAP`转成

  ```go
  v     := hash[key] // => v     := *mapaccess1(maptype, hash, &key)
  v, ok := hash[key] // => v, ok := mapaccess2(maptype, hash, &key)
  Copy
  ```

- 当接收参数就一个时,使用`mapaccess1`函数,如果多加一个是否存在的布尔值就会使用`mapaccess2`

- 在这个函数中我们首先会通过哈希表设置的哈希函数、种子获取当前键对应的哈希，再通过 bucketMask 和 add 函数拿到该键值对所在的桶和哈希最上面的 8 位数字，这 8 位数字最终就会与桶中存储的 tophash 作对比，每一个桶其实都存储了 8 个 tophash，就是编译期间的 topbits 字段，每一次都会与桶中全部的 8 个 uint8 进行比较，这 8 位的 tophash 其实就像是一级缓存，它存储的是哈希最高的 8 位，而选择桶时使用了桶掩码使用的是最低的几位，这种方式能够帮助我们快速判断当前的键值对是否存在并且减少碰撞,每一个桶都是一整片的内存空间，当我们发现某一个 topbits 与传入键的 tophash 匹配时，通过指针和偏移量获取哈希中存储的键并对两者进行比较，如果相同就会通过相同的方法获取目标值的指针并返回。另一个同样用于访问哈希表中数据的 mapaccess2 函数其实只是在 mapaccess1 的基础上同时返回了一个标识当前数据是否存在的布尔值

#### 写入

- 当哈希表没有处于扩容状态并且装载因子超过了6.5或者存在了太多溢出的桶,调用`hashGrow`对当前哈希表进行扩容
- 装载因子是同时由 `loadFactorNum` 和 `loadFactDen` 两个参数决定的，前者在 Go 源代码中的定义是 13 后者是 2，所以装载因子就是 6.5
- 如果桶满了,会调用 `newoverflow` 创建一个新的桶或者使用`hmap`预先在`noverflow`中创建好的桶来保存数据,新创建的桶的指针会被追加到已有桶中,与此同时,溢出桶的创建会增加哈希表的`noverflow`计数器
- 如果哈希表存储的键值是指针类型,其实就会被当前的键值对分别申请一块新的内存空间,并在插入的位置通过`eypedmemmove`将键移动到申请的内存空间,最后返回键对应的地址

#### 扩容

- 如果扩容是溢出的桶太多,那么就是 `sameSizeGrow`
- 如果是一次不改变大小的扩容,`evacDst`结构体只会初始化一个,当哈希表容量翻倍时,一个桶中的元素会被分流到新创建的两个桶中,这两个桶会被`evacDst`数组引用

#### 删除

- `delete`关键字,将某一个键对应的元素从哈希表中删除,无论该键对应的值是否存在,这个内建的函数都不会返回任何的结果
- 如果在删除期间遇到哈希表的扩容,就会对即将操作的桶进行分流,随后找到桶中的目标元素并根据数据的类型调用`memclrHasPointers` 或者 `memclrNoHeapPointers` 函数完成键值对的删除
- `delete`在类型检查阶段被转换成`ODELETE`操作,然后在 `SSA中间代码生成`时被转换成`mapdelete`函数簇

#### 哈希表总结

- Go语言用拉链法来解决哈希碰撞
- 哈希在每一个桶中存储键对应哈希的前8位,当对哈希进行操作时,这些 `tophash`就成了一级缓存帮助哈希快速遍历桶中元素
- 每个桶只能存储8个键值对,一旦某个桶超过8个,新的键值对会被存储到哈希的溢出桶中
- 当键值对数量的增加,装载因子升高,到一定范围后,会出发扩容操作,扩容时将桶的数量分配,元素再分配的过程也是在调用写操作时增量进行的,不会造成性能的瞬时巨大波动



### 1.1.7. for 和 range

- for 经典循环
- for...range 范围循环 编译器会在编译期间将带有`range`的循环变成普通的经典循环,这个过程发生在 SSA中间代码 阶段,所有的`range`都会被`walkrange` 函数转换成只包含基本表达式的语句,不包含任何复杂的结构

##### 遍历数组和切片

- 对于所以的`range`循环,Go语言都会在编译期间将原切片或者数组赋值给一个新的变量`ha`,在赋值的过程中其实就发生了拷贝,所以我们遍历的切片其实已经不是原有的切片变量了!
- 当同时遍历索引和元素的`range`循环时,Go语言会额外创建一个新的`v2`变量存储切片中的元素,循环中使用的这个变量v2会在每一次迭代中都被重新赋值,在赋值时也发生了拷贝, 所以我们想要访问数组中元素所在的地址,不应该直接获取`range`返回的`v2`变量的地址`&v2`,想要解决这个问题应该使用`&a[index]`这种方式获取数组中元素对应的地址

##### 遍历哈希

- 哈希表遍历会随机(`fastrand`函数)选择开始的位置,然后依次遍历桶中的元素,桶中元素如果被遍历完,就会遍历当前桶对应的溢出桶,溢出桶都遍历结束之后才会遍历哈希中下一个桶,直到所有的桶都被遍历完

##### 遍历字符串

- 遍历过程中会获取字符串中索引对应的字节,然后将字节转换成`rune`,我们在遍历字符串时拿到的值都是`rune`类型的变量

##### 遍历通道

- 循环会使用`<-ch`从管道中取出等待处理的值,这个操作会调用`chanrecv2`并阻塞当前的协程,当`chanrecv2`返回时会根据`hb`来判断当前的值是否存在,如果不存在就意味着当前的管道已经被关闭了,在正常情况下都会为`v1`赋值并清除`hv1`中的数据,然后会陷入下一次的阻塞等待接受新的数据




### 1.1.8. defer

- 作用域结束之后执行函数的关键字
- `defer`实现是由编译器和运行时共同完成的



##### 实现原理

```go
type _defer struct {
    siz     int32
    started bool
    sp      uintptr
    pc      uintptr
    fn      *funcval
    _panic  *_panic
    link    *_defer
}
Copy
```

- `sp`和`pc`分别指向了栈指针和调用方的程序计数器,`fn`存储的就是向`defer`关键字中传入的函数
- `defer` 关键字在编译期间的SSA阶段才被`stmt`函数处理的,中间详情不表
- 运行时,每一个`defer`关键字都会被转换成`deferproc`,这个函数里会为`defer`创建一个新的`_defer`结构体并设置它的`fn`,`pc`和`sp`参数,并将`defer`相关的函数都拷贝到紧挨着结构体的内存空间中

##### 总结

- `defer`关键字会在编译阶段被转换成`deferproc`的函数并在函数返回之前插入`deferreturn`指令,在运行期间,每一次`deferproc`的调用都会将一个新的`_defer`结构体追加到当前Goroutine持有的链表头,而`deferreturn`会从Goroutine中取出`_defer`结构并以此执行,所有的`_defer`结构执行成功之后当前函数才返回!



### 1.1.9. panic 和 recover

- panic 能改变程序的控制流,当函数调用执行panic,它会立刻停止执行函数其他的代码,而是会运行其中的`defer`函数,执行成功返回到调用方
- 调用导致panic和直接调用`panic`类似,执行所有的`defer`函数并返回到它的调用方,这个过程会一直进行到当前的Goroutine的调用栈不包含任何的函数,这时整个程序才会崩溃
- `panic`导致的`恐慌`状态其实可以被`defer`中的`recover`中止,`recover`是一个只在`defer`中能够发挥作用的函数,在正常的控制流程中,`recover`会直接返回`nil`并没有任何的作用,如果当前的Goroutine发生了`恐慌`,`recover`就能够捕获到`panic`抛出的错误并阻止`恐慌`的继续传播

##### 数据结构

```go
type _panic struct {
    argp      unsafe.Pointer // 指向`defer`调用时参数的指针
    arg       interface{} // 调用`panic`时传入的参数
    link      *_panic // 指向更早调用的`_panic`结构
    recovered bool // 当前的`_panic`是否被`recover` 恢复
    aborted   bool // 表示当前的`panic`是否被强行终止
}
Copy
```

1. 获取当前`panic`调用所在的Goroutine协程
2. 创建并初始化一个 `_panic`结构体
3. 从当前Goroutine的链表获取一个`_defer`结构体
4. 如果当前的`_defer`存在,调用`reflectcall`执行`_defer`中的代码
5. 将下一位的`_defer`结构设置到Goroutine上并返回到3
6. 调用`fatalpanic`中止整个程序(会在中止整个程序之前可能会通过`printpanics`打印出全部的`panic`消息以及调用时传入的参数)

##### panic和recover总结

- 编译过程中会将`panic`和`recover` 分别转换成`gopanic` 和`gorecover`函数,同时将`defer`转换成`deferproc` 函数并在调用`defer`的函数和方法末尾增加`deferreturn`的指令

- 在运行过程中遇到`gopanic`方法时,会从当前Goroutine中取出`_defer`的链表并通过`reflectcall`调用用于收尾的函数

- 如果在

  ```go
  reflectcall
  ```

  调用时遇到了

  ```go
  gorecover
  ```

  就会直接将当前的

   

  ```go
  _panic.recovered
  ```

  标记成

  ```go
  true
  ```

  并返回

  ```go
  panic
  ```

  传入的参数(在这时

  ```go
  recover
  ```

  就能够获取到

  ```go
  panic
  ```

  的信息)

  - 在这次调用结束后,`gopanic`会从`_defer`结构体中取出程序计数器`pc`和栈指针`sp`并调用`recovery`方法进行恢复
  - `recovery`会根据传入的`pc`和`sp`跳转到`deferproc`函数
  - 编译器自动生成的代码会发现`deferproc`的返回值不为`0`,这时就会直接跳到`deferreturn`函数中并恢复到正常的控制流程(依次执行剩余的`defer`并正常退出)

- 如果没有遇到`gorecover`就会一次遍历所有的`_defer`结构,并在最后调用`fatalpanic`中止程序,打印`panic`参数并返回错误码`2`





# Interview 问题

java线程池与go携程池的区别
map与sync.map底层
sync.map高并发怎样
有没有改进它的思路
代码:根据输入的文件名称，打印出文件树状结构。
如何设计一个高并发的系统 



clickhouse 原理  sql注意啥
微服务数据一致性


二维码扫描实现


mutux, rxmutux区别 

https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/

一个表超大数据，分页查询怎么才能尽可能的快，如何优化大分页查询？

慢sql的排查与优化以及解决思路

1. 1. 混合写屏障
   2. java的垃圾回收机制

   简单谈一下java与go，优缺点

1. 1. go协程和java线程的不同


1. 1. GMP

1. 1. 1. 简单讲解一下
      2. 本地队列的数量多少个
      3. golang是否支持抢占式调度？

1. 1. 1. 1. 哪几种场景会进行抢占式调度？

1. 1. 1. 1. 1. 怎么保持cpu一直不被协程占用的呢，满足什么条件会退出呢？通过什么方式来进行切换的？

1. 1. 1.  g0线程(协程)和m0线程一般都担当什么职责？

1. 1. 怎么保持全部协程执行完毕，主协程再退出？
   2. make和new的区别？
   3. 进程、线程、协程之间的区别？

1. 1. 1. 为什么线程的上下文切换比进程快很多？
      2. 线程的资源分配到哪里？
      3. 线程的资源是每个线程独享的吗、还是共享的？

1. 1. GMP中本地队列有256个，一个G绑定一个P的时候，跟它的M不是配对的嘛？当他们都绑定之后，在本地最多可以执行多少个g？可以说在p中最多可以存储多少个g来执行？一个p中最多可以存储多少个g？肯定是高于256个，至于多几个，多在什么地方知道吗？本地存储到多少个队列的时候会全局队列里放？
   2. 当我在执行本地队列里的goroutine的时候，比如说本地队列的256是满的，这个时候我去输出我执行的goroutine，他是全部从本地队列去拿还是会夹杂着全局队列？（限定一下，当我在执行的时候，把goMaxProxy限定为1，打300个goroutine进去，输出的时候会输出到全局队列吗？前256会有全局队列吗）
   3. GC

1. 1. 1. 说一下GC
      2. JAVA的GC用的什么算法 
      3. GC在哪几种场景下会触发？

1. java

1. 1. aio、bio、nio的区别？https://blog.csdn.net/meism5/article/details/89469101
   2. 阻塞、非阻塞？
   3. 同步、异步？

1. go和java对比

1. 1. go struct和java 类有什么不一样的？
   2. 一个struct想要复用另外一个struct的成员的话怎么做？
   3.  java里面实现接口和go实现接口有啥区别？



1. 1. **进程和线程的区别？**

1. 1. 1. 调度：进程是资源管理的基本单位，线程是程序执行的基本单位。

并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行
切换：线程上下文切换比进程上下文切换要快得多。
拥有资源： 进程是拥有资源的一个独立单位，线程不拥有系统资源，但是可以访问隶属于进程的资源。
系统开销： 创建或撤销进程时，系统都要为之分配或回收系统资源，如内存空间，I/O设备等，OS所付出的开销显著大于在创建或撤销线程时的开销，进程切换的开销也远大于线程切换的开销。

1. 1. **go里边的协程？**

1. 1. 1. 进程：是应用程序的启动实例，每个进程都有独立的内存空间，不同的进程通过进程间的通信方式来通信。

线程：从属于进程，每个进程至少包含一个线程，线程是 CPU 调度的基本单位，多个线程之间可以共享进程的资源并通过共享内存等线程间的通信方式来通信。

协程：为轻量级线程，与线程相比，协程不受操作系统的调度，协程的调度器由用户应用程序提供，协程调度器按照调度策略把协程调度到线程中运行

1. 1. **编译的几个环节？**
1）先要识别出句子中的一个个单词；

（2）分析句子的语法结构；

（3）根据句子的含义进行初步翻译；

（4）对译文进行修饰；

（5）写出最后的译文。


计数器

```go
package statistics

import (
	"sync"
)

var GpsClient = new(dataMap)

var CanClient = new(dataMap)

type statistic interface {
	IncSuccess() uint64
	IncError() uint64
	GetSuccess() uint64
	GetError() uint64
	GetCount() uint64
}

type dataMap struct {
	dataType string
	success  uint64
	error    uint64
	sync.Mutex
}

func (d *dataMap) IncSuccess() uint64 {
	d.Lock()
	defer d.Unlock()
	d.success ++
	return d.success
}

func (d *dataMap) IncError() uint64 {
	d.Lock()
	defer d.Unlock()
	d.error ++
	return d.error
}

func (d *dataMap) GetSuccess() uint64 {
	d.Lock()
	defer d.Unlock()
	return d.success
}

func (d *dataMap) GetError() uint64 {
	d.Lock()
	defer d.Unlock()
	return d.error
}

func (d *dataMap) GetCount() uint64 {
	d.Lock()
	defer d.Unlock()
	count := d.success + d.error
	return count
}
```

```go
/**
	功能：实现一个计数器模块，不依赖外部三方模块和存储，
	要求进程内协程安全、异步、高性能按指标 key-value 统计。
 */
package main

import (
	"fmt"
	"time"
	"./statistics"
)

func main(){
	go Task()

	for {
		func() {
			fmt.Printf("can: success = %d \n",statistics.CanClient.IncSuccess())
			fmt.Printf("can: error = %d \n",statistics.CanClient.IncError())
		}()

		time.Sleep(time.Second)
		fmt.Printf("can: error = %d \n",statistics.CanClient.GetError())
		fmt.Printf("can: count = %d \n",statistics.CanClient.GetCount())
	}

}

func Task() {
	for {
		func() {
			fmt.Printf("gps:success = %d\n", statistics.GpsClient.IncSuccess())
		}()
		time.Sleep(time.Second)
		fmt.Printf("gps count = %d \n", statistics.GpsClient.GetCount())
	}
}
```

限流策略：令牌桶，漏桶



## 零、go与其他语言

### 0、什么是[面向对象](https://so.csdn.net/so/search?q=面向对象&spm=1001.2101.3001.7020)

在了解 Go 语言是不是面向对象（简称：OOP） 之前，我们必须先知道 OOP 是啥，得先给他 “下定义”

根据 Wikipedia 的定义，我们梳理出 OOP 的几个基本认知：

- 面向对象编程（OOP）是一种基于 “对象” 概念的编程范式，它可以包含数据和代码：数据以字段的形式存在（通常称为属性或属性），代码以程序的形式存在（通常称为方法）。
- 对象自己的程序可以访问并经常修改自己的数据字段。
- 对象经常被定义为类的一个实例。
- 对象利用属性和方法的私有/受保护/公共可见性，对象的内部状态受到保护，不受外界影响（被封装）。

基于这几个基本认知进行一步延伸出，面向对象的三大基本特性：

- 封装
- 继承
- 多态

### 1、Go语言和Java有什么区别? 

1、Go上不允许函数重载，必须具有方法和函数的唯一名称，而Java允许函数重载。

2、在速度方面，Go的速度要比Java快。

3、Java默认允许多态，而Go没有。

4、Go语言使用HTTP协议进行路由配置，而Java使用Akka.routing.ConsistentHashingRouter和Akka.routing.ScatterGatherFirstCompletedRouter进行路由配置。

5、Go代码可以自动扩展到多个核心，而Java并不总是具有足够的可扩展性。

6、Go语言的继承通过匿名组合完成，基类以Struct的方式定义，子类只需要把基类作为成员放在子类的定义中，支持多继承;而Java的继承通过extends关键字完成，不支持多继承。

### 2、Go 是面向对象的语言吗？

是的，也不是。原因是：

1. Go 有类型和方法，并且允许面向对象的编程风格，但没有类型层次。
2. Go 中的 "接口 "概念提供了一种不同的方法，我们认为这种方法易于使用，而且在某些方面更加通用。还有一些方法可以将类型嵌入到其他类型中，以提供类似的东西，但不等同于子类。
3. Go 中的方法比 C++ 或 Java 中的方法更通用：它们可以为任何类型的数据定义，甚至是内置类型，如普通的、"未装箱的 "整数。它们并不局限于结构（类）。
4. Go 由于缺乏类型层次，Go 中的 "对象 "比 C++ 或 Java 等语言更轻巧。

### 3、Go 实现面向对象编程

#### 封装

面向对象中的 “封装” 指的是可以隐藏对象的内部属性和实现细节，仅对外提供公开接口调用，这样子用户就不需要关注你内部是怎么实现的。

**在 Go 语言中的属性访问权限，通过首字母大小写来控制：**

- 首字母大写，代表是公共的、可被外部访问的。
- 首字母小写，代表是私有的，不可以被外部访问。

Go 语言的例子如下：

```go
type Animal struct {
	name string
}

func NewAnimal() *Animal {
 	return &Animal{}
}

func (p *Animal) SetName(name string) {
 	p.name = name
}

func (p *Animal) GetName() string {
 	return p.name
}
```



在上述例子中，我们声明了一个结构体 Animal，其属性 name 为小写。没法通过外部方法，在配套上存在 Setter 和 Getter 的方法，用于统一的访问和设置控制。

以此实现在 Go 语言中的基本封装。

#### 继承

面向对象中的 “继承” 指的是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1661876060993-91ac09c4-3a79-4b38-a09e-6450552a3bfe.png)

从实际的例子来看，就是动物是一个大父类，下面又能细分为 “食草动物”、“食肉动物”，这两者会包含 “动物” 这个父类的基本定义。

从实际的例子来看，就是动物是一个大父类，下面又能细分为 “食草动物”、“食肉动物”，这两者会包含 “动物” 这个父类的基本定义。

**在 Go 语言中，是没有类似** **extends** **关键字的这种继承的方式，在语言设计上采取的是组合的方式**：

```go
type Animal struct {
 	Name string
}

type Cat struct {
 	Animal
 	FeatureA string
}

type Dog struct {
 	Animal
 	FeatureB string
}
```

在上述例子中，我们声明了 Cat 和 Dog 结构体，其在内部匿名组合了 Animal 结构体。因此 Cat 和 Dog 的实例都可以调用 Animal 结构体的方法：

```go
func main() {
 	p := NewAnimal()
 	p.SetName("我是搬运工，去给煎鱼点赞~")

 	dog := Dog{Animal: *p}
 	fmt.Println(dog.GetName())
}
```

同时 Cat 和 Dog 的实例可以拥有自己的方法：

```go
func (dog *Dog) HelloWorld() {
 	fmt.Println("脑子进煎鱼了")
}

func (cat *Cat) HelloWorld() {
 	fmt.Println("煎鱼进脑子了")
}
```

上述例子能够正常包含调用 Animal 的相关属性和方法，也能够拥有自己的独立属性和方法，在 Go 语言中达到了类似继承的效果。

#### 多态

多态

面向对象中的 “多态” 指的同一个行为具有多种不同表现形式或形态的能力，具体是指一个类实例（对象）的相同方法在不同情形有不同表现形式。

多态也使得不同内部结构的对象可以共享相同的外部接口，也就是都是一套外部模板，内部实际是什么，只要符合规格就可以。

**在 Go 语言中，多态是通过接口来实现的：**

```go
type AnimalSounder interface {
 	MakeDNA()
}

func MakeSomeDNA(animalSounder AnimalSounder) {		// 参数是AnimalSounder接口类型
 	animalSounder.MakeDNA()
}
```

在上述例子中，我们声明了一个接口类型 AnimalSounder，配套一个 MakeSomeDNA 方法，其接受 AnimalSounder 接口类型作为入参。

因此在 Go 语言中。只要配套的 Cat 和 Dog 的实例也实现了 MakeSomeDNA 方法，那么我们就可以认为他是 AnimalSounder 接口类型：

```go
type AnimalSounder interface {
 	MakeDNA()
}

func MakeSomeDNA(animalSounder AnimalSounder) {
 	animalSounder.MakeDNA()
}

func (c *Cat) MakeDNA() {
 	fmt.Println("煎鱼是煎鱼")
}

func (c *Dog) MakeDNA() {
 	fmt.Println("煎鱼其实不是煎鱼")
}

func main() {
 	MakeSomeDNA(&Cat{})
 	MakeSomeDNA(&Dog{})
}
```

当 Cat 和 Dog 的实例实现了 AnimalSounder 接口类型的约束后，就意味着满足了条件，他们在 Go 语言中就是一个东西。能够作为入参传入 MakeSomeDNA 方法中，再根据不同的实例实现多态行为。

------

在日常工作中，基本了解这些概念就可以了。若是面试，可以针对三大特性：“封装、继承、多态” 和 五大原则 “单一职责原则（SRP）、开放封闭原则（OCP）、里氏替换原则（LSP）、依赖倒置原则（DIP）、接口隔离原则（ISP）” 进行深入理解和说明。

## **一、基础部分**

### 0、为什么选择golang

**0、高性能-协程**
golang 源码级别支持协程，实现简单；对比进程和线程，协程占用资源少，能够简洁高效地处理高并发问题。

**1、学习曲线容易-****代码极简**

Go语言语法简单，包含了类C语法。因为Go语言容易学习，所以一个普通的大学生花几个星期就能写出来可以上手的、高性能的应用。在国内大家都追求快，这也是为什么国内Go流行的原因之一。

Go 语言的语法特性简直是太简单了，简单到你几乎玩不出什么花招，直来直去的，学习曲线很低，上手非常快。

**2、效率：快速的编译时间，开发效率和运行效率高**

开发过程中相较于 Java 和 C++呆滞的编译速度，Go 的快速编译时间是一个主要的效率优势。Go拥有接近C的运行效率和接近PHP的开发效率。

C 语言的理念是信任程序员，保持语言的小巧，不屏蔽底层且底层友好，关注语言的执行效率和性能。而 Python 的姿态是用尽量少的代码完成尽量多的事。于是我能够感觉到，Go 语言想要把 C 和 Python 统一起来，这是多棒的一件事啊。

**3、出身名门、血统纯正**

之所以说Go出身名门，从Go语言的创造者就可见端倪，Go语言绝对血统纯正。其次Go语言出自Google公司，Google在业界的知名度和实力自然不用多说。Google公司聚集了一批牛人，在各种编程语言称雄争霸的局面下推出新的编程语言，自然有它的战略考虑。而且从Go语言的发展态势来看，Google对它这个新的宠儿还是很看重的，Go自然有一个良好的发展前途。

**4、自由高效：组合的思想、无侵入式的接口**

Go语言可以说是开发效率和运行效率二者的完美融合，天生的并发编程支持。Go语言支持当前所有的编程范式，包括过程式编程、面向对象编程、面向接口编程、函数式编程。程序员们可以各取所需、自由组合、想怎么玩就怎么玩。

**5、强大的标准库-****生态**

背靠谷歌，生态丰富，轻松 go get 获取各种高质量轮子。用户可以专注于业务逻辑，避免重复造轮子。

这包括互联网应用、系统编程和网络编程。Go里面的标准库基本上已经是非常稳定了，特别是我这里提到的三个，网络层、系统层的库非常实用。Go 语言的 lib 库麻雀虽小五脏俱全。Go 语言的 lib 库中基本上有绝大多数常用的库，虽然有些库还不是很好，但我觉得不是问题，因为我相信在未来的发展中会把这些问题解决掉。

**6、部署方便：二进制文件，Copy部署**

部署简单，源码编译成执行文件后，可以直接运行，减少了对其它插件依赖。不像其它语言，执行文件依赖各种插件，各种库，研发机器运行正常，部署到生产环境，死活跑不起来 。

**7、简单的并发**

并行和异步编程几乎无痛点。Go 语言的 Goroutine 和 Channel 这两个神器简直就是并发和异步编程的巨大福音。像 C、C++、Java、Python 和 JavaScript 这些语言的并发和异步方式太控制就比较复杂了，而且容易出错，而 Go 解决这个问题非常地优雅和流畅。这对于编程多年受尽并发和异步折磨的编程者来说，完全就是让人眼前一亮的感觉。Go 是一种非常高效的语言，高度支持并发性。Go是为大数据、微服务、并发而生的一种编程语言。

Go 作为一门语言致力于使事情简单化。它并未引入很多新概念，而是聚焦于打造一门简单的语言，它使用起来异常快速并且简单。其唯一的创新之处是 goroutines 和通道。Goroutines 是 Go 面向线程的轻量级方法，而通道是 goroutines 之间通信的优先方式。

创建 Goroutines 的成本很低，只需几千个字节的额外内存，正由于此，才使得同时运行数百个甚至数千个 goroutines 成为可能。可以借助通道实现 goroutines 之间的通信。Goroutines 以及基于通道的并发性方法使其非常容易使用所有可用的 CPU 内核，并处理并发的 IO。相较于 Python/Java，在一个 goroutine 上运行一个函数需要最小的代码。

**8、稳定性**

Go拥有强大的编译检查、严格的编码规范和完整的软件生命周期工具，具有很强的稳定性，稳定压倒一切。那么为什么Go相比于其他程序会更稳定呢？这是因为Go提供了软件生命周期（开发、测试、部署、维护等等）的各个环节的工具，如go tool、gofmt、go test。

**9、跨平台**
很多语言都支持跨平台，把这个优点单独拿出来，貌似没有什么值得称道的，但是结合上述优点，它的综合能力就非常强了。

### golang 缺点

**①右大括号不允许换行，否则编译报错**

**②不允许有未使用的包或变量**

**③错误处理原始，虽然引入了defer、panic、recover处理出错后的逻辑，函数可以返回多个值，但基本依靠返回错误是否为空来判断函数是否执行成功，if err != nil语句较多，比较繁琐，程序没有java美观。**(官方解释：提供了多个返回值，处理错误方便，如加入异常机制会要求记住一些常见异常，例如IOException，go的错误Error类型较统一方便)
**④[]interface{}不支持下标操作**

**⑤struct没有构造和析构，一些资源申请和释放动作不太方便**

**⑥仍然保留C/C++的指针操作，取地址&，取值\***


### **6、能介绍下 rune 类型吗？**

相当int32

golang中的字符串底层实现是通过byte数组的，中文字符在unicode下占2个字节，在utf-8编码下占3个字节，而golang默认编码正好是utf-8

byte 等同于int8，常用来处理ascii字符

rune 等同于int32,常用来处理unicode或utf-8字符

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1659259378747-48538a44-1ccb-47ac-9492-0b569d219e2b.png)

### **7、 golang 中解析 tag 是怎么实现的？反射原理是什么？(中高级肯定会问，比较难，需要自己多去总结)**

**参考如下连接**

[golang中struct关于反射tag_paladinosment的博客-CSDN博客_golang 反射tagblog.csdn.net/paladinosment/article/details/42570937](https://link.zhihu.com/?target=https%3A//blog.csdn.net/paladinosment/article/details/42570937)

type User struct { 	name string `json:name-field` 	age  int } func main() { 	user := &User{"John Doe The Fourth", 20} 	field, ok := reflect.TypeOf(user).Elem().FieldByName("name") 	if !ok { 		panic("Field not found") 	} 	fmt.Println(getStructTag(field)) } func getStructTag(f reflect.StructField) string { 	return string(f.Tag) }

Go 中解析的 tag 是通过反射实现的，反射是指计算机程序在运行时（Run time）可以访问、检测和修改它本身状态或行为的一种能力或动态知道给定数据对象的类型和结构，并有机会修改它。反射将接口变量转换成反射对象 Type 和 Value；反射可以通过反射对象 Value 还原成原先的接口变量；反射可以用来修改一个变量的值，前提是这个值可以被修改；tag是啥:结构体支持标记，name string `json:name-field` 就是 `json:name-field` 这部分

**gorm json yaml gRPC protobuf gin.Bind()都是通过反射来实现的**

### **8、调用函数传入结构体时，应该传值还是指针？ （Golang 都是传值）**

Go 的函数参数传递都是值传递。所谓值传递：指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。参数传递还有引用传递，所谓引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数

因为 Go 里面的 map，slice，chan 是引用类型。变量区分值类型和引用类型。所谓值类型：变量和变量的值存在同一个位置。所谓引用类型：变量和变量的值是不同的位置，变量的值存储的是对值的引用。但并不是 map，slice，chan 的所有的变量在函数内都能被修改，不同数据类型的底层存储结构和实现可能不太一样，情况也就不一样。

### 9、goroutine什么情况下会阻塞

在 Go 里面阻塞主要分为以下 4 种场景：

1. 由于原子、互斥量或通道操作调用导致 Goroutine 阻塞，调度器将把当前阻塞的 Goroutine 切换出去，重新调度 LRQ 上的其他 Goroutine；
2. 由于网络请求和 IO 操作导致 Goroutine 阻塞。Go 程序提供了网络轮询器（NetPoller）来处理网络请求和 IO 操作的问题，其后台通过 kqueue（MacOS），epoll（Linux）或 iocp（Windows）来实现 IO 多路复用。通过**使用 NetPoller 进行网络系统调用**，调度器可以防止 Goroutine 在进行这些系统调用时阻塞 M。这可以让 M 执行 P 的 LRQ 中其他的 Goroutines，而不需要创建新的 M。执行网络系统调用不需要额外的 M，**网络轮询器使用系统线程**，它时刻处理一个有效的事件循环，有助于减少操作系统上的调度负载。用户层眼中看到的 Goroutine 中的“block socket”，实现了 goroutine-per-connection 简单的网络编程模式。实际上是通过 Go runtime 中的 netpoller 通过 Non-block socket + I/O 多路复用机制“模拟”出来的。
3. 当调用一些系统方法的时候（如文件 I/O），如果系统方法调用的时候发生阻塞，这种情况下，网络轮询器（NetPoller）无法使用，而进行系统调用的 G1 将阻塞当前 M1。调度器引入 其它M 来服务 M1 的P。
4. 如果在 Goroutine 去执行一个 sleep 操作，导致 M 被阻塞了。Go 程序后台有一个监控线程 sysmon，它监控那些长时间运行的 G 任务然后设置可以强占的标识符，别的 Goroutine 就可以抢先进来执行。



### **11、讲讲 Go 的 defer 底层数据结构和一些特性？**

答：每个 defer 语句都对应一个_defer 实例，多个实例使用指针连接起来形成一个单连表，保存在 gotoutine 数据结构中，每次插入_defer 实例，均插入到链表的头部，函数结束再一次从头部取出，从而形成后进先出的效果。

**defer 的规则总结**：

延迟函数的参数是 defer 语句出现的时候就已经确定了的。

延迟函数执行按照后进先出的顺序执行，即先出现的 defer 最后执行。

延迟函数可能操作主函数的返回值。

申请资源后立即使用 defer 关闭资源是个好习惯。


### 13、go出现panic的场景

### https://www.cnblogs.com/paulwhw/p/15585467.html

- - 数组/切片越界
  - 空指针调用。比如访问一个 nil 结构体指针的成员
  - 过早关闭 HTTP 响应体
  - 除以 0
  - 向已经关闭的 channel 发送消息
  - 重复关闭 channel
  - 关闭未初始化的 channel
  - 未初始化 map。注意访问 map 不存在的 key 不会 panic，而是返回 map 类型对应的零值，但是不能直接赋值
  - 跨协程的 panic 处理
  - sync 计数为负数。
  - 类型断言不匹配。`var a interface{} = 1; fmt.Println(a.(string))` 会 panic，建议用 `s,ok := a.(string)`


### 16、go如何实现类似于java当中的继承机制？

https://zhuanlan.zhihu.com/p/88480107

说到继承我们都知道，在Go中没有extends关键字，也就意味着Go并没有原生级别的继承支持。这也是为什么我在文章开头用了**伪继承**这个词。本质上，Go使用interface实现的功能叫组合，Go是使用组合来实现的继承，说的更精确一点，是使用组合来代替的继承，举个很简单的例子:

**通过组合实现了继承：**

```go
type Animal struct {
    Name string
}

func (a *Animal) Eat() {
    fmt.Printf("%v is eating", a.Name)
    fmt.Println()
}

type Cat struct {
    *Animal
}

cat := &Cat{
    Animal: &Animal{
        Name: "cat",
    },
}
cat.Eat() // cat is eating
```

首先，我们实现了一个Animal的结构体，代表动物类。并声明了Name字段，用于描述动物的名字。

然后，实现了一个以Animal为receiver的Eat方法，来描述动物进食的行为。

最后，声明了一个Cat结构体，组合了Cat字段。再实例化一个猫，调用Eat方法，可以看到会正常的输出。

可以看到，Cat结构体本身没有Name字段，也没有去实现Eat方法。唯一有的就是组合了Animal父类，至此，我们就证明了已经通过组合实现了继承。

**总结：**

- 如果一个 struct 嵌套了另一个匿名结构体，那么这个结构可以直接访问匿名结构体的属性和方法，从而实现继承。
- 如果一个 struct 嵌套了另一个有名的结构体，那么这个模式叫做组合。
- 如果一个 struct 嵌套了多个匿名结构体，那么这个结构可以直接访问多个匿名结构体的属性和方法，从而实现多重继承。

### 17、怎么去复用一个接口的方法？

https://www.yisu.com/zixun/452409.html

### 18、go里面的 _ 

1. **忽略返回值**

1. 1. 比如某个函数返回三个参数，但是我们只需要其中的两个，另外一个参数可以忽略，这样的话代码可以这样写：

```go
v1, v2, _ := function(...)
v1, _, _ := function(...)
```

1. **用在变量(特别是接口断言)**

```go
type T struct{}
var _ X = T{}
//其中 I为interface
```

上面用来判断 type T是否实现了X,用作类型断言，如果T没有实现接口X，则编译错误.

1. **用在import package**

```go
import _ "test/food"
```

引入包时，会先调用包中的初始化函数，这种使用方式仅让导入的包做初始化，而不使用包中其他功能

### 19、goroutine创建的时候如果要传一个参数进去有什么要注意的点？

https://www.cnblogs.com/waken-captain/p/10496454.html

### 20、写go单元测试的规范？

1.  **单元测试文件命名规则 ：**

单元测试需要创建单独的测试文件，不能在原有文件中书写，名字规则为 xxx_test.go。这个规则很好理解。

1.  **单元测试包命令规则** 

单元测试文件的包名为原文件的包名添加下划线接test，举例如下：

```go
// 原文件包名：

package xxx

// 单元测试文件包名：

package xxx_test
```

1.  **单元测试方法命名规则** 

单元测试文件中的测试方法和原文件中的待测试的方法名相对应，以Test开头，举例如下：

```go
// 原文件方法：
func Xxx(name string) error 
 
// 单元测试文件方法：
func TestXxx()
```

1.  **单元测试方法参数** 

单元测试方法的参数必须是t *testing.T，举例如下：

```go
func TestZipFiles(t *testing.T) { ...
```

### 21、单步调试？

https://www.jianshu.com/p/21ed30859d80

### 22、导入一个go的工程，有些依赖找不到，改怎么办？

https://www.cnblogs.com/niuben/p/16182001.html

### 23、[值拷贝 与 引用拷贝，深拷贝 与 浅拷贝](https://www.cnblogs.com/yizhixiaowenzi/p/14664222.html)

map，slice，chan 是引用拷贝；引用拷贝 是 浅拷贝

其余的，都是 值拷贝；值拷贝 是 深拷贝

#### 深浅拷贝的本质区别：

是否真正获取对象实体，而不是引用

**深拷贝：**

拷贝的是数据本身，创造一个新的对象，并在内存中开辟一个新的内存地址，与原对象是完全独立的，不共享内存，修改新对象时不会影响原对象的值。释放内存时，也没有任何关联。

**值拷贝：**

接收的是  整个array的值拷贝，所以方法对array中元素的重新赋值不起作用。

```go
package main  

import "fmt"  

func modify(a [3]int) {  
    a[0] = 4  
    fmt.Println("modify",a)             // modify [4 2 3]
}  

func main() {  
    a := [3]int{1, 2, 3}  
    modify(a)  
    fmt.Println("main",a)                  // main [1 2 3]
}  
```

**浅拷贝：**

拷贝的是数据地址，只复制指向的对象的指针，新旧对象的内存地址是一样的，修改一个另一个也会变。释放内存时，同时释放。

**引用拷贝：**

函数的引用拷贝与原始的引用指向同一个数组，所以对数组中元素的修改，是有效的

```go
package main  
  
import "fmt"  
  
func modify(s []int) {  
    s[0] = 4  
    fmt.Println("modify",s)          // modify [4 2 3]
}  
  
func main() {  
    s := []int{1, 2, 3}  
    modify(s)  
    fmt.Println("main",s)              // main [4 2 3]
}
```

### 24、[精通Golang项目依赖Go modules](https://www.topgoer.cn/docs/golangxiuyang/golangxiuyang-1cmee13oek1e8)

### 25、Go 多返回值怎么实现的？

答：Go 传参和返回值是通过 FP+offset 实现，并且存储在调用函数的栈帧中。FP 栈底寄存器，指向一个函数栈的顶部;PC 程序计数器，指向下一条执行指令;SB 指向静态数据的基指针，全局符号;SP 栈顶寄存器。

### 26、Go 语言中不同的类型如何比较是否相等？

答：像 string，int，float interface 等可以通过 reflect.DeepEqual 和等于号进行比较，像 slice，struct，map 则一般使用 reflect.DeepEqual 来检测是否相等。

### 27、Go中init 函数的特征?

答：一个包下可以有多个 init 函数，每个文件也可以有多个 init 函数。多个 init 函数按照它们的文件名顺序逐个初始化。应用初始化时初始化工作的顺序是，从被导入的最深层包开始进行初始化，层层递出最后到 main 包。不管包被导入多少次，包内的 init 函数只会执行一次。但包级别变量的初始化先于包内 init 函数的执行。

### 28、

## 二、slice

### **2、**[**讲讲 Go 的 slice 底层数据结构和一些特性？**](https://www.topgoer.cn/docs/gozhuanjia/gozhuanjiaslice)

答：Go 的 slice 底层数据结构是由一个 array 指针指向底层数组，len 表示切片长度，cap 表示切片容量。slice 的主要实现是扩容。对于 append 向 slice 添加元素时，假如 slice 容量够用，则追加新元素进去，slice.len++，返回原来的 slice。当原容量不够，则 slice 先扩容，扩容之后 slice 得到新的 slice，将元素追加进新的 slice，slice.len++，返回新的 slice。对于切片的扩容规则：当切片比较小时（容量小于 1024），则采用较大的扩容倍速进行扩容（新的扩容会是原来的 2 倍），避免频繁扩容，从而减少内存分配的次数和数据拷贝的代价。当切片较大的时（原来的 slice 的容量大于或者等于 1024），采用较小的扩容倍速（新的扩容将扩大大于或者等于原来 1.25 倍），主要避免空间浪费，网上其实很多总结的是 1.25 倍，那是在不考虑内存对齐的情况下，实际上还要考虑内存对齐，扩容是大于或者等于 1.25 倍。

（关于刚才问的 slice 为什么传到函数内可能被修改，如果 slice 在函数内没有出现扩容，函数外和函数内 slice 变量指向是同一个数组，则函数内复制的 slice 变量值出现更改，函数外这个 slice 变量值也会被修改。如果 slice 在函数内出现扩容，则函数内变量的值会新生成一个数组（也就是新的 slice，而函数外的 slice 指向的还是原来的 slice，则函数内的修改不会影响函数外的 slice。）

### 3、golang中数组和slice作为参数的区别？slice作为参数传递有什么问题？

https://blog.csdn.net/weixin_44387482/article/details/119763558

1. 当使用数组作为参数和返回值的时候，传进去的是值，在函数内部对数组进行修改并不会影响原数据
2. 当切片作为参数的时候穿进去的是值，也就是值传递，但是当我在函数里面修改切片的时候，我们发现源数据也会被修改，这是因为我们在切片的底层维护这一个匿名的数组，当我们把切片当成参数的时候，会重现创建一个切片，但是创建的这个切片和我们原来的数据是共享数据源的，所以在函数内被修改，源数据也会被修改
3. 数组还是切片，在函数中传递的时候如果没有指定为指针传递的话，都是值传递，但是切片在传递的过程中，有着共享底层数组的风险，所以如果在函数内部进行了更改的时候，会修改到源数据，所以我们需要根据不同的需求来处理，如果我们不希望源数据被修改话的我们可以使用copy函数复制切片后再传入，如果希望源数据被修改的话我们应该使用指针传递的方式

### 4、从数组中取一个相同大小的slice有成本吗？

或者这么问：从切片中取一个相同大小的数组有成本吗？

从数组中截取切片：https://blog.csdn.net/weixin_42117918/article/details/81913036



## **三、map相关**

### 3、 map 中删除一个 key，它的内存会释放么？（常问）

如果删除的元素是值类型，如int，float，bool，string以及数组和struct，map的内存不会自动释放

如果删除的元素是引用类型，如指针，slice，map，chan等，map的内存会自动释放，但释放的内存是子元素应用类型的内存占用

将map设置为nil后，内存被回收。

**这个问题还需要大家去搜索下答案，我记得有不一样的说法，谨慎采用本题答案。**


### 6、map 的数据结构是什么？

https://www.topgoer.cn/docs/gozhuanjia/gozhuanjiamap

答：golang 中 map 是一个 kv 对集合。底层使用 hash table，用链表来解决冲突 ，出现冲突时，不是每一个 key 都申请一个结构通过链表串起来，而是以 bmap 为最小粒度挂载，一个 bmap 可以放 8 个 kv。在哈希函数的选择上，会在程序启动时，检测 cpu 是否支持 aes，如果支持，则使用 aes hash，否则使用 memhash。每个 map 的底层结构是 hmap，是有若干个结构为 bmap 的 bucket 组成的数组。每个 bucket 底层都采用链表结构。


**下图展示一个拥有4个bucket的map：**

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1661789793109-401b7c75-c26b-4893-bbf7-1f2dfa69316b.png)

本例中, hmap.B=2， 而hmap.buckets长度是2^B为4. 元素经过哈希运算后会落到某个bucket中进行存储。查找过程类似。

bucket很多时候被翻译为桶，所谓的哈希桶实际上就是bucket。


这里只有一个 tophash 字段，而实际上在使用中值的类型是不固定的，甚至可以是一个自定义结构体的指针类型。这个结构体看起来可能有点让人费解，其实编译器在编译期间会动态创建一个新的同名数据结构，如下所示

```go
type bmap struct {
    topbits  [8]uint8
    keys     [8]keytype
    values   [8]valuetype
    pad      uintptr
    overflow uintptr
}
```

bmap 即 bucket map 的缩写。

每个bucket可以存储8个键值对。

- topbits 是个长度为8的数组，哈希值相同的键（准确的说是哈希值低位相同的键）存入当前bucket时会将哈希值的高位存储在该数组中，以方便后续匹配。
- keys 长度为8的数组，[]keytype，元素为：具体的key值。
- values 长度为8的数组，[]valuetype，元素为：键值对的key对应的值。
- pad 对齐内存使用的，不是每个bmap都有会这个字段，需要满足一定条件
- overflow 指针指向的是下一个bucket，据此将所有冲突的键连接起来。

下图展示bucket存放8个key-value对：

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1661789834784-c60b0cb4-96be-4c4c-8978-2bfc9ca716b9.png)

#### [解决哈希冲突（四种方法）](https://blog.csdn.net/qq_48241564/article/details/118613312)

#### 哈希冲突

当有两个或以上数量的键被哈希到了同一个bucket时，我们称这些键发生了冲突。Go使用链地址法来解决键冲突。
由于每个bucket可以存放8个键值对，所以同一个bucket存放超过8个键值对时就会再创建一个键值对，用类似链表的方式将bucket连接起来。

下图展示产生冲突后的map：

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1661789900886-a77838be-46c8-4254-999b-b6e217721fbf.png)

bucket数据结构指示下一个bucket的指针称为overflow bucket，意为当前bucket盛不下而溢出的部分。事实上哈希冲突并不是好事情，它降低了存取效率，好的哈希算法可以保证哈希值的随机性，但冲突过多也是要控制的，后面会再详细介绍。

#### 负载因子

负载因子用于衡量一个哈希表冲突情况，公式为：

负载因子 = 键数量/bucket数量

例如，对于一个bucket数量为4，包含4个键值对的哈希表来说，这个哈希表的负载因子为1.

哈希表需要将负载因子控制在合适的大小，超过其阀值需要进行rehash，也即键值对重新组织：

- 哈希因子过小，说明空间利用率低
- 哈希因子过大，说明冲突严重，存取效率低

每个哈希表的实现对负载因子容忍程度不同，比如Redis实现中负载因子大于1时就会触发rehash，而Go则在在负载因子达到6.5时才会触发rehash，因为Redis的每个bucket只能存1个键值对，而Go的bucket可能存8个键值对，所以Go可以容忍更高的负载因子。

### 7、是怎么实现扩容？

#### map 的容量大小

底层调用 makemap 函数，计算得到合适的 B，map 容量最多可容纳 6.52^B 个元素，6.5 为装载因子阈值常量。装载因子的计算公式是：装载因子=填入表中的元素个数/散列表的长度，装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。底层调用 makemap 函数，计算得到合适的 B，map 容量最多可容纳 6.52^B 个元素，6.5 为装载因子阈值常量。装载因子的计算公式是：装载因子=填入表中的元素个数/散列表的长度，装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。

#### 触发 map 扩容的条件

为了保证访问效率，当新元素将要添加进map时，都会检查是否需要扩容，扩容实际上是以空间换时间的手段。
触发扩容的条件有二个：

1. 负载因子 > 6.5时，也即平均每个bucket存储的键值对达到6.5个。
2. overflow数量 > 2^15时，也即overflow数量超过32768时。

#### 增量扩容

当负载因子过大时，就新建一个bucket，新的bucket长度是原来的2倍，然后旧bucket数据搬迁到新的bucket。
考虑到如果map存储了数以亿计的key-value，一次性搬迁将会造成比较大的延时，Go采用逐步搬迁策略，即每次访问map时都会触发一次搬迁，每次搬迁2个键值对。

下图展示了包含一个bucket满载的map(为了描述方便，图中bucket省略了value区域):

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1661789723150-6a635c5e-5d5a-4173-972f-ac0fd0326ffe.png)

当前map存储了7个键值对，只有1个bucket。此地负载因子为7。再次插入数据时将会触发扩容操作，扩容之后再将新插入键写入新的bucket。

当第8个键值对插入时，将会触发扩容，扩容后示意图如下：

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1661789723181-66b62c5f-34bb-4427-8c68-446e7e05b4de.png)

hmap数据结构中oldbuckets成员指身原bucket，而buckets指向了新申请的bucket。新的键值对被插入新的bucket中。
后续对map的访问操作会触发迁移，将oldbuckets中的键值对逐步的搬迁过来。当oldbuckets中的键值对全部搬迁完毕后，删除oldbuckets。

搬迁完成后的示意图如下：

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1661789723183-d1c03c9d-b6a9-4dd7-8410-a2674f1f1c0c.png)

数据搬迁过程中原bucket中的键值对将存在于新bucket的前面，新插入的键值对将存在于新bucket的后面。
实际搬迁过程中比较复杂，将在后续源码分析中详细介绍。

#### 等量扩容

所谓等量扩容，实际上并不是扩大容量，buckets数量不变，重新做一遍类似增量扩容的搬迁动作，把松散的键值对重新排列一次，以使bucket的使用率更高，进而保证更快的存取。
在极端场景下，比如不断地增删，而键值对正好集中在一小部分的bucket，这样会造成overflow的bucket数量增多，但负载因子又不高，从而无法执行增量搬迁的情况，如下图所示：

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1661789747828-6f31463b-a48d-4a4d-877b-828f7f6abc9d.png)

上图可见，overflow的bucket中大部分是空的，访问效率会很差。此时进行一次等量扩容，即buckets数量不变，经过重新组织后overflow的bucket数量会减少，即节省了空间又会提高访问效率。

### 8、查找过程

查找过程如下：

1. 根据key值算出哈希值
2. 取哈希值低位与hmap.B取模确定bucket位置
3. 取哈希值高位在tophash数组中查询
4. 如果tophash[i]中存储值也哈希值相等，则去找到该bucket中的key值进行比较
5. 当前bucket没有找到，则继续从下个overflow的bucket中查找。
6. 如果当前处于搬迁过程，则优先从oldbuckets查找

注：如果查找不到，也不会返回空值，而是返回相应类型的0值。

### 9、插入过程

新元素插入过程如下：

1. 根据key值算出哈希值
2. 取哈希值低位与hmap.B取模确定bucket位置
3. 查找该key是否已经存在，如果存在则直接更新值
4. 如果没找到将key，将key插入


## 四、接口

### 1、[Go 语言与鸭子类型的关系](http://golang.design/go-questions/interface/duck-typing/)

总结一下，鸭子类型是一种动态语言的风格，在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由它"当前方法和属性的集合"决定。Go 作为一种静态语言，通过接口实现了 鸭子类型，实际上是 Go 的编译器在其中作了隐匿的转换工作。

### 2、[值接收者和指针接收者的区别](http://golang.design/go-questions/interface/receiver/)

#### 方法

方法能给用户自定义的类型添加新的行为。它和函数的区别在于方法有一个接收者，给一个函数添加一个接收者，那么它就变成了方法。接收者可以是值接收者，也可以是指针接收者。

在调用方法的时候，值类型既可以调用值接收者的方法，也可以调用指针接收者的方法；指针类型既可以调用指针接收者的方法，也可以调用值接收者的方法。

也就是说，不管方法的接收者是什么类型，该类型的值和指针都可以调用，不必严格符合接收者的类型。

实际上，当类型和方法的接收者类型不同时，其实是编译器在背后做了一些工作，用一个表格来呈现：

| **-**          | **值接收者**                                                 | **指针接收者**                                               |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 值类型调用者   | 方法会使用调用者的一个副本，类似于“传值”                     | 使用值的引用来调用方法，上例中，qcrao.growUp() 实际上是 (&qcrao).growUp() |
| 指针类型调用者 | 指针被解引用为值，上例中，stefno.howOld() 实际上是 (*stefno).howOld() | 实际上也是“传值”，方法里的操作会影响到调用者，类似于指针传参，拷贝了一份指针 |

#### 值接收者和指针接收者

前面说过，不管接收者类型是值类型还是指针类型，都可以通过值类型或指针类型调用，这里面实际上通过语法糖起作用的。

先说结论：实现了接收者是值类型的方法，相当于自动实现了接收者是指针类型的方法；而实现了接收者是指针类型的方法，不会自动生成对应接收者是值类型的方法。

所以，当实现了一个接收者是值类型的方法，就可以自动生成一个接收者是对应指针类型的方法，因为两者都不会影响接收者。但是，当实现了一个接收者是指针类型的方法，如果此时自动生成一个接收者是值类型的方法，原本期望对接收者的改变（通过指针实现），现在无法实现，因为值类型会产生一个拷贝，不会真正影响调用者。

最后，只要记住下面这点就可以了：

如果实现了接收者是值类型的方法，会隐含地也实现了接收者是指针类型的方法。

#### 两者分别在何时使用

如果方法的接收者是值类型，无论调用者是对象还是对象指针，修改的都是对象的副本，不影响调用者；如果方法的接收者是指针类型，则调用者修改的是指针指向的对象本身。

使用指针作为方法的接收者的理由：

- 方法能够修改接收者指向的值。
- 避免在每次调用方法时复制该值，在值的类型为大型结构体时，这样做会更加高效。

是使用值接收者还是指针接收者，不是由该方法是否修改了调用者（也就是接收者）来决定，而是应该基于该类型的本质。

如果类型具备“原始的本质”，也就是说它的成员都是由 Go 语言里内置的原始类型，如字符串，整型值等，那就定义值接收者类型的方法。像内置的引用类型，如 slice，map，interface，channel，这些类型比较特殊，声明他们的时候，实际上是创建了一个 header， 对于他们也是直接定义值接收者类型的方法。这样，调用函数时，是直接 copy 了这些类型的 header，而 header 本身就是为复制设计的。

如果类型具备非原始的本质，不能被安全地复制，这种类型总是应该被共享，那就定义指针接收者的方法。比如 go 源码里的文件结构体（struct File）就不应该被复制，应该只有一份实体。



### 10、[Go 接口与 C++ 接口有何异同](http://golang.design/go-questions/interface/compare-to-cpp/)

接口定义了一种规范，描述了类的行为和功能，而不做具体实现。

C++ 的接口是使用抽象类来实现的，如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 “= 0” 来指定的。例如：

```plain
class Shape
{
   public:
      // 纯虚函数
      virtual double getArea() = 0;
   private:
      string name;      // 名称
};
```

设计抽象类的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。

派生类需要明确地声明它继承自基类，并且需要实现基类中所有的纯虚函数。

C++ 定义接口的方式称为“侵入式”，而 Go 采用的是 “非侵入式”，不需要显式声明，只需要实现接口定义的函数，编译器自动会识别。

C++ 和 Go 在定义接口方式上的不同，也导致了底层实现上的不同。C++ 通过虚函数表来实现基类调用派生类的函数；而 Go 通过 itab 中的 fun 字段来实现接口变量调用实体类型的函数。C++ 中的虚函数表是在编译期生成的；而 Go 的 itab 中的 fun 字段是在运行期间动态生成的。原因在于，Go 中实体类型可能会无意中实现 N 多接口，很多接口并不是本来需要的，所以不能为类型实现的所有接口都生成一个 itab， 这也是“非侵入式”带来的影响；这在 C++ 中是不存在的，因为派生需要显示声明它继承自哪个基类。






## 八、锁相关

### 5、goroutine 的自旋占用资源如何解决

自旋锁是指当一个线程在获取锁的时候，如果锁已经被其他线程获取，那么该线程将循环等待，然后不断地判断是否能够被成功获取，直到获取到锁才会退出循环。

**自旋的条件如下：**

1）还没自旋超过 4 次,

2）多核处理器，

3）GOMAXPROCS > 1，

4）p 上本地 goroutine 队列为空。

mutex 会让当前的 goroutine 去空转 CPU，在空转完后再次调用 CAS 方法去尝试性的占有锁资源，直到不满足自旋条件，则最终会加入到等待队列里。

## **九、并发相关**

### 3、如何优雅的实现一个 goroutine 池

（百度、手写代码，本人面传音控股被问道：请求数大于消费能力怎么设计协程池）

这一块能啃下来，offer满天飞，这应该是保证高并发系统稳定性、高可用的核心部分之一。

**建议参考：**

[Golang学习篇--协程池_Word哥的博客-CSDN博客_golang协程池blog.csdn.net/finghting321/article/details/106492915/](https://link.zhihu.com/?target=https%3A//blog.csdn.net/finghting321/article/details/106492915/)

**这篇文章的目录是：**

\1. 为什么需要协程池？

\2. 简单的协程池

\3. go-playground/pool

\4. ants（推荐）

**所以直接研究ants底层吧，省的造轮子。**


## 十三、框架

### Gin

文档：https://gin-gonic.com/zh-cn/docs/introduction/

#### 0、特性

1. **快速**

1. 1. 基于 Radix 树的路由，小内存占用。没有反射。可预测的 API 性能。

1. **支持中间件**

1. 1. 传入的 HTTP 请求可以由一系列中间件和最终操作来处理。 例如：Logger，Authorization，GZIP，最终操作 DB。

1. **Crash 处理**

1. 1. Gin 可以 catch 一个发生在 HTTP 请求中的 panic 并 recover 它。这样，你的服务器将始终可用。例如，你可以向 Sentry 报告这个 panic！

1. **JSON 验证**

1. 1. Gin 可以解析并验证请求的 JSON，例如检查所需值的存在。

1. **路由组**

1. 1. 更好地组织路由。是否需要授权，不同的 API 版本…… 此外，这些组可以无限制地嵌套而不会降低性能。

1. **错误管理**

1. 1. Gin 提供了一种方便的方法来收集 HTTP 请求期间发生的所有错误。最终，中间件可以将它们写入日志文件，数据库并通过网络发送。

1. **内置渲染**

1. 1. Gin 为 JSON，XML 和 HTML 渲染提供了易于使用的 API。

1. **可扩展性**

1. 1. 新建一个中间件非常简单，去查看[示例代码](https://gin-gonic.com/zh-cn/docs/examples/using-middleware/)吧。

#### 1、[gin目录结构](https://blog.csdn.net/qq_34877350/article/details/107959381)

文档：https://blog.csdn.net/qq_34877350/article/details/107959381

```plain
├── gin
│   ├──  Router
│          └── router.go
│   ├──  Middlewares
│          └── corsMiddleware.go
│   ├──  Controllers
│          └── testController.go
│   ├──  Services
│          └── testService.go
│   ├──  Models
│          └── testModel.go
│   ├──  Databases
│          └── mysql.go
│   ├──  Sessions
│          └── session.go
└── main.go
```

- 使用gorm访问数据库
- gin 为项目根目录
- main.go 为入口文件
- Router 为路由目录
- Middlewares 为中间件目录
- Controllers 为控制器目录（MVC）
- Services 为服务层目录，这里把DAO逻辑也写入其中，如果分开也可以
- Models 为模型目录
- Databases 为数据库初始化目录
- Sessions 为session初始化目录
- 文件 引用顺序 大致如下：
- main.go(在main中关闭数据库) - router(Middlewares) - Controllers - Services(sessions) - Models - Databases

#### 2、[Gin框架介绍及使用 - 李文周的博客](https://www.liwenzhou.com/posts/Go/Gin_framework/#autoid-0-0-0)

文档：https://www.liwenzhou.com/posts/Go/Gin_framework/#autoid-0-0-0

#### 3、源码

[Gin源码阅读与分析](https://www.yuque.com/iveryimportantpig/huchao/zd24cb3z2bco5304)：https://www.yuque.com/iveryimportantpig/huchao/zd24cb3z2bco5304

### go-zero

文档：https://go-zero.dev/cn/docs/introduction

go-zero 是一个集成了各种工程实践的 web 和 rpc 框架。通过弹性设计保障了大并发服务端的稳定性，经受了充分的实战检验。

go-zero 包含极简的 API 定义和生成工具 goctl，可以根据定义的 api 文件一键生成 Go, iOS, Android, Kotlin, Dart, TypeScript, JavaScript 代码，并可直接运行。

使用 go-zero 的好处：

- 轻松获得支撑千万日活服务的稳定性
- 内建级联超时控制、限流、自适应熔断、自适应降载等微服务治理能力，无需配置和额外代码
- 微服务治理中间件可无缝集成到其它现有框架使用
- 极简的 API 描述，一键生成各端代码
- 自动校验客户端请求参数合法性
- 大量微服务治理和并发工具包

### 字节-CloudWeGo

文档：https://www.cloudwego.io/zh/docs/

### HTTP-Hertz

文档：https://www.cloudwego.io/zh/docs/hertz/overview/

是一个 Golang 微服务 HTTP 框架，在设计之初参考了其他开源框架 [fasthttp](https://github.com/valyala/fasthttp)、[gin](https://github.com/gin-gonic/gin)、[echo](https://github.com/labstack/echo) 的优势， 并结合字节跳动内部的需求，使其具有高易用性、高性能、高扩展性等特点，目前在字节跳动内部已广泛使用。 如今越来越多的微服务选择使用 Golang，如果对微服务性能有要求，又希望框架能够充分满足内部的可定制化需求，Hertz 会是一个不错的选择。

**特点**

- 高易用性在开发过程中，快速写出来正确的代码往往是更重要的。因此，在 Hertz 在迭代过程中，积极听取用户意见，持续打磨框架，希望为用户提供一个更好的使用体验，帮助用户更快的写出正确的代码。
- 高性能Hertz 默认使用自研的高性能网络库 Netpoll，在一些特殊场景相较于 go net，Hertz 在 QPS、时延上均具有一定优势。关于性能数据，可参考下图 Echo 数据。四个框架的对比:![img](https://cdn.nlark.com/yuque/0/2023/png/22219483/1675414683589-8ae9d18c-b2e6-43bd-943f-7392415e0e74.png)三个框架的对比:![img](https://cdn.nlark.com/yuque/0/2023/png/22219483/1675414685005-e51955bc-2290-48b8-8782-11f6a26f4efc.png)关于详细的性能数据，可参考 https://github.com/cloudwego/hertz-benchmark。
- 高扩展性Hertz 采用了分层设计，提供了较多的接口以及默认的扩展实现，用户也可以自行扩展。同时得益于框架的分层设计，框架的扩展性也会大很多。目前仅将稳定的能力开源给社区，更多的规划参考 [RoadMap](https://github.com/cloudwego/hertz/blob/main/ROADMAP.md)。
- 多协议支持Hertz 框架原生提供 HTTP1.1、ALPN 协议支持。除此之外，由于分层设计，Hertz 甚至支持自定义构建协议解析逻辑，以满足协议层扩展的任意需求。
- 网络层切换能力Hertz 实现了 Netpoll 和 Golang 原生网络库 间按需切换能力，用户可以针对不同的场景选择合适的网络库，同时也支持以插件的方式为 Hertz 扩展网络库实现。

### RPC-Kitex 

文档：https://www.cloudwego.io/zh/docs/kitex/overview/

字节跳动内部的 Golang 微服务 RPC 框架，具有**高性能**、**强可扩展**的特点，在字节内部已广泛使用。如果对微服务性能有要求，又希望定制扩展融入自己的治理体系，Kitex 会是一个不错的选择。

**框架特点**

- **高性能**使用自研的高性能网络库 [Netpoll](https://github.com/cloudwego/netpoll)，性能相较 go net 具有显著优势。
- **扩展性**提供了较多的扩展接口以及默认扩展实现，使用者也可以根据需要自行定制扩展，具体见下面的框架扩展。
- **多消息协议**RPC 消息协议默认支持 **Thrift**、**Kitex Protobuf**、**gRPC**。Thrift 支持 Buffered 和 Framed 二进制协议；Kitex Protobuf 是 Kitex 自定义的 Protobuf 消息协议，协议格式类似 Thrift；gRPC 是对 gRPC 消息协议的支持，可以与 gRPC 互通。除此之外，使用者也可以扩展自己的消息协议。
- **多传输协议**传输协议封装消息协议进行 RPC 互通，传输协议可以额外透传元信息，用于服务治理，Kitex 支持的传输协议有 **TTHeader**、**HTTP2**。TTHeader 可以和 Thrift、Kitex Protobuf 结合使用；HTTP2 目前主要是结合 gRPC 协议使用，后续也会支持 Thrift。
- **多种消息类型**支持 **PingPong**、**Oneway**、**双向 Streaming**。其中 Oneway 目前只对 Thrift 协议支持，双向 Streaming 只对 gRPC 支持，后续会考虑支持 Thrift 的双向 Streaming。
- **服务治理**支持服务注册/发现、负载均衡、熔断、限流、重试、监控、链路跟踪、日志、诊断等服务治理模块，大部分均已提供默认扩展，使用者可选择集成。
- **代码生成**Kitex 内置代码生成工具，可支持生成 **Thrift**、**Protobuf** 以及脚手架代码。









## golang方面
#### 1. go struct能不能比较
因为是强类型语言，所以不同类型的结构不能作比较，但是同一类型的实例值是可以比较的，实例不可以比较，因为是指针类型


#### 3.channnel

##### 切片、map、channel是否并发安全

切片和映射（map）的访问和操作不是并发安全的，需要采取额外的措施来确保并发安全。而通道（channel）则是并发安全的，因为通道在设计时就考虑了并发性。

切片和映射的非并发安全性主要表现在两个方面：

1. 内部结构的修改：切片和映射都有一个内部的结构，包含指向底层数组或哈希表的指针、长度和容量等信息。当多个 goroutine 并发修改这些信息时，可能会导致数据的不一致性，甚至破坏整个数据结构。
2. 并发读写的竞争：当多个 goroutine 并发读写同一个切片或映射时，可能会出现竞争条件，导致数据的不一致性或不可预期的结果。

为了确保切片和映射的并发安全，可以采用以下方法：

1. 互斥锁：使用 sync.Mutex 或 sync.RWMutex 等同步原语，在访问和修改切片或映射时加锁，避免多个 goroutine 同时修改数据结构。

2. 原子操作：使用 sync/atomic 包中的原子操作，可以在不使用互斥锁的情况下进行原子性操作，避免竞争条件。

   

   通道是并发安全的，因为通道内部维护了一个队列，每次只有一个 goroutine 可以向通道发送或接收数据，其他 goroutine 需要等待该操作完成后才能进行下一步操作。这种方式保证了数据的顺序和一致性，避免了竞争条件和数据不一致性的问题。

##### sync.map底层分片原理

sync.map底层使用了分片技术，将整个map分成多个小的map，每个小的map称为一个分片。每个分片都有自己的读写锁，可以独立地进行读写操作，从而提高了并发性能。

具体来说，sync.map将key通过哈希函数映射到不同的分片中，每个分片中包含了一部分key-value对。当进行读写操作时，先根据key计算出对应的分片，然后在该分片中进行操作。这样就可以避免多个goroutine同时访问同一个分片，从而提高了并发性能。

在实现上，sync.map使用了一个数组来存储所有的分片，每个分片都是一个结构体，包含了一个读写锁和一个map。当进行读写操作时，先根据key计算出对应的分片索引，然后在该分片中进行操作。由于每个分片都有自己的读写锁，因此可以并发地进行读写操作，从而提高了并发性能。

总之，sync.map底层使用了分片技术，将整个map分成多个小的map，每个小的map称为一个分片，从而提高了并发性能。



##### select监听管道

select的case语句读channel不会阻塞，尽管channel中没有数据。这是由于case语句编译后调用读 channel时会明确传入不阻塞的参数，此时读不到数据时不会将当前goroutine加入到等待队列，而是直接返回。

##### range遍历管道

相当于读，会发生管道阻塞

#### Slice

##### 分配切片的几种方式

make([]T,len)

make([]T,len,cap)

原数组上划分 slice := lice := array[5:7]，创建数组的长度为元素数量，容量为从开始到原数组最后的位置

![image-20220609142603339](C:\Users\fliggy\AppData\Roaming\Typora\typora-user-images\image-20220609142603339.png)

slice := arr[start:end：max]

start 开始位置，end结束位置，max（max不能小于长度，不能大于原数组的长度）

##### 切片扩容

切片的扩容

1. 小于1024 2倍扩容
2. 大于1024 1.25倍扩容

扩容之后，切片指向的底层数组放生变化

![image-20220611161140068](C:\Users\fliggy\AppData\Roaming\Typora\typora-user-images\image-20220611161140068.png)

##### 切片拷贝

使用copy()内置函数拷贝两个切片时，会将源切片的数据逐个拷贝到目的切片指向的数组中，拷贝数量取两个切片长度的最小 值。 

例如长度为10的切片拷贝到长度为5的切片时，将会拷贝5个元素。 也就是说，copy过程中不会发生扩容。

##### 总结

append函数总会返回新的切片，而且如果新切片的容量比原切片的容量更大那么就 意味着底层数组也是新的了。

通过函数传递切片时，不会拷贝整个切片，因为切片本身只是个结构体而已


#### struct中tag

Go的struct声明允许字段附带 Tag 来对字段做一些标记。 该 Tag 不仅仅是一个字符串那么简单，因为其主要用于反射场景， reflect 包中提供了操作 Tag 的方法，所 以 Tag 写法也要遵循一定的规则。

##### tag是struct中的一部分

Go 是如何管理struct字段的。

```go
// A StructField describes a single field in a struct.
type StructField struct {
	// Name is the field name.
    Name string
    ...
    Type Type // field type
    Tag StructTag // field tag string
    ...
}
type StructTag string
```

##### 获取tag

通过反射获取

#### Iota

##### iota规则

iota代表了const声明块的行索引（下标从0开始）

除此之外，const声明还有个特点，即第一个常量必须指定一个表达式，后续的常 量如果没有表达式，则继承上面的表达式。

```go
const (
    bit0, mask0 = 1 << iota, 1<<iota - 1 //const声明第0行，即iota==0
    bit1, mask1 //const声明第1行，即iota==1, 表达式继承上面的语句
    _, _ //const声明第2行，即iota==2
    bit3, mask3 //const声明第3行，即iota==3
)
```

##### 编译原理（理解规则）

```go
ValueSpec struct {
    Doc *CommentGroup // associated documentation; or nil
    Names []*Ident // value names (len(Names) > 0)
    Type Expr // value type; or nil
    Values []Expr // initial values; or nil
    Comment *CommentGroup // line comments; or nil
}
```

其中iota实际每一行对应一个ValueSpec存储

对应一个ValueSpec，表示了这一行中多次的iota定义

const块实际上是spec类型的切片，用于表示const中的多行。 

所以编译期间构造常量时的伪算法如下：

```go
for iota, spec := range ValueSpecs {
    for i, name := range spec.Names {
        obj := NewConst(name, iota...) //此处将iota传入，用于构造常量
        ...
    }
}
```

从上面可以更清晰的看出iota实际上是遍历const块的索引，每行中即便多次使用iota，其值也不会递增。

#### string

##### 数据结构

Go标准库 builtin 给出了所有内置类型的定义。 源代码位于 src/builtin/builtin.go ，其中关于string的描述如下

- string可以为空（长度为0），但不会是nil
- string对象不可以修改

```go
type stringStruct struct {
    str unsafe.Pointer //首地址
    len int //长度
}
```

##### []byte转string

```go
func GetStringBySlice(s []byte) string {
    return string(s)
}

转换过程如下：
1. 根据切片的长度申请内存空间，假设内存地址为p，切片长度为len(b)；
2. 构建string（string.str = p；string.len = len；）
3. 拷贝数据(切片中数据拷贝到新申请的内存空间)
```

##### 字符串拼接

```go
func concatstrings(a []string) string { // 字符串拼接
    length := 0 // 拼接后总的字符串长度
    for _, str := range a {
    	length += len(str)
    }
    s, b := rawstring(length) // 生成指定大小的字符串，返回一个string和切片，二者共享内存空间
    for _, str := range a {
        copy(b, str) // string无法修改，只能通过切片修改
        b = b[len(str):]
    } 
	return s
}

```

##### 为什么字符串不允许修改

因为string通常指向字符串字面量，而字符串字面量存储位置是只读段，而不是堆或栈上，所以才有了string不可修改的约定。

##### []byte转换成string一定会拷贝内存吗？

yte切片转换成string的场景很多，为了性能上的考虑，有时候只是临时需要字符串的场景下，byte切片转换成string时并不 会拷贝内存，而是直接返回一个string，这个string的指针(string.str)指向切片的内存

比如，编译器会识别如下临时场景： 

- 使用m[string(b)]来查找map（map是string为key，临时把切片b转成string）； 
- 字符串拼接，如”<” + “string(b)” + “>”；
- 字符串比较：string(b) == “foo”

#### 常见控制结构

##### defer

###### defer规则

- 延迟函数的参数在defer语句出现时就已经确定下来了
- 延迟函数执行按后进先出顺序执行，即先出现的defer最后执 行

设计defer的初衷是简化函数返回时资源清理的动作，资源往往有依赖顺序，比如先申请A资源，再根据A资源申请B资源，根据 B资源申请C资源，即申请顺序是:A–>B–>C，释放时往往又要反向进行。这就是把defer设计成LIFO的原因。

- 延迟函数**可能**操作主函数的具名返回值（注意是可能）


##### recover 失效的条件

1. panic时指定的参数为 nil ；（一般panic语句如 panic("xxx failed...") ）
2. 当前协程没有发生panic； 
3. recover没有被defer方法直接调用；

##### select

select是Golang在语言层面提供的**多路IO复用**的机制，其可以检测多个channel是否ready(即是否可读或可写)

##### range

- 遍历过程中每次迭代会对index和value进行赋值，如果数据量大或者value类型为string时，对value的赋值操作可能是多余 的，可以在for-range中忽略value值，使用slice[index]引用value值。
- 另外range会复制对象，在你遍历对象之前，k，v就已经被确定了。这时候如果去修改数组的值，对遍历出来的v没有任何影响

```go
package main

import "fmt"

func main() {
    a := [3]int{0, 1, 2}

    for i, v := range a { // index、value 都是从复制品中取出。

        if i == 0 { // 在修改前，我们先修改原数组。
            a[1], a[2] = 999, 999
            fmt.Println(a) // 确认修改有效，输出 [0, 999, 999]。
        }

        a[i] = v + 100 // 使用复制品中取出的 value 修改原数组。

    }

    fmt.Println(a) // 输出 [100, 101, 102]。
}

	a:= []int{0, 1, 2}

	for i, v := range a { // index、value 都是从复制品中取出。

		if i == 0 { // 在修改前，我们先修改原数组。
			a[1], a[2] = 999, 999
			fmt.Println(a) // 确认修改有效，输出 [0, 999, 999]。
		}

		a[i] = v + 100 // 使用复制品中取出的 value 修改原数组。

	}

	fmt.Println(a) // 输出 [100, 1099, 1099]。
}
//原因就在于虽然切片被拷贝了，但是指向的底层数组并没有发生改变
```

- 遍历过程中可以视情况放弃接收index或value，可以一定程度上提升性能 
- 遍历channel时，如果channel中没有数据，可能会阻塞 
- 尽量避免遍历过程中修改原数据

#### 协程调度

#### 内存对齐

- 起始地址必须是对齐边界倍数
- 长度必须是对齐边界的倍数

保证了，不能有多余的取值操作

- 结构体对齐边界为，结构体字段中最大的对齐边界

![image-20220611165047235](C:\Users\fliggy\AppData\Roaming\Typora\typora-user-images\image-20220611165047235.png)

![image-20220611165030945](C:\Users\fliggy\AppData\Roaming\Typora\typora-user-images\image-20220611165030945.png)

### Linux进程

#### 进程

进程是计算机中已运行程序的实体

#### PID/PPID

pid表示进程id，ppid表示进程父id


slice

map
