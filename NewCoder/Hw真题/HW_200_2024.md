# 华为机考 200分 题
## 1. 标题：孙悟空吃蟠桃

孙悟空爱吃蟠桃，有一天趁着蟠桃园守卫不在来偷吃。已知蟠桃园有N颗桃树，每颗树上都有桃子，守卫将在H小时后回来。

孙悟空可以决定他吃蟠桃的速度K（个/小时），每个小时选一颗桃树，并从树上吃掉K个，如果树上的桃子少于K个，则全部吃掉，并且这一小时剩余的时间里不再吃桃。

孙悟空喜欢慢慢吃，但又想在守卫回来前吃完桃子。

请返回孙悟空可以在H小时内吃掉所有桃子的最小速度K（K为整数）。如果以任何速度都吃不完所有桃子，则返回0。

输入描述:
第一行输入为N个数字，N表示桃树的数量，这N个数字表示每棵桃树上蟠桃的数量。
第二行输入为一个数字，表示守卫离开的时间H。
其中数字通过空格分割，N、H为正整数，每棵树上都有蟠桃，且0<N<10000，0<H<10000。

输出描述:
吃掉所有蟠桃的最小速度K，无解或输入异常时输出0。
示例1
输入
2 3 4 5
4
输出
5
示例2
输入
2 3 4 5
3
输出
0
示例3
输入
30 11 23 4 20
6
输出
23

## 2. 标题：篮球游戏

幼儿园里有一个放倒的圆桶，它是一个线性结构，允许在桶的右边将篮球放入，可以在桶的左边和右边将篮球取出。每个篮球有单独的编号，老师可以连续放入一个或多个篮球，小朋友可以在桶左边或右边将篮球取出，当桶里只有一个篮球的情况下，必须从左边取出。

如老师按顺序放入1、2、3、4、5 共5个编号的篮球，那么小朋友可以依次取出的编号为“1,2,3,4,5”或者“3,1,2,4,5”编号的篮球，无法取出 “5,1,3,2,4” 编号的篮球
其中“3,1,2,4,5”的取出场景为：连续放入1,2,3号 -> 从右边取出3号 -> 从左边取出1号 -> 从左边取出2号 -> 放入4号 -> 从左边取出4号 -> 放入5号 -> 从左边取出5号，简单起见，我们以L表示左，R表示右，此时的篮球的依次取出序列为“ RLLLL ”
输入描述:
每次输入包含一个测试用例：
1、第一行的数字作为老师依次放入的篮球编号；
2、第二行的数字作为要检查是否能够按照放入顺序取出的篮球编号；
其中篮球编号用逗号进行分隔。
输出描述:
对于每个篮球的取出序列，如果确实可以获取，请打印出其按照左右方向的操作的取出顺序，如果无法获取则打印"NO"
备注:
1、1<=篮球的编号，篮球个数<=200；
2、篮球上的数字不重复；
3、输出的结果中LR的必须为大写；
示例1
输入
4,5,6,7,0,1,2
6,4,0,1,2,5,7
输出
RLRRRLL
说明
篮球的取出顺序依次为 “右，左，右，右，右，左，左”
示例2
输入
4,5,6,7,0,1,2
6,0,5,1,2,4,7
输出
NO
说明
无法取出对应序列的篮球
示例3
输入
1,2,3,4
1,2,3,5
输出
NO
说明
不存在编号为5的篮球，所以无法取出对应的编号数据

## 3. 标题：石头剪刀布游戏 

石头剪刀布游戏有3种出拳形状：石头、剪刀、布。 分别用字母 A,B,C表示。

游戏规则：

1）出拳形状之间的胜负规则如下：A> B；B> C；C> A

“>” 左边一个字母，表示相对优势形状。 右边一个字母，表示相对劣势形状。

2) 当本场次中有且仅有一种出拳形状优于其它出拳形状，则该形状的玩家是胜利者。 否则认为是平局。
  例如1 三个玩家出拳分别是 A,B,C。由于出现三方优势循环（即没有任何一方优于其它出拳者），判断为平局。
  例如2 三个玩家，出拳分别是 A,B。出拳A的获胜。 
  例如3   三个玩家，出拳全部是 A。 判为平局
3）当发生平局，没有赢家。有多个胜利者时，同为赢家。 

输入描述:
在一场游戏中，每个玩家的信息为一行。玩家数量不超过1000。玩家信息2个字段，用空格隔开： 

1）玩家ID：一个仅由英文字母和数字组成的字符串。

2）出拳形状：以英文大写字母表示，A、B、C形状。

3）出拳时间：正整数，越小表示时间越早

例如：

abc1 A

xyz B

解释：玩家abc1 出拳为石头（A）。玩家 xyz 出拳为剪刀（B）

输出描述:
输出为赢家的玩家ID列表（一个或多个），每个ID一行，按字符串升序排列。 如果没有赢家，输出为“NULL”字符串。
例如：
abc1 

示例1
输入
abc1 A
xyz B
输出
abc1
说明
A比B有优势，abc1 胜出
示例2
输入
abc1 A
xyz A
输出
NULL
说明
没有优胜的出拳形状，平局
示例3
输入
abc1 A
def A
alic A
xyz B
输出
abc1
alic
def
说明
A为优胜方，有三个赢家
4
ACM编程 语言限制 【200分】 标题：跳格子三 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
小明和朋友们一起玩跳格子游戏，每个格子上有特定的分数，score[] = [1 -1 -6 7 -17 7]，从起点score[0]开始，每次最大跳的步长为k，请你返回小明跳到终点score[n-1]时，能得到的最大得分 。

注：
格子的总长度和步长的区间在 [1,  100000]；
每个格子的分数在[-10000, 10000]区间中；
输入描述:
6 // 第一行输入总的格子数量
1 -1 -6 7 -17 7  // 第二行输入每个格子的分数score[]
2  // 第三行输入最大跳的步长k
输出描述:
14 // 输出最大得分数，小明从起点score[0]开始跳，第一次跳score[1], 第二次跳到score[3],第三次跳到score[5]，因此得到的最大的得分是score[0] + score[1] + score[3] + score[5] = 14
示例1
输入
6
1 -1 -6 7 -17 7
2
输出
14
5
ACM编程 语言限制 【200分】 标题：智能驾驶 | 时间限制：2秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
有一辆汽车需要从m * n的地图的左上角（起点）开往地图的右下角（终点），去往每一个地区都需要消耗一定的油量，加油站可进行加油
请你计算汽车确保从起点到达终点时所需的最少初始油量
说明：
（1）智能汽车可以上、下、左、右四个方向移动
（2）地图中的数字取值是0或-1或正整数：
     -1：表示加油站，可以加满油，汽车的油箱容量最大为100；
      0：表示这个地区是障碍物，汽车不能通过；
      正整数：表示汽车走过这个地区的耗油量
（3）如果汽车无论如何都无法到达终点，则返回-1
输入描述:
第一行为两个数字，M、N，表示地图的大小为M*N
后面是一个M*N的矩阵，其中的值是0或-1或正整数，加油站的总数不超过200个
输出描述:
如果汽车无论如何都无法到达终点，则返回-1。
如果汽车可以到达终点，则返回最少的初始油量。
备注:
0<M,N<=200
示例1
输入
2,2
10,20
30,40
输出
70
说明
行走路线为：右->下
示例2
输入
4,4
10,30,30,20
30,30,-1,10
0,20,20,40
10,-1,30,40
输出
70
说明
行走路线为：右->右->下->下->下->右
示例3
输入
4,5
10,0,30,-1,10
30,0,20,0,20
10,0,10,0,30
10,-1,30,0,10
输出
60
说明
行走路线为：下->下->下->右->右->上->上->上->右->右->下->下->下
示例4
输入
4,4
10,30,30,20
30,30,20,10
10,20,10,40
10,20,30,40
输出
-1
说明
无论如何都无法到达终点
6
ACM编程 语言限制 【200分】 标题：园区参观路径 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
园区某部门举办了Family Day，邀请员工及其家属参加；将公司园区视为一个矩形，起始园区设置在左上角，终点园区设置在右下角；家属参观园区时，只能向右和向下园区前进；求从起始园区到终点园区会有多少条不同的参观路径；

输入描述:
第一行为园区长和宽；后面每一行表示该园区是否可以参观，0表示可以参观，1表示不能参观
输出描述:
输出为不同的路径数量
备注:

1 <= 园区长 <= 100



1 <= 园区宽 <= 100

示例1
输入
3 3
0 0 0
0 1 0
0 0 0
输出
2
7
ACM编程 语言限制 【200分】 标题：运输时间 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), JavaScript V8(6.0.0), Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), bash(GNU bash4.3.46), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)
M（1<=M <=20）辆车需要在一条不能超车的单行道到达终点，起点到终点的距离为N（1<=N<=400）。速度快的车追上前车后，只能以前车的速度继续行驶，求最后一车辆到达目的地花费的时间。
注：每辆车固定间隔1小时出发，比如第一辆车0时出发，第二辆车1时出发，依次类推

输入描述:
第一行两个数字：M N分别代表车辆数和到终点的距离，以空格分隔。

接下来M行，每行1个数字 S，代表每辆车的速度。0< S<30



输出描述:
输出：最后一辆车到达目的地花费的时间。
示例1
输入
2 11
3
2
输出
5.5
说明
2辆车，距离11，0时出发的车速度快，1时出发的车，达到目的地花费5.5
8
ACM编程 语言限制 【200分】 标题：数据单元的变量替换 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
将一个csv格式的数据文件中包含有单元格引用的内容替换为对应单元格内容的实际值。
comma separated values(CSV) 逗号分隔值，csv格式的数据文件使用逗号“,”作为分隔符将各单元的内容进行分隔。
输入描述:
1、输入只有一行数据，用逗号分隔每个单元格，行尾没有逗号。最多26个单元格，对应编号A~Z。
2、每个单元格的内容包含字母和数字，以及使用'<>'分隔的单元格引用，例如：<A>表示引用第一个单元的值。
3、每个单元格的内容，在替换前和替换后均不超过100个字符。
5、引用单元格的位置不受限制，允许排在后面的单元格被排在前面的单元格引用。

6、不存在循环引用的情况，比如下面这种场景是不存在的：

A单元格：aCd<B>8u

B单元格：kAy<A>dzqo
7、不存在多重'<>'的情况，一个单元格只能引用一个其他单元格。比如下面这种场景是不存在的：
A单元格：aCd8u

B单元格：kAydzqo
C单元格：y<<A><B>>d
输出描述:
输出所有单元格展开后的内容，单元格之间用","分隔。处理过程中出现错误时，输出字符串“-1”表示出错。
示例1
输入
1,2<A>00
输出
1,2100
说明
第二个单元中有对A单元的引用，A单元格的值为1，替换时，将A单元的内容替代<A>的位置，并和其他内容合并。
示例2
输入
<B>12,1
输出
112,1
说明
第一个单元中有对B单元的引用，B单元格的值为1，替换时，将第二个数据单元的内容替代<B>的位置，并和其他内容合并。
示例3
输入
<B<12,1
输出
-1
说明
第一个单元中有错误的单元格引用方式，输出字符串“-1”表示错误。
9
ACM编程 语言限制 【200分】 标题：伐木工 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
一根X米长的树木，伐木工切割成不同长度的木材后进行交易，交易价格为每根木头长度的乘积。规定切割后的每根木头长度都为正整数；也可以不切割，直接拿整根树木进行交易。请问伐木工如何尽量少的切割，才能使收益最大化？




输入描述:
木材的长度（X<=50）


输出描述:
输出最优收益时的各个树木长度，以空格分割，按升序排列
示例1
输入
10
输出
3 3 4
说明
1. 一根2米长的树木，伐木工不切割，为2 * 1，收益最大为2 
2. 一根4米长的树木，伐木工不需要切割为2 * 2，省去切割成本，直接整根树木交易，为4 * 1，收益最大为4 
3. 一根5米长的树木，伐木工切割为2 * 3，收益最大为6 
4. 一根10米长的树木，伐木工可以切割为方式一：3，4，3，也可以切割为方式二：3，2，2，3，但方式二伐木工多切割了一次，增加切割成本却卖了一样的价格，因此并不是最优收益。
10
ACM编程 语言限制 【200分】 标题：高效货运 | 时间限制：1秒 | 内存限制：32768K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
1.老李是货运公司承运人，老李的货车额定载货重量为wt
2.现有两种货物，货物A单件重量为wa，单件运费利润为pa，货物B单件重量为wb，单件运费利润为pb
3.老李每次发车时载货总重量刚好为货车额定载货重量wt，车上必须同时有货物A和货物B，货物A、B不可切割
4.老李单车次满载运输可获得的最高利润是多少
输入描述:
第一列输入为货物A的单件重量wa，0<wa<10000
第二列输入为货物B的单件重量wb，0<wb<10000
第三列输入为货车的额定载重wt，0<wt<100000
第四列输入为货物A的单件运费利润pa，0<pa<1000
第五列输入为货物B的单件运费利润pb，0<pb<1000


输出描述:
单次满载运输的最高利润
示例1
输入
10 8 36 15 7
输出
44
示例2
输入
1 1 2 1 1
输出
2
11
ACM编程 语言限制 【200分】 标题：推荐多样性 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
推荐多样性需要从多个列表中选择元素，一次性要返回N屏数据（窗口数量），每屏展示K个元素（窗口大小），选择策略：
1. 各个列表元素需要做穿插处理，即先从第一个列表中为每屏选择一个元素，再从第二个列表中为每屏选择一个元素，依次类推
2. 每个列表的元素尽量均分为N份，如果不够N个，也要全部分配完，参考样例图：
（1）从第一个列表中选择4条0 1 2 3，分别放到4个窗口中
（2）从第二个列表中选择4条10 11 12 13，分别放到4个窗口中
（3）从第三个列表中选择4条20 21 22 23，分别放到4个窗口中
（4）再从第一个列表中选择4条4 5 6 7，分别放到4个窗口中
...
（5）再从第一个列表中选择，由于数量不足4条，取剩下的2条，放到窗口1和窗口2
（6）再从第二个列表中选择，由于数量不足4条并且总的元素数达到窗口要求，取18 19放到窗口3和窗口4


输入描述:
第一行输入为N，表示需要输出的窗口数量，取值范围 [1, 10]
第二行输入为K，表示每个窗口需要的元素数量，取值范围 [1, 100]
之后的行数不定（行数取值范围[1,10]），表示每个列表输出的元素列表。元素之间以空格分隔，已经过排序处理，每个列表输出的元素数量取值范围[1,100]
输出描述:
输出元素列表，元素数量=窗口数量*窗口大小，元素之间以空格分隔，多个窗口合并为一个列表输出，参考样例：
先输出窗口1的元素列表，再输出窗口2的元素列表，再输出窗口3的元素列表，最后输出窗口4的元素列表
备注:
1. 每个列表会保证元素数量满足窗口要求，不需要考虑元素不足情况
2. 每个列表的元素已去重，不需要考虑元素重复情况
3. 每个列表的元素列表均不为空，不需要考虑列表为空情况
4. 每个列表的元素列表已经过排序处理，输出结果要保证不改变同一个列表的元素顺序
5. 每个列表的元素数量可能是不同的
示例1
输入
4
7
0 1 2 3 4 5 6 7 8 9
10 11 12 13 14 15 16 17 18 19
20 21 22 23 24 25 26 27 28 29
输出
0 10 20 4 14 24 8 1 11 21 5 15 25 9 2 12 22 6 16 26 18 3 13 23 7 17 27 19
12
ACM编程 语言限制 【200分】 标题：信道分配 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
算法工程师小明面对着这样一个问题，需要将通信用的信道分配给尽量多的用户：


信道的条件及分配规则如下：

1)     所有信道都有属性：”阶”。阶为r的信道的容量为2^r比特；

2)     所有用户需要传输的数据量都一样：D比特；

3)     一个用户可以分配多个信道，但每个信道只能分配给一个用户；

4)     只有当分配给一个用户的所有信道的容量和>=D，用户才能传输数据；


给出一组信道资源，最多可以为多少用户传输数据？

输入描述:
第一行，一个数字R。R为最大阶数。

0<=R<20

 

第二行，R+1个数字，用空格隔开。

代表每种信道的数量Ni。按照阶的值从小到大排列。

0<=i<=R, 0<=Ni<1000.

 

第三行，一个数字D。

D为单个用户需要传输的数据量。

0<D<1000000

输出描述:
一个数字，代表最多可以供多少用户传输数据。

示例1
输入
5
10 5 0 1 3 2
30
输出
4
说明
最大阶数为5.

信道阶数：0       1    2    3    4    5

信道容量：1       2    4    8    16  32  

信道个数：10     5    0    1    3    2

单个用户需要传输的数据量为30

 

可能存在很多分配方式，举例说明：

分配方式1：

1)     32*1 = 32

2)     32*1 = 32

3)     16*2 = 32

4)     16*1 + 8*1 + 2*3 = 30

剩下2*2 + 1*10=14不足以再分一个用户了。

 

分配方式2：

1)     16*1 + 8*1 + 2*3 = 30

2)     16*1 + 2*2 + 1*10 = 30

3)     32*1 = 32

4)     32*1 = 32

剩下16*1=16不足以再分一个用户了。

 

分配方式3：

1)     16*1 + 8*1 + 2*3 = 30

2)     16*1 + 2*2 + 1*10 = 30

3)     16*1 + 32*1 = 48

4)     32*1 = 32

恰好用完。

 

虽然每种分配方式剩下的容量不同，但服务的用户数量是一致的。因为这个问题中我们只关心服务的用户数，所以我们认为这些分配方式等效。
13
ACM编程 语言限制 【200分】 标题：贪心歌手 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), JavaScript V8(6.0.0), Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), C++14(g++5.4), bash(GNU bash4.3.46), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44)
一个歌手准备从A城去B城参加演出。

1)     按照合同，他必须在T天内赶到。

2)     歌手途径N座城市。

3)     歌手不能往回走。

4)     每两座城市之间需要的天数都可以提前获知。

5)     歌手在每座城市都可以在路边卖唱赚钱。经过调研，歌手提前获知了每座城市卖唱的收入预期：

如果在一座城市第一天卖唱可以赚M，后续每天的收入会减少D（第二天赚的钱是M – D，第三天是M-2D…）。如果收入减到0就不会再少了。

6)     歌手到达后的第二天才能开始卖唱。如果今天卖过唱，第二天才能出发。

贪心的歌手最多可以赚多少钱？

输入描述:
第一行两个数字 T和N，中间用空格隔开。

T代表总天数；

N代表路上经过N座城市；

0 < T < 1000, 0 < N < 100

 

第二行N+1个数字，中间用空格隔开。

代表每两座城市之间耗费的时间。

其总和<=T。

 

接下来N行，每行两个数字M和D，中间用空格隔开。

代表每个城市的收入预期。

0 < M < 1000, 0 < D < 100

输出描述:
一个数字。代表歌手最多可以赚多少钱。以回车结束。

示例1
输入
10 2
1 1 2
120 20
90 10
输出
540
说明
总共10天，路上经过2座城市。

路上共花1+1+2=4天。

剩余6天最好的计划是在第一座城市待3天，在第二座城市待3天。

在第一座城市赚的钱：120+100+80= 300.

在第二座城市赚的钱：90+80+70 =240.

一共300 + 240 = 540。

14
ACM编程 语言限制 【200分】 标题：5G网络建设 | 时间限制：4秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
现需要在某城市进行5G网络建设，已经选取N个地点设置5G基站，编号固定为1到N，接下来需要各个基站之间使用光纤进行连接以确保基站能互联互通，不同基站之间架设光纤的成本各不相同，且有些节点之间已经存在光纤相连，请你设计算法，计算出能联通这些基站的最小成本是多少。
注意：基站的联通具有传递性，入基站A与基站B架设了光纤，基站B与基站C也架设了光纤，则基站A与基站C视为可以互相联通
输入描述:
第一行输入表示基站的个数N，其中0<N<=20
第二行输入表示具备光纤直连条件的基站对的数目M，其中0<M<N*(N-1)/2
从第三行开始连续输入M行数据，格式为 X Y Z P，其中X Y表示基站的编号，0<X<=N，0<Y<=N且x不等于y，Z表示在X Y之间架设光纤的成本，其中 0<Z<100，P表示是否已存在光纤连接，0表示未连接，1表示已连接
输出描述:
如果给定条件，可以建设成功互联互通的5G网络，则输出最小的建设成本；
如果给定条件，无法建设成功互联互通的5G网络，则输出-1
示例1
输入
3
3
1 2 3 0
1 3 1 0
2 3 5 0
输出
4
说明
只需要在1,2以及2,3基站之间铺设光纤，其成本为3+1=4
示例2
输入
3
1
1 2 5 0
输出
-1
说明
3基站无法与其他基站连接，输出-1
示例3
输入
3
3
1 2 3 0
1 3 1 0
2 3 5 1
输出
1
说明
2,3基站已有光纤相连，只有要再1,3站点之间铺设光纤，其成本为1
15
ACM编程 语言限制 【200分】 标题：模拟数据序列化传输 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
模拟一套简化的序列化传输方式，请实现下面的数据编码与解码过程
1、编码前数据格式为[位置,类型，值]，多个数据的时候用逗号分隔，位置仅支持数字，不考虑重复等场景；类型仅支持：Integer/String/Compose（Compose的数据类型表示该存储的数据也需要编码）。
2、编码后数据参考图示，数据区的格式是：位置#类型#长度#数，类型存储需要编码，Integer->0;String->1;Compose->2 长度是指数据的字符长度；数据仅允许数字、大小写字母、空格。

	 

3、输入的编码字符长度不能超过1000，一个数据的格式错误，则解析剩下数据，其他错误输出ENCODE_ERROR。
4、输入的解码字符不能超过1000，数据区异常则跳过继续解析剩余数据区，其他异常输出DECODE_ERROR。

输入描述:
输入有两行，第一行是命令，1表示编码，2表示解码，第二行输入待编码、解码的字符。
数据最多嵌套10层， [1,Compose,[1,String,Second]]为2层嵌套。
输出描述:
如果输入要求是编码，则输出编码结果；如果输入要求是解码，则输出解码结果；当异常时输出对应的错误字符
示例1
输入
1
[1,String,I am Mary],[2,Integer,23],[3, Long,1000000],[4,Compose,[1,String,I am Kitty],[2,Integer,44]]
输出
1#1#9#I am Mary2#0#2#234#2#25#1#1#10#I am Kitty2#0#2#44
说明
由于Long型未不支持类型，所以数据[3, Long,1000000]自动被过滤掉
示例2
输入
2
1#1#9#I am Mary2#0#2#233#0#3#8794#2#25#1#1#10#I am Kitty2#0#2#44
输出
[1,String,I am Mary],[2,Integer,23],[3,Integer,879],[4,Compose,[1,String,I am Kitty],[2,Integer,44]]
示例3
输入
2
xxx
输出
DECODE_ERROR
说明
输入的待解码数据不满足格式要求
示例4
输入
1
[1,String,I am Mary],[2,Integer,23]],
输出
ENCODE_ERROR
说明
输入格式不满足输入格式要求
16
ACM编程 语言限制 【200分】 标题：学生重新排队 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
n个学生排成一排，学生编号分别是1到n，n为3的整倍数。老师随机抽签决定将所有学生分成m个3人的小组，n=3*m
为了便于同组学生交流，老师决定将小组成员安排到一起，也就是同组成员彼此相连，同组任意两个成员之间无其它组的成员。
因此老师决定调整队伍，老师每次可以调整任何一名学生到队伍的任意位置，计为调整了一次，
请计算最少调整多少次可以达到目标。
注意：对于小组之间没有顺序要求，同组学生之间没有顺序要求。
输入描述:
两行字符串，空格分隔表示不同的学生编号
第一行是学生目前排队情况
第二行是随机抽签分组情况，从左开始每3个元素为一组
n 为学生的数量， n的范围为[3, 900], n一定为3的整倍数
第一行和第二行的元素个数一定相同


输出描述:
老师调整学生达到同组彼此相连的最小次数

备注:
同组相连： 同组任意两个成员之间无其它组的成员 ，比如有两个小组[4 5 6]  [1 2 3],以下结果都满足要求
1 2 3 4 5 6
1 3 2 4 5 6
2 3 1 5 6 4
5 6 4 1 2 3
以下结果不满足要求
1 2 4 3 5 6，  4与5之间存在其它组的成员3
 
示例1
输入
7 9 8 5 6 4 2 1 3
7 8 9 4 2 1 3 5 6
输出
1
说明

学生目前排队情况: 7 9 8 5 6 4 2 1 3
学生分组情况：[7 8 9] [4 2 1] [3 5 6]
将3调整到4之前，队列调整为 7 9 8 5 6 3 4 2 1，那么三个小组成员均彼此相连[7 9 8] [5 6 3] [4 2 1]
输出：1
示例2
输入
8 9 7 5 6 3 2 1 4
7 8 9 4 2 1 3 5 6
输出
0
说明

学生目前排队情况: 7 9 8 5 6 3 2 1 4
学生分组情况：[7 8 9] [4 2 1] [3 5 6]
无需调整，三个小组成员均彼此相连[7 9 8] [5 6 3] [2 1 4]
输出：0
17
ACM编程 语言限制 【200分】 标题：根据IP查找城市 | 时间限制：3秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
某业务需要根据终端的IP地址获取该终端归属的城市，可以根据公开的IP地址池信息查询归属城市。地址池格式如下城市名=起始IP,结束IP，起始和结束地址按照英文逗号分隔，多个地址段采用英文分号分隔。

比如City1=1.1.1.1,1.1.1.2;City1=1.1.1.11,1.1.1.16;City2=3.3.3.3,4.4.4.4;City3=2.2.2.2,6.6.6.6。
一个城市可以有多个IP段，比如City1有2个IP段。城市间也可能存在包含关系，如City3的IP段范围包含City2的IP段范围。现在要根据输入的IP列表，返回最佳匹配的城市列表。

注：最佳匹配即包含待查询IP且长度最小的IP段，比如例子中3.4.4.4最佳匹配是City2=3.3.3.3,4.4.4.4，5.5.5.5的最佳匹配是City3=2.2.2.2,6.6.6.6。
输入描述:
输入共2行。
第一行为城市的IP段列表，多个IP段采用英文分号';'分隔，IP段列表最大不超过500000。城市名称只包含英文字母、数字和下划线，最多不超过100000个。IP段包含关系可能有多层，但不超过100层。
第二行为查询的IP列表，多个IP采用英文逗号‘,’分隔，最多不超过10000条。
输出描述:
最佳匹配的城市名列表，采用英文逗号‘,’分隔，城市列表长度应该跟查询的IP列表长度一致。
备注:
1）无论是否查到匹配正常都要输出分隔符。举例：假如输入IP列表为IPa,IPb两个IP均未有匹配城市，此时输出为“,”，即只有一个逗号分隔符，两个城市均为空；
2）可以假定用例中的所有输入均合法，IP地址均为合法的ipv4地址，满足（1~255）.（0~255）.（0~255）.（0~255）的格式，且可以假定用例中不会出现组播和广播地址；
示例1
输入
City1=1.1.1.1,1.1.1.2;City1=1.1.1.11,1.1.1.16;City2=3.3.3.3,4.4.4.4;City3=2.2.2.2,6.6.6.6
1.1.1.15,3.3.3.5,2.2.2.3
输出
City1,City2,City3
说明
1）City1有2个IP段，City3的IP段包含City2的IP段；
2）1.1.1.15仅匹配City1=1.1.1.11,1.1.1.16，所以City1就是最佳匹配；2.2.2.3仅匹配City3=2.2.2.2,6.6.6.6，所以City3是最佳匹配；3.3.3.5同时匹配为City2=3.3.3.3,4.4.4.4和City3=2.2.2.2,6.6.6.6，但是City3=2.2.2.2,6.6.6.6的IP段范围更小，所以City3为最佳匹配；
18
ACM编程 语言限制 【200分】 标题：矩阵匹配 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
从一个N*M（N<=M)的矩阵中选出N个数，任意两个数字不能在同一行或同一列，求选出来的N个数中第K大的数字的最小值是多少。

输入描述:
输入矩阵要求：1<=K<=N<=M<=150
输入格式：
    N M K
    N*M矩阵
输出描述:
N*M的矩阵中可以选出M!/N!种组合数组，每个组合数组中第K大的数中的最小值。无需考虑重复数字，直接取字典排序结果即可。
备注:
注意：结果是第K大的数字的最小值
示例1
输入
3 4 2
1 5 6 6 
8 3 4 3
6 8 6 3
输出
3
说明
N*M的矩阵中可以选出M!/N!种组合数组，每个组合数组中第K大的数中的最小值；上述输入中选出的数组组合为1,3,6; 1,3,3; 1,4,8; 1,4,3;...... 
上述输入样例中选出的组合数组有24种，最小数组为1,3,3，则2大的最小值为3
19
ACM编程 语言限制 【200分】 标题：最小矩阵宽度 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
给定一个矩阵，包含N*M个整数，和一个包含K个整数的数组。
现在要求在这个矩阵中找一个宽度最小的子矩阵，要求子矩阵包含数组中所有的整数。
输入描述:
第一行输入两个正整数N，M，表示矩阵大小。
接下来N行M列表示矩阵内容。
下一行包含一个正整数K。
下一行包含K个整数，表示所需包含的数组，K个整数可能存在重复数字
所有输入数据小于1000。
输出描述:
输出包含一个整数，表示满足要求子矩阵的最小宽度，若找不到，输出-1.
示例1
输入
2 5
1 2 2 3 1
2 3 2 3 2
3
1 2 3
输出
2
说明
矩阵第0、3列包含了1、2、3，矩阵第3、4列包含了1、2、3
示例2
输入
2 5
1 2 2 3 1
1 3 2 3 4
3
1 1 4
输出
5
说明
矩阵第1、2、3、4、5列包含了1、1、4
20
ACM编程 语言限制 【200分】 标题：图像物体的边界 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
给定一个二维数组M行N列，二维数组里的数字代表图片的像素，为了简化问题，仅包含像素1和5两种像素，每种像素代表一个物体，2个物体相邻的格子为边界，求像素1代表的物体的边界个数。

像素1代表的物体的边界指与像素5相邻的像素1的格子，边界相邻的属于同一个边界，相邻需要考虑8个方向（上，下，左，右，左上，左下，右上，右下）。

其他约束：

地图规格约束为：

0<M<100

0<N<100


1）如下图，与像素5的格子相邻的像素1的格子（0,0）、（0,1）、（0,2）、（1,0）、（1,2）、（2,0）、（2,1）、（2,2）、（4,4）、（4,5）、（5,4）为边界，另（0,0）、（0,1）、（0,2）、（1,0）、（1,2）、（2,0）、（2,1）、（2,2）相邻，为1个边界，（4,4）、（4,5）、（5,4）相邻，为1个边界，所以下图边界个数为2。


2）如下图，与像素5的格子相邻的像素1的格子（0,0）、（0,1）、（0,2）、（1,0）、（1,2）、（2,0）、（2,1）、（2,2）、（3,3）、（3,4）、（3,5）、（4,3）、（4,5）、（5,3）、（5,4）、（5,5）为边界，另这些边界相邻，所以下图边界个数为1。注：（2,2）、（3,3）相邻。

输入描述:
第一行，行数M，列数N

第二行开始，是M行N列的像素的二维数组，仅包含像素1和5
输出描述:
像素1代表的物体的边界个数。如果没有边界输出0（比如只存在像素1，或者只存在像素5）。
示例1
输入
6  6
1 1 1 1 1 1
1 5 1 1 1 1
1 1 1 1 1 1
1 1 1 1 1 1
1 1 1 1 1 1
1 1 1 1 1 5
输出
2
说明
参考题目描述部分
示例2
输入
6  6
1 1 1 1 1 1
1 5 1 1 1 1
1 1 1 1 1 1
1 1 1 1 1 1
1 1 1 1 5 1
1 1 1 1 1 1
输出
1
说明
参考题目描述部分
21
ACM编程 语言限制 【200分】 标题：数组排列求和 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
1到n的n个连续的数字组成一个数组，n为3的倍数
每次按照顺序从数组中取出3个元素，去掉这3个元素中的一个最大值和一个最小值，并将剩下的元素累加为S，S初始值为0
可以通过调整数组中元素的位置改变最终结果，每移动一个元素计为移动一次。请计算最少移动几次可以使得数组和S最大。
输入描述:
数组长度n的范围为[3, 600]
数组中数字范围  [1, 10000]
数组由一个字符串表示，不同数字元素之间使用空格分隔
输出描述:
移动次数是一个自然数
无需移动，返回0
示例1
输入
1 8 9 7 4 2 5 6 3
输出
1
说明
3 8 9->8, 7 4 2->4, 5 6 1->5,  8+4+5=17， 将7移动到5 6 之间，调整结果为 3 8 9 4 2 5 7 6 1 ，3 8 9->8, 4 2 5->4, 7 6 1->6,  8+4+6=18， 18是所有排列中的最大值，输出1
示例2
输入
2 6 9 5 4 3 8 7 1
输出
2
说明
2 6 9->6, 5 4 3->4, 8 7 1->7,  6+4+7=17， 将9移动到8之前，7移动到6之后，调整结果为 2 6 7 5 4 3 9 8 1 ，2 6 7->6, 5 4 3->4, 9 8 1->8,  6+4+8=18， 18是所有排列中的最大值，输出2
22
ACM编程 语言限制 【200分】 标题：中文分词模拟器 | 时间限制：5秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
给定一个连续不包含空格字符串，该字符串仅包含英文小写字母及英文文标点符号(逗号、分号、句号)，同时给定词库，对该字符串进行精确分词。
说明：
1.精确分词： 字符串分词后，不会出现重叠。即“ilovechina” ，不同词库可分割为 “i，love，china” “ilove，china”，不能分割出现重叠的"i，ilove，china",i重叠出现
2.标点符号不成词，仅用于断句
3.词库：根据外部知识库统计出来的常用词汇例：dictionary=["i","love","china","lovechina","ilove"], 
4.分词原则：采用分词顺序优先且最长匹配原则
“ilovechina”，假设分词结果  [ i,ilove,lo,love,ch,china,lovechina ] 则输出 [ilove，china] 
 错误输出：[i,lovechina],            原因："ilove ">优先于 "lovechina"成词
 错误输出：[i,love,china]            原因："ilove" >"i"  遵循最长匹配原则


输入描述:
字符串长度限制：0<length<256
词库长度限制：  1<length<100000
第一行输入待分词语句 "ilovechina"
第二行输入中文词库   "i,love,china,ch,na,ve,lo,this,is,the,word"
输出描述:
按顺序输出分词结果 "i,love,china"
示例1
输入
ilovechina
i,love,china,ch,na,ve,lo,this,is,the,word
输出
i,love,china
示例2
输入
iat
i,love,china,ch,na,ve,lo,this,is,the,word,beauti,tiful,ful
输出
i,a,t
说明
单个字母，不在词库中且不成词则直接输出单个字母
示例3
输入
ilovechina,thewordisbeautiful
i,love,china,ch,na,ve,lo,this,is,the,word,beauti,tiful,ful
输出
i,love,china,the,word,is,beauti,ful
说明
标点符号为英文标点符号
23
ACM编程 语言限制 【200分】 标题：抢7游戏 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
A、B两个人玩抢7游戏，游戏规则为A先报一个起始数字X(10<起始数字<10000)，B报下一个数字Y(X-Y<3),A再报一个数字Z(Y-Z<3)，以此类推，直到其中一个抢到7，抢到7即为胜者；在B赢得比赛的情况下，一共有多少种组合？
输入描述:
起始数字M，如100；10<=M<=10000
输出描述:
B能赢得比赛的组合次数
示例1
输入
10
输出
1
24
ACM编程 语言限制 【200分】 标题：反射计数 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
给定一个包含 0 和 1 的二维矩阵

给定一个初始位置和速度

一个物体从给定的初始位置触发, 在给定的速度下进行移动, 遇到矩阵的边缘则发生镜面反射

无论物体经过 0 还是 1, 都不影响其速度

请计算并给出经过 t 时间单位后, 物体经过 1 点的次数

矩阵以左上角位置为[0, 0](列(x), 行(行)), 例如下面A点坐标为[2, 1] (第二列, 第一行)


+--------------------------- 递增(x)
| 0 0 1 0 0 0 0 1 0 0 0 0
| 0 0 1 0 0 0 0 1 0 0 0 0
| 0 0 1 0 0 0 0 1 0 0 0 0
| 0 0 1 0 0 0 0 1 0 0 0 0
| 0 0 1 0 0 0 0 1 0 0 0 0
| 0 0 1 0 0 0 0 1 0 0 0 0
| 0 0 1 0 0 0 0 1 0 0 0 0
|
递增(y)

注意:

如果初始位置的点是 1, 也计算在内
时间的最小单位为1, 不考虑小于 1 个时间单位内经过的点
输入描述:
第一行为初始信息

<w> <h> <x> <y> <sx> <sy> <t>

第二行开始一共h行, 为二维矩阵信息

其中

w, h为矩阵的宽和高
x, y为起始位置
sx, sy为初始速度
t为经过的时间

所有输入都是有效的, 数据范围如下

0 < w < 100
0 < h < 100
0 <= x < w
0 <= y < w
-1 <= sx <= 1
-1 <= sy <= 1
0 <= t < 100


输出描述:
经过1的个数

注意初始位置也要计算在内
示例1
输入
12 7 2 1 1 -1 13
001000010000
001000010000
001000010000
001000010000
001000010000
001000010000
001000010000
输出
3
说明
初始位置为(2, 1), 速度为(1, -1), 那么13个时间单位后, 经过点1的个数为3

25
ACM编程 语言限制 【200分】 标题：项目排期 | 时间限制：5秒 | 内存限制：32768K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
项目组共有N个开发人员，项目经理接到了M个独立的需求，每个需求的工作量不同，且每个需求只能由一个开发人员独立完成，不能多人合作。假定各个需求直接无任何先后依赖关系，请设计算法帮助项目经理进行工作安排，使整个项目能用最少的时间交付。
输入描述:
第一行输入为M个需求的工作量，单位为天，用逗号隔开。
例如：X1 X2 X3 .... Xm
表示共有M个需求，每个需求的工作量分别为X1天，X2天......Xm天。其中0<M<30；0<Xm<200
第二行输入为项目组人员数量N
例如：
5
表示共有5名员工，其中0<N<10
输出描述:
最快完成所有工作的天数
例如：
25
表示最短需要25天能完成所有工作
示例1
输入
6 2 7 7 9 3 2 1 3 11 4
2
输出
28
说明
共有两位员工，其中一位分配需求 6 2 7 7 3 2 1共需要28天完成，另一位分配需求 9 3 11 4 共需要27天完成，故完成所有工作至少需要28天。
26
ACM编程 语言限制 【200分】 标题：员工派遣 | 时间限制：1秒 | 内存限制：65536K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
某公司部门需要派遣员工去国外做项目。现在，代号为x的国家和代号为y的国家分别需要cntx名和cnty名员工。部门每个员工有一个员工号(1,2,3……)，工号连续，从1开始。

部长派遣员工的规则：

规则1、从[1,k]中选择员工派遣出去
规则2、编号为x的倍数的员工不能去x国，编号为y的倍数的员工不能去y国
问题：
找到最小的k，使得可以将编号在[1,k]中的员工分配给x国和y国，且满足x国和y国的需求

输入描述:
四个整数 x, y, cntx, cnty。(2<=x<y<=30000; x和y一定是质数;1<=cntx,cnty<10^9; cntx+cnty<=10^9）
输出描述:
满足条件的最小的k。
示例1
输入
2 3 3 1
输出
5
说明
输入说明：
2 -表示国家代号2
3 -表示国家代号3
3 -表示国家2需要3个人
1 -表示国家3需要1个人
27
ACM编程 语言限制 【200分】 标题：找城市 | 时间限制：1秒 | 内存限制：65536K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
一张地图上有n个城市，城市和城市之间有且只有一条道路相连：要么直接相连，要么通过其它城市中转相连（可中转一次或多次）。城市与城市之间的道路都不会成环。
当切断通往某个城市 i 的所有道路后，地图上将分为多个连通的城市群，设该城市 i 的聚集度为 DPi（Degree of Polymerization）,  DPi = max(城市群1的城市个数， 城市群2的城市个数, ... 城市群m的城市个数)。

请找出地图上 DP 值最小的城市（即找到城市 j，使得 DPj = min(DP1, DP2 ... DPn) )

提示：如果有多个城市都满足条件，这些城市都要找出来（可能存在多个解）
提示：DPi 的计算，可以理解为已知一棵树，删除某个节点后，生成的多个子树，求解多个子树节点数的问题。
输入描述:
每个样例：第一行有一个整数N，表示有N个节点。1<=N<=1000

接下来的N-1行每行有两个整数x,y，表示城市x与城市y连接。1<=x, y<=N
输出描述:
输出城市的编号。如果有多个，按照编号升序输出。

示例1
输入
5
1 2
2 3
3 4
4 5
输出
3
说明
输入表示的是如下地图：


对于城市3，切断通往3的所有道路后，形成2个城市群[（1,2）,（4,5）]，其聚集度分别都是2。DP3 = 2。 对于城市4，切断通往城市4的所有道路后， 形成2个城市群[ (1,2,3), (5) ]，DP4 = max（3, 1）= 3 。依次类推，切断其它城市的所有道路后，得到的DP都会大于2，因为城市3就是满足条件的城市，输出是3。
示例2
输入
6
1 2
2 3
2 5
3 4
3 6
输出
2 3
说明
输入表示的是如下地图：

切断通往2的所有道路后，形成3个城市群[（1）,（5），（3,4,6）]，其聚集度分别都是1、1、3，因此DP2 = 3。

切断通往3的所有道路后，形成3个城市群[（1，2,5）,（4），（,6）]，其聚集度分别都是3、1、1，因此DP3 = 3。

切断其它城市的所有道路后，得到的DP都会大于3，因为城市2、3就是满足条件的城市，升序排列输出是2 3

28
ACM编程 语言限制 【200分】 标题：音乐小说内容重复识别 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
实现一个简易的重复内容识别系统，通过给定的两个内容名称，和相似内容符号，判断两个内容是否相似；如果相似，返回相似的内容；如果不相似，返回不相似的内容

初始化：给出两个字符串，一些相似字符对，如顿号和逗号相似，的和de相似，猪和潴，给出两个字符串的相似判断结果
输入：两条语句，给出是否相似，对于相似的语句，返回True和相似的字符对；对于不相似的内容，则返回第一个内容的不相似信息，方便后续补充

 注意：
1、相似关系是 具有 传递性的。例如，如果 "顿号" 和 "逗号" 是相似的，"逗号" 和 "分号" 是相似的，则 "顿号" 和 "逗号" 是相似的。
2、为了过滤一些无意义的信息，这里***可以匹配任意长度的内容，
例如：给出相似对 "(***)",""时，'异世邪君（人气玄幻作家）'和'异世邪君' 认为是相似，此时相似符号返回 *** 即可
3、不相似的内容，需要给出不相似的字符串，多处不相似的字符串用空格分隔

输入描述:
第一行表示第一张专辑的专辑名，其中  0<专辑长度<= 50

第二行表示第二张专辑的专辑名，其中  0<专辑长度<= 50

第三行开始每行为相似的字符串，每行为一组，每组字符串不超过10个

总共相似字符串行不超过10行

输出描述:
第一行返回相似判断的结果，即True或者False
第二行开始返回相似/不相似的字符串，每行一组
示例1
输入
林汉达上下五千年
林汉达上下5千年
五 5 ⑤ 伍 wu
输出
True
五 5
示例2
输入
幸福de猪的个人专辑
幸福的猪的个人专辑
得 的
得 de
输出
True
de 的
示例3
输入
异世邪君(人气玄幻作家)
异世邪君
(***)
输出
True
(***)
示例4
输入
浩然爸爸讲成语
浩然爸爸讲论语
论语 三字经
输出
False
成语 论语
29
ACM编程 语言限制 【200分】 标题：两个字符串间的最短路径问题 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
给定两个字符串，分别为字符串A与字符串B。例如A字符串为ABCABBA，B字符串为CBABAC可以得到下图m*n的二维数组，定义原点为(0, 0)，终点为(m, n)，水平与垂直的每一条边距离为1，映射成坐标系如下图。
从原点(0, 0)到(0, A)为水平边，距离为1，从(0, A)到(A, C)为垂直边，距离为1；假设两个字符串同一位置的两个字符相同则可以作一个斜边，如(A, C)到(B, B)最短距离为斜边，距离同样为1。
作出所有的斜边如下图，(0, 0)到(B, B)的距离为 1个水平边 + 1个垂直边 + 1个斜边 = 3。

根据定义可知，原点到终点的最短距离路径如下图红线标记，最短距离为9：

输入描述:
空格分割的两个字符串A与字符串B，字符串不为“空串”，字符格式满足正则规则：[A-Z]，字符串长度 < 10000
输出描述:
原点到终点的最短距离
示例1
输入
ABC ABC
输出
3
示例2
输入
ABCABBA CBABAC
输出
9
30
ACM编程 语言限制 【200分】 标题：解密犯罪时间 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
警察在侦破一个案件时，得到了线人给出的可能犯罪时间，形如 “HH:MM” 表示的时刻。

根据警察和线人的约定，为了隐蔽，该时间是修改过的，解密规则为：利用当前出现过的数字，构造下一个距离当前时间最近的时刻，则该时间为可能的犯罪时间。每个出现数字都可以被无限次使用。
输入描述:
形如HH:SS的字符串，表示原始输入
输出描述:
形如HH:SS的字符串，表示推理出来的犯罪时间
备注:
1.    可以保证线人给定的字符串一定是合法的。例如，“01:35” 和 “11:08” 是合法的，“1:35” 和 “11:8” 是不合法的。

2.    最近的时刻有可能在第二天。

示例1
输入
18:52
输出
18:55
说明
利用数字1, 8, 5, 2构造出来的最近时刻是18:55，是3分钟之后。结果不是18:51因为这个时刻是23小时59分钟之后。
示例2
输入
23:59
输出
22:22
说明
利用数字2, 3, 5, 9构造出来的最近时刻是22:22。 答案一定是第二天的某一时刻，所以选择可构造的最小时刻为犯罪时间。
31
ACM编程 语言限制 【200分】 标题：寻找最优的路测线路 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
评估一个网络的信号质量，其中一个做法是将网络划分为栅格，然后对每个栅格的信号质量计算。路测的时候，希望选择一条信号最好的路线（彼此相连的栅格集合）进行演示。现给出R行C列的整数数组Cov，每个单元格的数值S即为该栅格的信号质量（已归一化，无单位，值越大信号越好）。

要求从[0, 0]到[R-1, C-1]设计一条最优路测路线。返回该路线得分。
规则：

1.     路测路线可以上下左右四个方向，不能对角。
2.     路线的评分是以路线上信号最差的栅格为准的，例如路径8→4→5→9的值为 4，该线路评分为4。线路最优表示该条线路的评分最高。
输入描述:
第一行表示栅格的行数R

第二行表示栅格的列数C

第3行开始，每一行表示栅格地图一行的信号值，如5 4 5
输出描述:
最优路线的得分
备注:
1.    1<= R, C <= 20

2.    0<= S <= 65535

示例1
输入
3
3
5 4 5
1 2 6
7 4 6
输出
4
说明
路线为：5→4→5→6→6
示例2
输入
6
5
3 4 6 3 4
0 2 1 1 7
8 8 3 2 7
3 2 4 9 8
4 1 2 0 0
4 6 5 4 3
输出
3
说明
路线为：3→4→6→3→4→7→7→8→9→4→3→8→8→3→4→4→6→5→4→3
32
ACM编程 语言限制 【200分】 标题：文件缓存系统 | 时间限制：2秒 | 内存限制：32768K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)

请设计一个文件缓存系统，该文件缓存系统可以指定缓存的最大值（单位为字节）。

文件缓存系统有两种操作：存储文件(put)和读取文件(get)

操作命令为put fileName fileSize或者get fileName

存储文件是把文件放入文件缓存系统中；读取文件是从文件缓存系统中访问已存在的文件，如果文件不存在，则不作任何操作。

当缓存空间不足以存放新的文件时，根据规则删除文件，直到剩余空间满足新的文件大小为止，再存放新文件。
具体的删除规则为：
文件访问过后，会更新文件的最近访问时间和总的访问次数，当缓存不够时，按照第一优先顺序为访问次数从少到多，第二顺序为时间从老到新的方式来删除文件。

输入描述:
第一行为缓存最大值m(整数，取值范围为0 < m <= 52428800)；

第二行为文件操作序列个数n(0 <= n <= 300000
从第三行起为文件操作序列，每个序列单独一行
文件操作定义为"op file_namefile_size"
file_name是文件名，file_size是文件大小
输出描述:
输出当前文件缓存中的文件名列表，文件名用英文逗号分隔，按字典顺序排序
如：
a,c

如果文件缓存中没有文件，则输出NONE

备注:
1.  如果新文件的文件名和文件缓存中已有的文件名相同，则不会放在缓存中

2.  新的文件第一次存入到文件缓存中时，文件的总访问次数不会变化，文件的最近访问时间会更新到最新时间

3.  每次文件访问后，总访问次数加1，最近访问时间更新到最新时间

4.  任何两个文件的最近访问时间不会重复

5.  文件名不会为空，均为小写字母，最大长度为10。

6.  缓存空间不足时，不能存放新文件

7.  每个文件大小都是大于0的整数

示例1
输入
50
6
put a 10
put b 20
get a
get a
get b
put c 30
输出
a,c
示例2
输入
50
1
get file
输出
NONE
33
ACM编程 语言限制 【200分】 标题：查找一个有向网络的头节点和尾节点 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
给定一个有向图，图中可能包含有环，图使用二维矩阵表示，每一行的第一列表示起始节点，第二列表示终止节点，如[0, 1]表示从0到1的路径。每个节点用正整数表示。求这个数据的首节点与尾节点，题目给的用例会是一个首节点，但可能存在多个尾节点。同时，图中可能含有环。如果图中含有环，返回[-1]。
说明：入度为0是首节点，出度为0是尾节点。



输入描述:
第一行为后续输入的键值对数量N>=0，第二行为2N个数字。每两个为一个起点，一个终点。如：

输出描述:
输出一行头节点和尾节点。如果有多个尾节点，按从大到小的顺序输出。

备注:
如果图有环，输出为-1.
所有输入均合法，不会出现不配对的数据
示例1
输入
4
0 1 0 2 1 2 2 3
输出
0 3
示例2
输入
2
0 1 0 2
输出
0 1 2
34
ACM编程 语言限制 【200分】 标题：字符串拼接 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
给定M(0<M<=30)个字符（a-z），从中取出任意字符（每个字符只能用一次）拼接成长度为N(0<N<=5)的字符串，要求相同的字符不能相邻，计算出给定的字符列表能拼接出多少种满足条件的字符串，输入非法或者无法拼接出满足条件的字符串则返回0。
输入描述:
给定的字符列表和结果字符串长度，中间使用空格（" "）拼接
输出描述:
满足条件的字符串个数
示例1
输入
abc 1
输出
3
说明
给定的字符为a,b,c，结果字符串长度为1，可以拼接成a,b,c，共3种
示例2
输入
dde 2
输出
2
说明
给定的字符为dde，结果字符串长度为2，可以拼接成de,ed，共2种
35
ACM编程 语言限制 【200分】 标题：符号运算 | 时间限制：1秒 | 内存限制：32768K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
给定一个表达式，求其分数计算结果 
 
表达式的限制如下：

1. 所有的输入数字皆为正整数(包括0)
2. 仅支持四则运算(+-*/)和括号
3. 结果为整数或分数, 分数必须化为最简格式(比如6, 3/4, 7/8, 90/7)
4. 除数可能为0，如果遇到这种情况，直接输出"ERROR"
5. 输入和最终计算结果中的数字都不会超出整型范围

用例的输入一定合法, 不会出现括号不匹配的情况

输入描述:
字符串格式的表达式，仅支持+-*/，数字可能超过两位，可能带有空格，没有负数

长度小于200个字符
输出描述:
表达式结果，以最简格式表达
如果结果为整数，那么直接输出整数
如果结果为分数，那么分子分母不可再约分，可以为假分数，不可表达为带分数
结果可能是负数, 负号放在最前面
示例1
输入
1 + 5 * 7 / 8
输出
43/8
示例2
输入
1 / (0 - 5)
输出
-1/5
说明
负号需要提到最前面
示例3
输入
1 * (3*4/(8-(7+0)))
输出
12
说明
注意括号可以多重嵌套
36
ACM编程 语言限制 【200分】 标题：简易内存池 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
请实现一个简易内存池,根据请求命令完成内存分配和释放。
内存池支持两种操作命令，REQUEST和RELEASE，其格式为：
REQUEST=请求的内存大小 表示请求分配指定大小内存，如果分配成功，返回分配到的内存首地址；如果内存不足，或指定的大小为0，则输出error。
RELEASE=释放的内存首地址 表示释放掉之前分配的内存，释放成功无需输出，如果释放不存在的首地址则输出error。
注意：
1.内存池总大小为100字节。
2.内存池地址分配必须是连续内存，并优先从低地址分配。
3.内存释放后可被再次分配，已释放的内存在空闲时不能被二次释放。
4.不会释放已申请的内存块的中间地址。
5.释放操作只是针对首地址所对应的单个内存块进行操作，不会影响其它内存块。
输入描述:
·        首行为整数N ,表示操作命令的个数，取值范围：0 < N <= 100。

接下来的N行,每行将给出一个操作命令，操作命令和参数之间用 “=”分割。
输出描述:
见题面输出要求

示例1
输入
2
REQUEST=10
REQUEST=20
输出
0
10
示例2
输入
5
REQUEST=10
REQUEST=20
RELEASE=0
REQUEST=20
REQUEST=10
输出
0
10
30
0
说明
第一条指令，申请地址0~9的10个字节内存，返回首地址0
第二条指令，申请地址10~29的20字节内存，返回首地址10
第三条指令，释放首地址为0的内存申请，0~9地址内存被释放，变为空闲，释放成功，无需输出
第四条指令，申请20字节内存，0~9地址内存连续空间不足20字节，往后查找到30~49地址，返回首地址30
第五条指令，申请10字节，0~9地址内存空间足够，返回首地址0
37
ACM编程 语言限制 【200分】 标题：最长的指定瑕疵度的元音子串 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
开头和结尾都是元音字母（aeiouAEIOU）的字符串为 元音字符串 ，其中混杂的非元音字母数量为其 瑕疵度 。比如:

·         “a” 、 “aa”是元音字符串，其瑕疵度都为0

·         “aiur”不是元音字符串（结尾不是元音字符）

·         “abira”是元音字符串，其瑕疵度为2

给定一个字符串，请找出指定瑕疵度的最长元音字符子串，并输出其长度，如果找不到满足条件的元音字符子串，输出0。

子串：字符串中任意个连续的字符组成的子序列称为该字符串的子串。

输入描述:
首行输入是一个整数，表示预期的瑕疵度flaw，取值范围[0, 65535]。
接下来一行是一个仅由字符a-z和A-Z组成的字符串，字符串长度(0, 65535]。
输出描述:
输出为一个整数，代表满足条件的元音字符子串的长度。

示例1
输入
0
asdbuiodevauufgh
输出
3
说明
 满足条件的最长元音字符子串有两个，分别为uio和auu，长度为3。

示例2
输入
2
aeueo
输出
0
说明
没有满足条件的元音字符子串，输出0
示例3
输入
1
aabeebuu
输出
5
说明
满足条件的最长元音字符子串有两个，分别为aabee和eebuu，长度为5
38
ACM编程 语言限制 【200分】 标题：快递员的烦恼 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
快递公司每日早晨，给每位快递员推送需要送到客户手中的快递以及路线信息，快递员自己又查找了一些客户与客户之间的路线距离信息，请你依据这些信息，给快递员设计一条最短路径，告诉他最短路径的距离。

注意：

1.     不限制快递包裹送到客户手中的顺序，但必须保证都送到客户手中

2.     用例保证一定存在投递站到每位客户之间的路线，但不保证客户与客户之间有路线，客户位置及投递站均允许多次经过

3.     所有快递送完后，快递员需回到投递站

输入描述:
首行输入两个正整数n、m

接下来n行，输入快递公司发布的客户快递信息，格式为：客户id 投递站到客户之间的距离distance

再接下来的m行，是快递员自行查找的客户与客户之间的距离信息，格式为：客户1id 客户2id distance

在每行数据中，数据与数据之间均以单个空格分割

规格：

0 < n <= 10

0 <= m <= 10

0 < 客户id <= 1000

0 < distance <= 10000

输出描述:
最短路径距离，如无法找到，请输出-1

示例1
输入
2 1
1 1000
2 1200
1 2 300
输出
2500
说明
路径1：快递员先把快递送到客户1手中，接下来直接走客户1到客户2之间的直通线路，最后走投递站和客户2之间的路，回到投递站，距离为1000 + 300 + 1200 = 2500

路径2：快递员先把快递送到客户1手中，接下来回到快递站，再出发把客户2的快递送过去，再回到投递站，距离为1000 + 1000 + 1200 + 1200 = 4400

路径3：快递员先把快递送到客户2手中，接下来直接走客户2到客户1之间的直通线路，最后走投递站和客户1之间的路，回到投递站，距离为1200 + 300 + 1000 = 2500

其他路径……

所有路径中，最短路径距离为2500

示例2
输入
5 1
5 1000
9 1200
17 300
132 700
500 2300
5 9 400
输出
9200
说明
在所有可行的路径中，最短路径长度为1000 + 400 + 1200 + 300 + 300 + 700 + 700 + 2300 + 2300 = 9200

39
ACM编程 语言限制 【200分】 标题：文本统计分析 | 时间限制：1秒 | 内存限制：32768K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
有一个文件, 包含以一定规则写作的文本, 请统计文件中包含的文本数量


规则如下

1. 文本以";"分隔，最后一条可以没有";"，但空文本不能算语句，比如"COMMAND A; ;"只能算一条语句.
    注意, 无字符/空白字符/制表符都算作"空"文本
2. 文本可以跨行, 比如下面, 是一条文本, 而不是三条
    COMMAND A
        AND
    COMMAND B;
3. 文本支持字符串, 字符串为成对的单引号(')或者成对的双引号("), 字符串可能出现用转义字符(\)处理的单双引号(比如"your input is: \"")和转义字符本身, 比如
    COMMAND A "Say \"hello\"";
4. 支持注释, 可以出现在字符串之外的任意位置, 注释以"--"开头, 到换行结束, 比如
    COMMAND A; -- this is comment
    COMMAND -- comment
              A AND COMMAND B;
     注意, 字符串内的"--", 不是注释

输入描述:
文本文件
输出描述:
包含的文本数量
示例1
输入
COMMAND TABLE IF EXISTS "UNITED STATE";
COMMAND A GREAT (
    ID ADSAB,
    download_length INTE-GER,  -- test
    file_name TEXT,
    guid TEXT,
    mime_type TEXT,
    notifica-tionid INTEGER,
    original_file_name TEXT,
    pause_reason_type INTEGER,
    resumable_flag INTEGER,
    start_time INTEGER,
    state INTEGER,
    folder TEXT,
    path TEXT,
    total_length INTE-GER,
    url TEXT
);
输出
2
40
ACM编程 语言限制 【200分】 标题：加密算法 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), JavaScript V8(6.0.0), Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), C++14(g++5.4), bash(GNU bash4.3.46), pypy2(pypy2.7.13), pypy3(pypy3.6.1)
有一种特殊的加密算法，明文为一段数字串，经过密码本查找转换，生成另一段密文数字串。规则如下：

1.   明文为一段数字串由0~9组成

2.   密码本为数字0~9组成的二维数组

3.   需要按明文串的数字顺序在密码本里找到同样的数字串，密码本里的数字串是由相邻的单元格数字组成，上下和左右是相邻的，注意：对角线不相邻，同一个单元格的数字不能重复使用。

4.   每一位明文对应密文即为密码本中找到的单元格所在的行和列序号（序号从0开始）组成的两个数字。如明文 第i位Data[i] 对应密码本单元格为Book[x][y]，则明文第i位对应的密文为X Y，X和Y之间用空格隔开。如果有多条密文，返回字符序最小的密文。如果密码本无法匹配，返回”error”。

请你设计这个加密程序。



输入描述:
第一行输入1个正整数N，代表明文的长度(1 <= N <= 200)

第二行输入N个明文数字组织的序列Data[i]，(整数，0 <= Data[i] <= 9)

第三行输入1个正整数M，(1 <= M <= 200)

接下来输入一个M * M的矩阵代表密码本Book[i][j]，(整数，0<=Book[i][j] <= 9)

输出描述:
如明文 第i位Data[i]对应密码本单元格为Book[x][y]，则明文第i位对应的密文为X Y，X和Y之间用空格隔开。如果有多条密文，返回字符序最小的密文。如果密码本无法匹配，返回”error”。
示例1
输入
2
0 3
3
0 0 2
1 3 4
6 6 4
输出
0 1 1 1
示例2
输入
2
0 5
3
0 0 2
1 3 4
6 6 4
输出
error
说明
找不到0 5的序列，返回error
41
ACM编程 语言限制 【200分】 标题：启动多任务排序 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
一个应用启动时，会有多个初始化任务需要执行，并且任务之间有依赖关系，例如A任务依赖B任务，那么必须在B任务执行完成之后，才能开始执行A任务。

现在给出多条任务依赖关系的规则，请输入任务的顺序执行序列，规则采用贪婪策略，即一个任务如果没有依赖的任务，则立刻开始执行，如果同时有多个任务要执行，则根据任务名称字母顺序排序。

例如：B任务依赖A任务，C任务依赖A任务，D任务依赖B任务和C任务，同时，D任务还依赖E任务。那么执行任务的顺序由先到后是：A任务，E任务，B任务，C任务，D任务。这里A和E任务都是没有依赖的，立即执行

输入描述:
输入参数每个元素都表示任意两个任务之间的依赖关系，输入参数中符号“->”表示依赖方向，例如A->B表示A依赖B，多个依赖之间用单个空格分割
输出描述:
输出为排序后的启动任务列表，多个任务之间用单个空格分割
示例1
输入
A->B C->B
输出
B A C
说明
输入参数每个元素都表示任意两个任务之间的依赖关系，输入参数中符号“->”表示依赖方向，例如A->B表示A依赖B，多个依赖之间用单个空格分割，输出的多个任务之间也用单个空格分割
42
ACM编程 语言限制 【200分】 标题：欢乐的周末 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
小华和小为是很要好的朋友，他们约定周末一起吃饭。通过手机交流，他们在地图上选择了多个聚餐地点（由于自然地形等原因，部分聚餐地点不可达），求小华和小为都能到达的聚餐地点有多少个？
输入描述:
第一行输入m和n，m代表地图的长度，n代表地图的宽度。
第二行开始具体输入地图信息，地图信息包含：
0 为通畅的道路
1 为障碍物（且仅1为障碍物）
2 为小华或者小为，地图中必定有且仅有2个 （非障碍物）
3 为被选中的聚餐地点（非障碍物）

输出描述:
可以被两方都到达的聚餐地点数量，行末无空格。
备注:
地图的长宽为m和n，其中：
4 <= m <= 100
4 <= n <= 100

聚餐的地点数量为 k，则 
1< k <= 100
示例1
输入
4 4
2 1 0 3
0 1 2 1
0 3 0 0
0 0 0 0
输出
2
说明
第一行输入地图的长宽为3和4。
第二行开始为具体的地图，其中：3代表小华和小明选择的聚餐地点；2代表小华或者小明（确保有2个）；0代表可以通行的位置；1代表不可以通行的位置。

此时两者能都能到达的聚餐位置有2处
示例2
输入
4 4
2 1 2 3
0 1 0 0
0 1 0 0
0 1 0 0
输出
0
说明
第一行输入地图的长宽为4和4。
第二行开始为具体的地图，其中：3代表小华和小明选择的聚餐地点；2代表小华或者小明（确保有2个）；0代表可以通行的位置；1代表不可以通行的位置。

由于图中小华和小为之间有个阻隔，此时，没有两人都能到达的聚餐地址，故而返回0
43
ACM编程 语言限制 【200分】 标题：Wonderland | 时间限制：1秒 | 内存限制：65536K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
Wonderland是小王居住地一家很受欢迎的游乐园。 Wonderland目前有4种售票方式，分别为一日票（1天）、三日票（3天）、周票（7天）和月票（30天）。

每种售票方式的价格将由一个数组给出，每种票据在票面时限内可以无限制的进行游玩。例如，小王在第10日买了一张三日票，小王可以在第10日、第11日和第12日进行无限制的游玩。 

小王计划在接下来一年内多次游玩该游乐园。小王计划的游玩日期将由一个数组给出。 现在，请您根据给出的售票价格数组和小王计划游玩日期数组，返回完成游玩计划所需要的最低消费。

输入描述:
输入为2个数组

售票价格数组为costs，costs.length=4,默认顺序为一日票、三日票、周票和月票。

小王计划游玩日期数组为days，1<=days.length<=365,1<=days[i]<=365,默认顺序为升序。


输出描述:
完成游玩计划的最低消费
备注:
样例说明：
根据售票价格数组和游玩日期数组给出的信息，发现每次去玩的时候买一张一日票是最省钱的，所以小王会买8张一日票，每张5元，最低花费是40元。
示例1
输入
5 14 30 100
1 3 15 20 21 200 202 230
输出
40
44
ACM编程 语言限制 【200分】 标题：考古学家 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
有一个考古学家发现一个石碑，但是很可惜，发现时其已经断成多段，原地发现n个断口整齐的石碑碎片。为了破解石碑内容，考古学家希望有程序能帮忙计算复原后的石碑文字组合数，你能帮忙吗？
输入描述:
第一行输入n，n表示石碑碎片的个数。
第二行依次输入石碑碎片上的文字内容s，共有n组。    
输出描述:
输出石碑文字的组合（按照升序排列），行末无多余空格。
备注:
如果存在石碑碎片内容完全相同，则由于碎片间的顺序变换不影响复原后的碑文内容，即相同碎片间的位置变换不影响组合。
示例1
输入
3
a b c
输出
abc
acb
bac
bca
cab
cba
说明
当石碑碎片上的内容为“a”，“b”，“c”时，则组合有“abc”，“acb”，“bac”，“bca”，“cab”，“cba”
示例2
输入
3
a b a
输出
aab
aba
baa
说明
当石碑碎片上的内容为“a”，“b”，“a”时，则可能的组合有“aab”，“aba”，“baa”
示例3
输入
3
a b ab
输出
aabb
abab
abba
baab
baba
说明
当石碑碎片上的内容为“a”，“b”，“ab”时，则可能的组合有“aabb”，“abab”，“abba”，“baab”，“baba”
45
ACM编程 语言限制 【200分】 标题：任务处理 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
在某个项目中有多个任务（用 tasks 数组表示）需要您进行处理，其中 tasks[i] = [si, ei]，你可以在 si <= day <= ei 中的任意一天处理该任务。请返回你可以处理的最大任务数。
注：一天可以完成一个任务的处理。
输入描述:
第一行为任务数量 n，1 <= n <= 100000。后面 n 行表示各个任务的开始时间和终止时间，用 si 和 ei 表示，1 <= si <= ei <= 100000。
输出描述:
输出为一个整数，表示可以处理的最大任务数。
备注:

示例1
输入
3
1 1
1 2
1 3
输出
3
说明
第一天处理任务 1，第二天处理任务 2，第三天处理任务 3。
46
ACM编程 语言限制 【200分】 标题：跳马 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), JavaScript V8(6.0.0), Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), C++14(g++5.4), bash(GNU bash4.3.46), pypy2(pypy2.7.13), pypy3(pypy3.6.1)
马是象棋(包括中国象棋和国际象棋)中的棋子，走法是每步直一格再斜一格，即先横着或直着走一格，然后再斜着走一个对角线，可进可退，可越过河界，俗称“马走‘日’字。

给顶m行n列的棋盘（网格图），棋盘上只有有棋子象棋中的棋子“马”，并且每个棋子有等级之分，等级为k的马可以跳1~k步（走的方式与象棋中“马”的规则一样，不可以超出棋盘位置），问是否能将所有马跳到同一位置，如果存在，输出最少需要的总步数（每匹马的步数相加），不存在则输出-1。

注：允许不同的马在跳的过程中跳到同一位置，坐标为(x,y)的马跳一次可以跳到到坐标为(x+1, y+2), (x+1, y-2), (x+2, y+1), (x+2, y-1), (x-1, y+2), (x-1, y-2), (x-2, y+1), (x-2, y-1),的格点上，但是不可以超出棋盘范围。

输入描述:
第一行输入m,n代表m行n列的网格图棋盘(1 ≤ m, n ≤ 25)；

接下来输入m行n列的网格图棋盘，如果第i行,第j列的元素为”.”代表此格点没有棋子，如果为数字k（1<=k<=9），代表此格点存在等级为k的“马”；

输出描述:
输出最少需要的总步数（每匹马的步数相加），不存在则输出-1。

示例1
输入
3 2
..
2.
..
输出
0
说明
只有一匹马，不需要跳动
示例2
输入
3 5
47.48
4744.
7....
输出
17
47
ACM编程 语言限制 【200分】 标题：部门人力分配 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
部门在进行需求开发时需要进行人力安排。当前部门需要完成N个需求，需求用requirements[]表示，requirements[i]表示第i个需求的工作量大小，单位：人月。
这部分需求需要在M个月内完成开发，进行人力安排后每个月的人力是固定的。

目前要求每个月最多有2个需求开发，并且每个月需要完成的需求不能超过部门人力。请帮部门评估在满足需求开发进度的情况下，
每个月需要的最小人力是多少？
输入描述:
输入第一行为M和requirements，M表示需要开发时间要求，requirements表示每个需求工作量大小，N为requirements长度
1 <= N/2 <= M <= N <= 10^4
1 <= requirements[i] <= 10^9
输出描述:
对于每组测试数据，输出部门需要人力需求，行末无多余空格
示例1
输入
3
3 5 3 4
输出
6
说明
输入数据两行，第一行输入数据3表示开发时间要求，第二行输入数据表示需求工作量大小，输出数据一行，表示部门人力需求
48
完善核心代码 语言限制 【200分】 标题：会议室占用时间 | 时间限制：1秒 | 内存限制：262144K
限定语言：不限
现有若干个会议，所有会议共享一个会议室，用数组表示每个会议的开始时间和结束时间，格式：[[会议1开始时间，会议1结束时间], [会议2开始时间，会议2结束时间]]。请计算会议室占用时间段。

备注:
会议室个数范围：[1, 100]
会议室时间段：[1, 24]
示例1
输入
[[1,4],[2,5],[7,9],[14,18]]
输出
[[1,5],[7,9],[14,18]]
说明
时间段 [1,4] 和 [2,5] 重叠, 合并为 [1,5]
示例2
输入
[[1,4],[4,5]]
输出
[[1,5]]
说明
时间段 [1,4] 和 [4,5] 连续
49
ACM编程 语言限制 【200分】 标题：电脑病毒感染 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), JavaScript V8(6.0.0), Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), C++14(g++5.4), bash(GNU bash4.3.46), pypy2(pypy2.7.13), pypy3(pypy3.6.1)
一个局域网内有很多台电脑，分别标注为0 - N-1的数字。相连接的电脑距离不一样，所以感染时间不一样，感染时间用t表示。
其中网络内一个电脑被病毒感染，其感染网络内所有的电脑需要最少需要多长时间。如果最后有电脑不会感染，则返回-1
给定一个数组times表示一个电脑把相邻电脑感染所用的时间。
如图：path[i]= {i,j, t} 表示电脑i->j 电脑i上的病毒感染j，需要时间t。

输入描述:
4
3
2 1 1
2 3 1
3 4 1
2
输出描述:
2
备注:
第一个参数:局域网内电脑个数N 1<=N<=200;
第二个参数：总共多少条网络连接
第三个 1 2 1 表示1->2时间为1
第七行：表示病毒最开始所在的电脑号1
示例1
输入
4
3
2 1 1
2 3 1
3 4 1
2
输出
2
50
ACM编程 语言限制 【200分】 标题：二叉树的广度优先遍历 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
有一棵二叉树，每个节点由一个大写字母标识(最多26个节点）。现有两组字母，分别表示后序遍历（左孩子->右孩子->父节点）和中序遍历（左孩子->父节点->右孩子）的结果，请输出层次遍历的结果。
输入描述:
输入为两个字符串，分别是二叉树的后续遍历和中序遍历结果。
输出描述:
输出二叉树的层次遍历结果。
示例1
输入
CBEFDA CBAEDF
输出
ABDCEF
说明
二叉树为：
    A
   / \
  B   D
 /   / \
C   E   F




51
ACM编程 语言限制 【200分】 标题：可以组成网络的服务器 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
在一个机房中，服务器的位置标识在 n*m 的整数矩阵网格中，1 表示单元格上有服务器，0 表示没有。如果两台服务器位于同一行或者同一列中紧邻的位置，则认为它们之间可以组成一个局域网。
请你统计机房中最大的局域网包含的服务器个数。
输入描述:
第一行输入两个正整数，n和m，0<n,m<=100
之后为n*m的二维数组，代表服务器信息
输出描述:
最大局域网包含的服务器个数。
示例1
输入
2 2
1 0
1 1
输出
3
说明
[0][0]、[1][0]、[1][1]三台服务器相互连接，可以组成局域网
52
ACM编程 语言限制 【200分】 标题：结队编程 | 时间限制：3秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), JavaScript V8(6.0.0), Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), C++14(g++5.4), bash(GNU bash4.3.46), pypy2(pypy2.7.13), pypy3(pypy3.6.1)
某部门计划通过结队编程来进行项目开发，已知该部门有N名员工，每个员工有独一无二的职级，每三个员工形成一个小组进行结队编程，结队分组规则如下：


从部门中选出序号分别为 i、j、k 的 3 名员工，他们的职级分别为 level[i]、level [j]、level [k]

结队小组需满足： level [i] < level [j] < level [k] 或者 level [i] > level [j] > level [k] ，其中  0 <= i < j < k < n

请你按上述条件计算可能组合的小组数量。同一员工可以参加多个小组。

输入描述:
第一行输入：员工总数n
第二行输入：按序号依次排列的员工的职级level，中间用空格隔开
限制：

1 <= n <= 6000

1 <= level[i] <= 10^5


输出描述:
可能组合的小组数量
示例1
输入
4
1 2 3 4
输出
4
说明
可能结队成的组合 (1,2,3)、(1,2,4)、(1,3,4)、(2,3,4)
示例2
输入
3
5 4 7
输出
0
说明
根据结队条件，我们无法为该部门组建小组
53
ACM编程 语言限制 【200分】 标题：模拟目录管理 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), JavaScript V8(6.0.0), Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), C++14(g++5.4), bash(GNU bash4.3.46), pypy2(pypy2.7.13), pypy3(pypy3.6.1)
实现一个模拟目录管理功能的软件，输入一个命令序列，输出最后一条命令运行结果。
支持命令：
 1）创建目录命令：mkdir 目录名称，如mkdir abc为在当前目录创建abc目录，如果已存在同名目录则不执行任何操作。此命令无输出。
 2）进入目录命令：cd 目录名称, 如cd abc为进入abc目录，特别地，cd ..为返回上级目录，如果目录不存在则不执行任何操作。此命令无输出。
 3）查看当前所在路径命令：pwd，输出当前路径字符串。
约束：
 1）目录名称仅支持小写字母；mkdir和cd命令的参数仅支持单个目录，如：mkdir abc和cd abc；不支持嵌套路径和绝对路径，如mkdir abc/efg, cd abc/efg, mkdir /abc/efg, cd /abc/efg是不支持的。
 2）目录符号为/，根目录/作为初始目录。
 3）任何不符合上述定义的无效命令不做任何处理并且无输出。
输入描述:
输入N行字符串，每一行字符串是一条命令。
输出描述:
输出最后一条命令运行结果字符串。
备注:
命令行数限制100行以内，目录名称限制10个字符以内。
示例1
输入
mkdir abc
cd abc
pwd
输出
/abc/
说明
在根目录创建一个abc的目录并进入abc目录中查看当前目录路径，输出当前路径/abc/。
54
完善核心代码 语言限制 【200分】 标题：路口最短时间问题 | 时间限制：1秒 | 内存限制：262144K
限定语言：不限
假定街道是棋盘型的，每格距离相等，车辆通过每格街道需要时间均为 timePerRoad；街道的街口（交叉点）有交通灯，灯的周期T(=lights[row][col])各不相同；车辆可直行、左转和右转，其中直行和左转需要等相应T时间的交通灯才可通行，右转无需等待。
现给出 n*m 个街口的交通灯周期，以及起止街口的坐标，计算车辆经过两个街口的最短时间。
其中：
1）起点和终点的交通灯不计入时间，且可以任意方向经过街口
2）不可超出 n*m 个街口，不可跳跃，但边线也是道路（即 lights[0][0] -> lights[0][1] 是有效路径）

入口函数定义:
/**
* lights : n*m 个街口每个交通灯的周期，值范围[0,120]，n和m的范围为[1,9]
* timePerRoad : 相邻两个街口之间街道的通过时间,范围为[0,600]
* rowStart : 起点的行号
* colStart : 起点的列号
* rowEnd : 终点的行号
* colEnd : 终点的列号
* return : lights[rowStart][colStart] 与 lights[rowEnd][colEnd] 两个街口之间的最短通行时间
*/
int calcTime(int[][] lights,int timePerRoad,int rowStart,int colStart,int rowEnd,int colEnd)

示例1
输入
[[1,2,3],[4,5,6],[7,8,9]],60,0,0,2,2
输出
245
说明
行走路线为 (0,0) -> (0,1) -> (1,1) -> (1,2) -> (2,2) 走了4格路，2个右转，1个左转，共耗时 60+0+60+5+60+0+60=245
55
ACM编程 语言限制 【200分】 标题：找数字 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), JavaScript V8(6.0.0), Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), C++14(g++5.4), bash(GNU bash4.3.46), pypy2(pypy2.7.13), pypy3(pypy3.6.1)
小扇和小船今天又玩起来了数字游戏，小船给小扇一个正整数n (1<=n<=1e9)，小扇需要找到一个比n大的数字m，使得m和n对应的二进制中1的个数要相同（如4对应二进制100,8对应二进制1000,1的个数都为1），现在求m的最小值。


输入描述:
输入：第一行输入一个正整数n(1<=n<=1e9)。
输出描述:
输出：输出一个正整数m。
示例1
输入
2
输出
4
说明
2的二进制10,4的二进制位100，1的个数相同，且4是满足条件的最小数
示例2
输入
7
输出
11
说明
7的二进制111,11的二进制位1011，1的个数相同，且11是满足条件的最小数
56
ACM编程 语言限制 【200分】 标题：贪吃的猴子 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
一只贪吃的猴子，来到一个果园，发现许多串香蕉排成一行，每串香蕉上有若干根香蕉。每串香蕉的根数由数组numbers给出。猴子获取香蕉，每次都只能从行的开头或者末尾获取，并且只能获取N次，求猴子最多能获取多少根香蕉。
输入描述:
第一行为数组numbers的长度
第二行为数组numbers的值每个数字通过空格分开
第三行输入为N，表示获取的次数
输出描述:
按照题目要求能获取的最大数值
备注:
1<= numbers.length <= 100000
1<= numbers[i] <= 100
1 <= N <= numbers.length

示例1
输入
7
1 2 2 7 3 6 1
3
输出
10
说明
第一次获取香蕉，无论是从行的开头或者末尾获取，得到的香蕉根数目为1 。但是，从行末尾获取能获取到最优的策略，后面可以直接得到香蕉根数目6和3。因此最终根数为1+6+3 = 10
示例2
输入
3
1 2 3
3
输出
6
说明
全部获取所有的香蕉，因此最终根数为1+2+3 = 6
示例3
输入
4
4 2 2 3
2
输出
7
说明
第一次获取香蕉为行的开头，第二次获取为行的末尾，因此最终根数为4+3 = 7
57
ACM编程 语言限制 【200分】 标题：最长子字符串的长度（二） | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
给你一个字符串 s，字符串s首尾相连成一个环形 ，请你在环中找出'l'、'o'、'x' 字符都恰好出现了偶数次最长子字符串的长度。

输入描述:
输入是一串小写的字母组成的字符串。

输出描述:
输出是一个整数
备注:
1 <= s.length <= 5 x 10^5

s 只包含小写英文字母。

示例1
输入
alolobo
输出
6
说明
最长子字符串之一是 "alolob"，它包含 'l'，'o'各 2 个，以及 0 个 'x' 。
示例2
输入
looxdolx
输出
7
说明
最长子字符串是 "oxdolxl"，由于是首尾连接在一起的，所以最后一个 'x' 和开头的 'l'是连接在一起的，此字符串包含 2 个 'l' ，2个 'o' ，2个 'x' 。
示例3
输入
bcbcbc
输出
6
说明
这个示例中，字符串 "bcbcbc" 本身就是最长的，因为  'l'、'o'、'x' 都出现了 0 次。
58
ACM编程 语言限制 【200分】 标题：二叉树计算 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
给出一个二叉树如下图所示：
                 6
                /  \
               7    9
                \   /   
                -2 6   

请由该二叉树生成一个新的二叉树，它满足其树中的每个节点将包含原始树中的左子树和右子树的和。

                20(7-2+9+6)
                /      \
               -2       6
                \      /   
                 0    0 
左子树表示该节点左侧叶子节点为根节点的一颗新树；右子树表示该节点右侧叶子节点为根节点的一颗新树
输入描述:
2行整数，第1行表示二叉树的中序遍历，第2行表示二叉树的前序遍历，以空格分割

例如：

7 -2 6 6 9
6 7 -2 9 6

输出描述:
1行整数，表示求和树的中序遍历，以空格分割

例如：

输出1
-2 0 20 0 6

示例1
输入
-3 12 6 8 9 -10 -7
8 12 -3 6 -10 9 -7
输出
0 3 0 7 0 2 0
59
ACM编程 语言限制 【200分】 标题：分月饼 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
题目描述：

中秋节，公司分月饼，m个员工，买了n个月饼，m<=n，每个员工至少分1个月饼，但可以分多个，单人分到最多月饼的个数是Max1，单人分到第二多月饼个数是Max2，Max1-Max2 <= 3，单人分到第n-1多月饼个数是Max(n-1)，单人分到第n多月饼个数是Max(n)，Max(n-1) – Max(n) <= 3, 问有多少种分月饼的方法？

输入描述:
每一行输入m n，表示m个员工，n个月饼，m<=n

输出描述:
输出有多少种月饼分法

示例1
输入
2 4
输出
2
说明
分法有2种：

4=1+3

4=2+2

注意：1+3和3+1算一种分法

示例2
输入
3 5
输出
2
说明
5=1+1+3

5=1+2+2

示例3
输入
3 12
输出
6
说明
满足要求的有6种分法：
12=1+1+10（Max1=10，Max2=1，不满足要求）
12=1+2+9（Max1=9, Max2=2, 不满足要求）

12=1+3+8（Max1=8, Max2=3, 不满足要求）

12=1+4+7（Max1=7, Max2=4, Max3=1，满足要求）

12=1+5+6（Max1=6, Max2=5, Max3=1，不满足要求）

12=2+2+8（Max1=8, Max2=2, 不满足要求）

12=2+3+7（Max1=7, Max2=3, 不满足要求）

12=2+4+6（Max1=6, Max2=4, Max3=2， 满足要求）

12=2+5+5（Max1=5, Max2=2，满足要求）

12=3+3+6（Max1=6, Max2=3, 满足要求）

12=3+4+5（Max1=5, Max2=4, Max3=3，满足要求）

12=4+4+4（Max1=4, 满足要求）
60
完善核心代码 语言限制 【200分】 标题：攀登者2 | 时间限制：1秒 | 内存限制：32768K
限定语言：不限
攀登者喜欢寻找各种地图，并且尝试攀登到最高的山峰。

地图表示为一维数组，数组的索引代表水平位置，数组的高度代表相对海拔高度。其中数组元素0代表地面。

例如[0,1,4,3,1,0,0,1,2,3,1,2,1,0], 代表如下图所示的地图，地图中有两个山脉位置分别为 1,2,3,4,5和8,9,10,11,12,13，最高峰高度分别为4,3。最高峰位置分别为3,10。
一个山脉可能有多座山峰(高度大于两边，或者在地图边界)。


               4 
 
             +---+ 
             |   | 
             |   | 3                       3 
             |   | 
             |   +---+                   ----- 
             |       |                   |   | 
           2 |       |                 2 |   |     2 
             |       |                   |   | 
         +---+       |               ----+   |   +---+ 
         |           |               |       |   |   | 
       1 |           | 1           1 |       | 1 |   | 1 
         |           |               |       |   |   | 
     +---+           +---+       +---+       +---+   +---+ 
     |                   |       |                       | 
   0 |                   | 0   0 |                       | 0 
     |                   |       |                       | 
 +---+                   +-------+                       +---+ 
 
   0   1   2   3   4   5   6   7   8   9  10  11  12  13  14
2. 登山时会消耗登山者的体力(整数)，上山时，消耗相邻高度差两倍的体力，下坡时消耗相邻高度差一倍的体力，平地不消耗体力，登山者体力消耗到零时会有生命危险。
例如，上图所示的山峰，从索引0，走到索引1，高度差为1，需要消耗2X1 = 2 的体力，从索引2高度2走到高度4索引3需要消耗2X2 = 4 的体力。如果是从索引3走到索引4则消耗1X1的体力。
3. 登山者体力上限为999。
4. 登山时的起点和终点可以是地图中任何高度为0的地面例如上图中的0,6,7,14 都可以作为登山的起点和终点 
 攀登者想要评估一张地图内有多少座山峰可以进行攀登，且可以安全返回到地面，且无生命危险。

例如上图中的数组，有3个不同的山峰，登上位置在3的山可以从位置0或者位置6开始，从位置0登到山顶需要消耗体力1X2+1X2+2X2 = 8, 从山顶返回到地面0需要消耗体力 2X1 + 1X1 + 1X1 = 4 的体力，按照登山路线0->3->0需要消耗体力 12。攀登者至少需要12以上的体力（大于12）才能安全返回。

示例1
输入
[0,1,4,3,1,0,0,1,2,3,1,2,1,0],13
输出
3
说明
登山者只能够登上位置10和12的山峰，7->10->7, 14->12>14
示例2
输入
[1,4,3],999
输出
0
说明
没有合适的起点和终点
61
ACM编程 语言限制 【200分】 标题：田忌赛马 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
给定两个只包含数字的数组a, b, 调整数组a里面数字的顺序，使得尽可能多的a[i] > b[i]。数组a和b中的数字各不相同。
输出所有可以达到最优结果的a数组数量


输入描述:
输入的第一行是数组a中的数字，其中只包含数字，每两个数字之间相隔一个空格，a数组大小不超过10
输入的第一行是数组b中的数字，其中只包含数字，每两个数字之间相隔一个空格，b数组大小不超过10
输出描述:
输出所有可以达到最优结果的a数组数量
示例1
输入
11 8 20
10 13 7
输出
1
说明
最优结果只有一个，a = [11, 20, 8]，故输出1
示例2
输入
11 12 20
10 13 7
输出
2
说明
有两个a数组的排列可以达到最优结果，[12, 20, 11]和[11, 20, 12]，故输出2
示例3
输入
1 2 3
4 5 6
输出
6
说明
a无论如何都会全输，故a任意排列都行，输出所有a数组的排列，6种排法
62
ACM编程 语言限制 【200分】 标题：社交距离 | 时间限制：1秒 | 内存限制：32768K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), JavaScript V8(6.0.0), Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), C++14(g++5.4), bash(GNU bash4.3.46), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44)
疫情期间，需要大家保证一定的社交距离，公司组织开交流会议，座位有一排共N个座位，编号分别为[0..N-1]，要求员工一个接着一个进入会议室，并且可以在任何时候离开会议室。
满足：每当一个员工进入时，需要坐到最大社交距离的座位（例如：位置A与左右有员工落座的位置距离分别为2和2，位置B与左右有员工落座的位置距离分别为2和3，影响因素都为2个位置，则认为座位A和B与左右位置的社交距离是一样的）；如果有多个这样的座位，则坐到索引最小的那个座位。

输入描述:
会议室座位总数seatNum，（1≤seatNum≤500）
员工的进出顺序seatOrLeave数组，元素值为1：表示进场；元素值为负数，表示出场（特殊：位置0的员工不会离开），例如-4表示坐在位置4的员工离开（保证有员工坐在该座位上）
输出描述:
最后进来员工，他会坐在第几个位置，如果位置已满，则输出-1
示例1
输入
10
[1, 1, 1, 1, -4, 1]
输出
5
说明
seat -> 0，坐在任何位置都行，但是要给他安排索引最小的位置，也就是座位0。
seat -> 9，要和旁边的人距离最远，也就是座位9。
seat -> 4，位置4与0和9的距离为(4和5),位置5与0和9的距离(5和4)，所以位置4和5都是可以选择的座位，按照要求需索引最小的那个座位，也就是座位4。
seat -> 2，位置2与0和4的距离为(2和2),位置6与4和9的距离(2和3)，位置7与4和9的距离(3和2)，影响因素都为2个位置，按照要求需索引最小的那个座位，也就是座位2。
leave(4) ，4号座位的员工离开。
seat -> 5，员工最后坐在5号座位上。

63
ACM编程 语言限制 【200分】 标题：求满足条件的最长子串的长度 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
 给定一个字符串，只包含字母和数字，按要求找出字符串中的最长（连续）子串的长度，字符串本身是其最长的子串，子串要求：

1、 只包含1个字母(a~z, A~Z)，其余必须是数字；

2、 字母可以在子串中的任意位置；

如果找不到满足要求的子串，如全是字母或全是数字，则返回-1。


输入描述:
字符串(只包含字母和数字)
输出描述:
子串的长度
示例1
输入
abC124ACb
输出
4
说明
满足条件的最长子串是C124或者124A，长度都是4
示例2
输入
a5
输出
2
说明
字符串自身就是满足条件的子串，长度为2
示例3
输入
aBB9
输出
2
说明
满足条件的子串为B9，长度为2
示例4
输入
abcdef
输出
-1
说明
没有满足要求的子串，返回-1
64
ACM编程 语言限制 【200分】 标题：亲子游戏 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
宝宝和妈妈参加亲子游戏，在一个二维矩阵（N*N）的格子地图上，宝宝和妈妈抽签决定各自的位置，地图上每个格子有不同的糖果数量，部分格子有障碍物。

游戏规则是妈妈必须在最短的时间（每个单位时间只能走一步）到达宝宝的位置，路上的所有糖果都可以拿走，不能走障碍物的格子，只能上下左右走。

请问妈妈在最短到达宝宝位置的时间内最多拿到多少糖果（优先考虑最短时间到达的情况下尽可能多拿糖果）。
输入描述:
第一行输入为N，N标识二维矩阵的大小
之后N行，每行有N个值，表格矩阵每个位置的值
其中：
-3：妈妈
-2：宝宝
-1：障碍
>=0：糖果数(0表示没有糖果，但是可以走)

输出描述:
输出妈妈在最短到达宝宝位置的时间内最多拿到多少糖果，行末无多余空格
备注:
地图最大50*50
示例1
输入
4
3 2 1 -3
1 -1 1 1
1 1 -1 2
-2 1 2 3
输出
9
说明

 



此地图有两条最短路径可到宝宝位置，绿色线和黄色线都是最短路径6步，但黄色拿到的糖果更多，9个 

示例2
输入
4
3 2 1 -3
-1 -1 1 1
1 1 -1 2
-2 1 -1 3
输出
-1
说明

 



此地图妈妈无法到达宝宝位置





