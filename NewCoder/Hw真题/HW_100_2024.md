1
ACM编程 语言限制 【100分】 标题：小明找位置 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
小朋友出操，按学号从小到大排成一列；小明来迟了，请你给小明出个主意，让他尽快找到他应该排的位置。
算法复杂度要求不高于nLog(n)；学号为整数类型，队列规模<=10000；
输入描述:
1、第一行：输入已排成队列的小朋友的学号（正整数），以”,”隔开；
       例如：93 95 97 100 102 123 155
2、第二行：小明学号，如110；
输出描述:
输出一个数字，代表队列位置（从1开始）。

例如：

6

示例1
输入
93 95 97 100 102 123 155
110
输出
6
2
ACM编程 语言限制 【100分】 标题：万能字符单词拼写 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
有一个字符串数组words和一个字符串chars。
假如可以用chars中的字母拼写出words中的某个“单词”（字符串），那么我们就认为你掌握了这个单词。
words的字符仅由 a-z 英文小写字母组成。 例如: abc
chars 由 a-z 英文小写字母和 “?”组成。其中英文问号“?”表示万能字符，能够在拼写时当做任意一个英文字母。 例如： "?" 可以当做 "a"等字母。
注意：每次拼写时，chars中的每个字母和万能字符都只能使用一次。
输出词汇表words中你掌握的所有单词的个数。 没有掌握任何单词，则输出0。
输入描述:
第1行输入数组words的个数，记为N。
从第2行开始到第N+1行依次输入数组words的每个字符串元素。
第N+2行输入字符串chars。
输出描述:
输出一个整数，表示词汇表words中你掌握的单词个数。
备注:
注意：
1 <= words.length <= 100
1 <= words[i].length, chars.length <= 100
所有字符串中都仅包含小写英文字母、英文问号
示例1
输入
4
cat
bt
hat
tree
atach??
输出
3
说明
可以拼写字符串"cat"、"bt"和"hat"
示例2
输入
3
hello
world
cloud
welldonehoneyr
输出
2
说明
可以拼写字符串"hello"和"world"
示例3
输入
3
apple
car
window
welldoneapplec?
输出
2
说明
可以拼写字符串"apple"和"car"
3
ACM编程 语言限制 【100分】 标题：生成哈夫曼树 | 时间限制：2秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
给定长度为n的无序的数字数组，每个数字代表二叉树的叶子节点的权值，数字数组的值均大于等于1。请完成一个函数，根据输入的数字数组，生成哈夫曼树，并将哈夫曼树按照中序遍历输出。
为了保证输出的二叉树中序遍历结果统一，增加以下限制：二叉树节点中，左节点权值小于等于右节点权值，根节点权值为左右节点权值之和。当左右节点权值相同时，左子树高度高度小于等于右子树。
注意：所有用例保证有效，并能生成哈夫曼树。
提醒：哈夫曼树又称最优二叉树，是一种带权路径长度最短的二叉树。所谓树的带权路径长度，就是树中所有的叶结点的权值乘上其到根结点的路径长度（若根结点为0层，叶结点到根结点的路径长度为叶结点的层数）。
例如：
由叶子节点5 15 40 30 10生成的最优二叉树如下图所示，该树的最短带权路径长度为40*1+30*2+15*3+5*4+10*4=205。

输入描述:
第一行输入为数组长度，记为N，1<=N<=1000，第二行输入无序数值数组，以空格分割，数值均大于等于1，小于100000
输出描述:
输出一个哈夫曼树的中序遍历的数组，数值间以空格分割
备注:

示例1
输入
5
5 15 40 30 10
输出
40 100 30 60 15 30 5 15 10
说明
根据输入，生成哈夫曼树，按照中序遍历返回。所有节点中，左节点权值小于等于右节点权值，根节点权值为左右节点权值之和。当左右节点权值相同时，左子树高度高度小于等于右子树。结果

参考答案：
哈夫曼树生成算法
4
ACM编程 语言限制 【100分】 标题：游戏分组 | 时间限制：1秒 | 内存限制：102400K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
部门准备举办一场王者荣耀表演赛，有10名游戏爱好者参与，分为两队，每队5人。每位参与者都有一个评分，代表着他的游戏水平。为了表演赛尽可能精彩，我们需要把10名参赛者分为实力尽量相近的两队。一队的实力可以表示为这一队5名队员的评分总和。
现在给你10名参与者的游戏水平评分，请你根据上述要求分队，最后输出这两组的实力差绝对值。
例：10名参赛者的评分分别为5 1 8 3 4 6 7 10 9 2，分组为（1 3 5 8 10）（2 4  6 7 9），两组实力差最小，差值为1。有多种分法，但实力差的绝对值最小为1。
输入描述:
10个整数，表示10名参与者的游戏水平评分。范围在[1, 10000]之间
输出描述:
1个整数，表示分组后两组实力差绝对值的最小值。
示例1
输入
1 2 3 4 5 6 7 8 9 10
输出
1
说明
10名队员分成两组，两组实力差绝对值最小为1。
5
ACM编程 语言限制 【100分】 标题：最多购买宝石数目 | 时间限制：3秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
 橱窗里有一排宝石，不同的宝石对应不同的价格，宝石的价格标记为gems[i],0<=i<n, n = gems.length
 宝石可同时出售0个或多个，如果同时出售多个，则要求出售的宝石编号连续；例如客户最大购买宝石个数为m，购买的宝石编号必须为gems[i],gems[i+1]...gems[i+m-1](0<=i<n,m<=n)
 假设你当前拥有总面值为value的钱，请问最多能购买到多少个宝石,如无法购买宝石，则返回0.

输入描述:
第一行输入n，参数类型为int，取值范围：[0,106]，表示橱窗中宝石的总数量。
之后n行分别表示从第0个到第n-1个宝石的价格，即gems[0]到gems[n-1]的价格，类型为int，取值范围：(0,1000]。
之后一行输入v，类型为int，取值范围：[0,109]表示你拥有的钱。

输出描述:
输出int类型的返回值，表示最大可购买的宝石数量。
示例1
输入
7
8
4
6
3
1
6
7
10
输出
3
说明

gems = [8,4,6,3,1,6,7], value = 10

最多购买的宝石为gems[2]至gems[4]或者gems[3]至gems[5]


示例2
输入
0
1
输出
0
说明

gems = [], value = 1

因为没有宝石，所以返回0
示例3
输入
9
6
1
3
1
8
9
3
2
4
15
输出
4
说明

gems = [6, 1, 3, 1, 8, 9, 3, 2, 4], value = 15

最多购买的宝石为gems[0]至gems[3]
示例4
输入
9
1
1
1
1
1
1
1
1
1
10
输出
9
说明

gems = [1, 1, 1, 1, 1, 1, 1, 1, 1], value = 10

最多购买的宝石为gems[0]至gems[8]，即全部购买
参考答案：
6
ACM编程 语言限制 【100分】 标题：精准核酸检测 | 时间限制：1秒 | 内存限制：65536K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
为了达到新冠疫情精准防控的需要，为了避免全员核酸检测带来的浪费，需要精准圈定可能被感染的人群。
现在根据传染病流调以及大数据分析，得到了每个人之间在时间、空间上是否存在轨迹的交叉。
现在给定一组确诊人员编号（X1, X2, X3, .... Xn）,在所有人当中，找出哪些人需要进行核酸检测，输出需要进行核酸检测的人数。（注意：确诊病例自身不需要再做核酸检测）
需要进行核酸检测的人，是病毒传播链条上的所有人员，即有可能通过确诊病例所能传播到的所有人。
例如：A是确诊病例，A和B有接触、B和C有接触、C和D有接触、D和E有接触，那么B\C\D\E都是需要进行核酸检测的人。
输入描述:
第一行为总人数N
第二行为确诊病例人员编号（确诊病例人员数量<N），用逗号分割
第三行开始，为一个N*N的矩阵，表示每个人员之间是否有接触，0表示没有接触，1表示有接触。
输出描述:
整数：需要做核酸检测的人数
备注:
人员编号从0开始
0<N<100
示例1
输入
5
1,2
1,1,0,1,0
1,1,0,0,0
0,0,1,0,1
1,0,0,1,0
0,0,1,0,1
输出
3
说明
编号为1、2号的人员，为确诊病例。
1号与0号有接触，0号与3号有接触。
2号与4号有接触。
所以，需要做核酸检测的人是0号、3号、4号，总计3人需要进行核酸检测。
7
ACM编程 语言限制 【100分】 标题：虚拟游戏理财 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
在一款虚拟游戏中生活，你必须进行投资以增强在虚拟游戏中的资产以免被淘汰出局。现有一家Bank，它提供有若干理财产品m，风险及投资回报不同，你有N（元）进行投资，能接受的总风险值为X。
你要在可接受范围内选择最优的投资方式获得最大回报。
说明：
在虚拟游戏中，每项投资风险值相加为总风险值；
在虚拟游戏中，最多只能投资2个理财产品；
在虚拟游戏中，最小单位为整数，不能拆分为小数；
投资额*回报率=投资回报
输入描述:
第一行：产品数(取值范围[1, 20])，总投资额(整数，取值范围[1, 10000])，可接受的总风险(整数，取值范围[1, 200])

第二行：产品投资回报率序列，输入为整数，取值范围[1,60]

第三行：产品风险值序列，输入为整数，取值范围[1,100]

第四行：最大投资额度序列，输入为整数，取值范围[1,10000]



输出描述:
每个产品的投资额序列
备注:
在虚拟游戏中，每项投资风险值相加为总风险值；
在虚拟游戏中，最多只能投资2个理财产品；
在虚拟游戏中，最小单位为整数，不能拆分为小数；
投资额*回报率=投资回报
示例1
输入
5 100 10 
10 20 30 40 50 
3 4 5 6 10 
20 30 20 40 30
输出
0 30 0 40 0
说明
投资第二项30个单位，第四项40个单位，总的投资风险为两项相加为4+6=10
8
ACM编程 语言限制 【100分】 标题：找座位 | 时间限制：1秒 | 内存限制：65536K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
在一个大型体育场内举办了一场大型活动，由于疫情防控的需要，要求每位观众的必须间隔至少一个空位才允许落座。现在给出一排观众座位分布图，座位中存在已落座的观众，请计算出，在不移动现有观众座位的情况下，最多还能坐下多少名观众。
输入描述:
一个数组，用来标识某一排座位中，每个座位是否已经坐人。0表示该座位没有坐人，1表示该座位已经坐人。
输出描述:
整数，在不移动现有观众座位的情况下，最多还能坐下多少名观众。
备注:
1<=数组长度<=10000
示例1
输入
10001
输出
1
示例2
输入
0101
输出
0
9
ACM编程 语言限制 【100分】 标题：传递悄悄话 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
给定一个二叉树，每个节点上站着一个人，节点数字表示父节点到该节点传递悄悄话需要花费的时间。
初始时，根节点所在位置的人有一个悄悄话想要传递给其他人，求二叉树所有节点上的人都接收到悄悄话花费的时间。
输入描述:
给定二叉树 
0 9 20 -1 -1 15 7 -1 -1 -1 -1 3 2
注：-1表示空节点

输出描述:
返回所有节点都接收到悄悄话花费的时间38
示例1
输入
0 9 20 -1 -1 15 7 -1 -1 -1 -1 3 2
输出
38
10
ACM编程 语言限制 【100分】 标题：小华最多能得到多少克黄金 | 时间限制：1秒 | 内存限制：65536K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), JavaScript V8(6.0.0), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
小华按照地图去寻宝，地图上被划分成 m 行和 n 列的方格，横纵坐标范围分别是 [0, n−1]和[0, m-1]。在横坐标和纵坐标的数位之和不大于k的方格中存在黄金（每个方格中仅存在一克黄金），但横坐标和纵坐标之和大于k的方格存在危险不可进入。小华从入口(0,0)进入，任何时候只能向左，右，上，下四个方向移动一格。请问小华最多能获得多少克黄金？
输入描述:
坐标取值范围如下：
0<=m<=50
0<=n<=50
k的取值范围如下：
0<=k<=100
输入中包含3个字数，分别是m，n，k
输出描述:
最多能获得多少克黄金
示例1
输入
40 40 18
输出
1484
说明
当k为18时，小华能够进入方格（10,10），因为1+0+1+0 = 2。 但是，他不能进入方格（36,38），因为3+6+3+8 = 20
示例2
输入
4 5 7
输出
20
说明
如图每个单元格中的数位之和均不大于7，都是符合要求的，所以可以最多可获得20克黄金

11
ACM编程 语言限制 【100分】 标题：密码输入检测 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
给定用户密码输入流input，输入流中字符'<'表示退格，可以清除前一个输入的字符，请你编写程序，输出最终得到的密码字符，并判断密码是否满足如下的密码安全要求。
密码安全要求如下：
1.密码长度>=8;
2.密码至少需要包含1个大写字母;
3.密码至少需要包含1个小写字母;
4.密码至少需要包含1个数字;
5.密码至少需要包含1个字母和数字以外的非空白特殊字符

注意空串退格后仍然为空串，且用户输入的字符串不包含‘<’字符和空白字符。


输入描述:
用一行字符串表示输入的用户数据，输入的字符串中‘<’字符标识退格，用户输入的字符串不包含空白字符，例如：
ABC<c89%000<
输出描述:
输出经过程序处理后，输出的实际密码字符串，并输出改密码字符串是否满足密码安全要求。两者间由‘,’分隔， 例如：
ABc89%00,true
示例1
输入
ABC<c89%000<
输出
ABc89%00,true
说明
解释：多余的C和0由于退格被去除,最终用户输入的密码为ABc89%00，且满足密码安全要求，输出true
示例2
输入
<ABC
输出
ABC,false
说明
不满足密码安全要求
示例3
输入
AB<<C<
输出
,false
说明
输出字符串为空，不满足密码安全要求
12
ACM编程 语言限制 【100分】 标题：转盘寿司 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
寿司店周年庆，正在举办优惠活动回馈新老客户。
寿司转盘上总共有n盘寿司，prices[i]是第i盘寿司的价格，如果客户选择了第i盘寿司，寿司店免费赠送客户距离第i盘寿司最近的下一盘寿司 j，前提是prices[j] < prices[i]，如果没有满足条件的 j，则不赠送寿司。
每个价格的寿司都可无限供应
输入描述:
输入的每一个数字代表每盘寿司的价格，每盘寿司的价格之间使用空格分隔，
例如:
3 15 6 14 
表示第0盘寿司价格prices[0]为3，第1盘寿司价格prices[1]为15，第2盘寿司价格prices[2]为6，第3盘寿司价格prices[3]为14

寿司的盘数n范围为：1 <= n <= 500
每盘寿司的价格price范围为：1 <= price <= 1000


输出描述:
输出享受优惠后的一组数据，每个值表示客户选择第i盘寿司时实际得到的寿司的总价格。使用空格进行分隔，例如：
3 21 6 17
示例1
输入
3 14 15 6 5
输出
3 20 21 11 8
说明
第0盘寿司价格为3，往后找不到任何比第0盘寿司便宜的寿司，所以客户选择第0盘寿司的话，实际可得到价格还是原价格3
第1盘寿司价格为14，往后可以找到第4盘寿司价格为6，prices[3] < prices[1]，所以客户选择第1盘寿司的话，实际可得到价格为prices[1] + prices[3] = 20

13
ACM编程 语言限制 【100分】 标题：智能成绩表 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
小明来到某学校当老师，需要将学生按考试总分或单科分数进行排名，你能帮帮他吗？
输入描述:
第1行输入两个整数，学生人数n和科目数量m。0<n<100,0<m<10
第2行输入m个科目名称，彼此之间用空格隔开。科目名称只由英文字母构成，单个长度不超过10个字符。科目的出现顺序和后续输入的学生成绩一一对应。不会出现重复的科目名称。
第3行开始的n行，每行包含一个学生的姓名和该生m个科目的成绩（空格隔开），学生不会重名。学生姓名只由英文字母构成，长度不超过10个字符。成绩是0~100的整数，依次对应第2行中输入的科目。
第n+2行，输入用作排名的科目名称。若科目不存在，则按总分进行排序。
输出描述:
输出一行，按成绩排序后的学生名字，空格隔开。成绩相同的按照学生姓名字典顺序排序。
示例1
输入
3 2
yuwen shuxue
fangfang 95 90
xiaohua 88 95
minmin 100 82
shuxue
输出
xiaohua fangfang minmin
说明
按shuxue成绩排名，依次是xiaohua、fangfang、minmin
示例2
输入
3 2
yuwen shuxue
fangfang 95 90
xiaohua 88 95
minmin 90 95
zongfen
输出
fangfang minmin xiaohua
说明
排序科目不存在，按总分排序，fangfang和minmin总分相同，按姓名的字典顺序，fangfang排在前面
14
ACM编程 语言限制 【100分】 标题：多段线数据压缩 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
下图中，每个方块代表一个像素，每个像素用其行号和列号表示。

为简化处理，多段线的走向只能是水平、竖直、斜向45度。
上图中的多段线可以用下面的坐标串表示：(2, 8), (3, 7), (3, 6), (3, 5), (4, 4), (5, 3), (6, 2), (7, 3), (8, 4), (7, 5)。
但可以发现，这种表示不是最简的，其实只需要存储6个蓝色的关键点即可，它们是线段的起点、拐点、终点，而剩下4个点是冗余的。
现在，请根据输入的包含有冗余数据的多段线坐标列表，输出其最简化的结果。
输入描述:
2 8 3 7 3 6 3 5 4 4 5 3 6 2 7 3 8 4 7 5
1、所有数字以空格分隔，每两个数字一组，第一个数字是行号，第二个数字是列号；
2、行号和列号范围为[0,64)，用例输入保证不会越界，考生不必检查；
3、输入数据至少包含两个坐标点。
输出描述:
2 8 3 7 3 5 6 2 8 4 7 5
压缩后的最简化坐标列表，和输入数据的格式相同。
备注:
输出的坐标相对顺序不能变化。
示例1
输入
2 8 3 7 3 6 3 5 4 4 5 3 6 2 7 3 8 4 7 5
输出
2 8 3 7 3 5 6 2 8 4 7 5
说明
如上图所示，6个蓝色像素的坐标依次是（2,8）、（3,7）、（3,5）、（6,2）、（8,4）、（7,5）。
将他们按顺序出即可。
15
ACM编程 语言限制 【100分】 标题：分割均衡字符串 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), JavaScript V8(6.0.0), Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), bash(GNU bash4.3.46), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)
均衡串定义：字符串只包含两种字符，且两种字符的个数相同。
给定一个均衡字符串，请给出可分割成新的均衡子串的最大个数。
约定字符串中只包含大写的'X'和'Y'两种字符。
输入描述:
均衡串：XXYYXY
字符串的长度[2,10000]。给定的字符串均为均衡串。

输出描述:
可分割为两个子串：
XXYY
XY
备注:
分割后的子串，是原字符串的连续子串。
示例1
输入
XXYYXY
输出
2
16
ACM编程 语言限制 【100分】 标题：螺旋数字矩阵 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
疫情期间，小明隔离在家，百无聊赖，在纸上写数字玩。他发明了一种写法：
给出数字个数n和行数m（0 < n ≤ 999，0 < m ≤ 999），从左上角的1开始，按照顺时针螺旋向内写方式，依次写出2,3...n，最终形成一个m行矩阵。
小明对这个矩阵有些要求：
1.每行数字的个数一样多
2.列的数量尽可能少
3.填充数字时优先填充外部
4.数字不够时，使用单个*号占位
输入描述:
两个整数，空格隔开，依次表示n、m
输出描述:
符合要求的唯一矩阵
示例1
输入
9 4
输出
1 2 3
* * 4
9 * 5
8 7 6
说明
9个数字写成4行，最少需要3列
示例2
输入
3 5
输出
1
2
3
*
*
说明
3个数字写5行，只有一列，数字不够用*号填充
示例3
输入
120 7
输出
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18
46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 19
45 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 63 20
44 83 114 115 116 117 118 119 120 * * * * * * 99 64 21
43 82 113 112 111 110 109 108 107 106 105 104 103 102 101 100 65 22
42 81 80 79 78 77 76 75 74 73 72 71 70 69 68 67 66 23
41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24
17
ACM编程 语言限制 【100分】 标题：数的分解 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), JavaScript V8(6.0.0), Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), bash(GNU bash4.3.46), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)
给定一个正整数n，如果能够分解为m(m > 1)个连续正整数之和，请输出所有分解中，m最小的分解。
如果给定整数无法分解为连续正整数，则输出字符串"N"。
输入描述:
输入数据为一整数，范围为（1, 2^30]
输出描述:
比如输入为：
21
输出：
21=10+11
备注:
21可以分解的连续正整数组合的形式有多种
21=1+2+3+4+5+6
21=6+7+8
21=10+11
输出，21=10+11，是最短的分解序列。
示例1
输入
21
输出
21=10+11
说明
21可以分解的连续正整数组合的形式有多种
21=1+2+3+4+5+6
21=6+7+8
21=10+11
因21=10+11，是最短的分解序列。所以答案是21=10+11
18
ACM编程 语言限制 【100分】 标题：开源项目热榜 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
某个开源社区希望将最近热度比较高的开源项目出一个榜单，推荐给社区里面的开发者。对于每个开源项目，开发者可以进行关注(watch)、收藏(star)、fork、提issue、提交合并请求(MR)等。
数据库里面统计了每个开源项目关注、收藏、fork、issue、MR的数量，开源项目的热度根据这5个维度的加权求和进行排序。

表示热度值，分别表示5个统计维度的权重，分别表示5个统计维度的统计值。
榜单按照热度值降序排序，对于热度值相等的，按照项目名字转换为全小写字母后的字典序排序（'a','b','c',...,'x','y','z')。
输入描述:
第一行输入为N，表示开源项目的个数，。
第二行输入为权重值列表，一共5个整型值，分别对应关注、收藏、fork、issue、MR的权重，权重取值。
第三行开始接下来的N行为开源项目的统计维度，每一行的格式为：
name nr_watch nr_star nr_fork nr_issue nr_mr
其中name为开源项目的名字，由英文字母组成，长度，其余5个整型值分别为该开源项目关注、收藏、fork、issue、MR的数量，数量取值。
输出描述:
按照热度降序，输出开源项目的名字，对于热度值相等的，按照项目名字转换为全小写字母后的字典序排序（'a'>'b'>'c'>...>'x'>'y'>'z')。
示例1
输入
4
8 6 2 8 6
camila 66 70 46 158 80
victoria 94 76 86 189 211
anthony 29 17 83 21 48
emily 53 97 1 19 218
输出
victoria
camila
emily
anthony
说明
排序热度值计算：
camila: 66*8 + 70*6 + 46*2 + 158*8 + 80*6 = 2784
victoria: 94*8 + 76*6 + 86*2 + 189*8 + 211*6 = 4158
anthony: 29*8 + 17*6 + 83*2 + 21*8 + 48*6 = 956
emily: 53*8 + 97*6 + 1*2 + 19*8 + 218*6 = 2468
根据热度值降序，得到结果。
示例2
输入
5
5 6 6 1 2
camila 13 88 46 26 169
grace 64 38 87 23 103
lucas 91 79 98 154 79
leo 29 27 36 43 178
ava 29 27 36 43 178
输出
lucas
grace
camila
ava
leo
说明
排序热度值计算：
camila: 13*5 + 88*6 + 46*6 + 26*1 + 169*2 = 1233
grace: 64*5 + 38*6 + 87*6 + 23*1 + 103*2 = 1299
lucas: 91*5 + 79*6 + 98*6 + 154*1 + 79*2 = 1829
leo: 29*5 + 27*6 + 36*6 + 43*1 + 178*2 = 922
ava: 29*5 + 27*6 + 36*6 + 43*1 + 178*2 = 922
根据热度值降序，对于leo和ava，热度值相等，按照字典序，ava排在leo前面，得到结果。
19
ACM编程 语言限制 【100分】 标题：内存冷热标记 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
现代计算机系统中通常存在多级的存储设备，针对海量workload的优化的一种思路是将热点内存页优先放到快速存储层级，这就需要对内存页进行冷热标记。
一种典型的方案是基于内存页的访问频次进行标记，如果统计窗口内访问次数大于等于设定阈值，则认为是热内存页，否则是冷内存页。
对于统计窗口内跟踪到的访存序列和阈值，现在需要实现基于频次的冷热标记。内存页使用页框号作为标识。
输入描述:
第一行为输入为N，表示访存序列的记录条数，。
第二行为访存序列，空格间隔的N个内存页框号，页框号范围0-65535，同一页框号可能重复出现，出现的次数即为对应页框号的频次。
第三行为热内存页的频次阈值T，正整数，范围。
输出描述:
第一行输出标记为热内存的内存页个数，如果没有被标记为热内存的，则输出0。
如果第一行>0，则接下来按照访问频次降序输出内存页框号，一行一个，频次一样的页框号，页框号小的排前面。
示例1
输入
10
1 2 1 2 1 2 1 2 1 2
5
输出
2
1
2
说明
内存页1和内存页2均被访问了5次，达到了阈值5，因此热内存页有2个。内存页1和内存页2的访问频次相等，页框号小的排前面。
示例2
输入
5
1 2 3 4 5
3
输出
0
说明
访存跟踪里面访问频次没有超过3的，因此热内存页个数为0。
20
ACM编程 语言限制 【100分】 标题：分披萨 | 时间限制：1秒 | 内存限制：65536K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), JavaScript V8(6.0.0), Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), bash(GNU bash4.3.46), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)
“吃货”和“馋嘴”两人到披萨店点了一份铁盘（圆形）披萨，并嘱咐店员将披萨按放射状切成大小相同的偶数扇形小块。但是粗心服务员将披萨切成了每块大小都完全不同奇数块，且肉眼能分辨出大小。
由于两人都想吃到最多的披萨，他们商量了一个他们认为公平的分法：从“吃货”开始，轮流取披萨。除了第一块披萨可以任意选取以外，其他都必须从缺口开始选。
他俩选披萨的思路不同。“馋嘴”每次都会选最大块的披萨，而且“吃货”知道“馋嘴”的想法。
已知披萨小块的数量以及每块的大小，求“吃货”能分得的最大的披萨大小的总和。
输入描述:
第1行为一个正整数奇数N，表示披萨小块数量。3 <= N < 500。
接下来的第2行到第N+1行（共N行），每行为一个正整数，表示第i块披萨的大小。1 <= i <= N。披萨小块从某一块开始，按照一个方向依次顺序编号为1~N。每块披萨的大小范围为[1, 2147483647]。
输出描述:
“吃货”能分得的最大的披萨大小的总和。
示例1
输入
5
8
2
10
5
7
输出
19
说明
此例子中，有5块披萨。每块大小依次为8、2、10、5、7。按照如下顺序拿披萨，可以使“吃货”拿到最多披萨：
1、“吃货”拿大小为10的披萨
2、“馋嘴”拿大小为5的披萨
3、“吃货”拿大小为7的披萨
4、“馋嘴”拿大小为8的披萨
5、“吃货”拿大小为2的披萨
至此，披萨瓜分完毕，“吃货”拿到的披萨总大小为10+7+2=19。
可能存在多种拿法，以上只是其中一种。
21
ACM编程 语言限制 【100分】 标题：小朋友至少有几个 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), JavaScript V8(6.0.0), Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), bash(GNU bash4.3.46), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)
幼儿园组织活动，老师布置了一个任务：每个小朋友去了解与自己同一个小区的小朋友还有几个。我们将这些数量汇总到数组garden中。
请根据这些小朋友给出的信息，计算小朋友至少有几个？



输入描述:
输入：garden[] = {2, 2, 3}
说明：
garden数组长度最大为999
每个小区的小朋友数量最多1000人，也就是garden[i]的范围为[0,999]
输出描述:
输出：7
示例1
输入
2 2 3
输出
7
说明
解释：
第一个小朋友反馈有两个小朋友和自己同一小区，即此小区有3个小朋友
第二个小朋友反馈有两个小朋友和自己同一小区，即此小区有3个小朋友。
这两个小朋友，可能是同一小区的，且此小区的小朋友只有3个人。
第三个小区反馈还有3个小朋友与自己同一小区，则这些小朋友只能是另外一个小区的。这个小区有4个小朋友。

## 22. 标题：围棋的气

围棋棋盘由纵横各19条线垂直相交组成，棋盘上一共19x19=361个交点，对弈双方一方执白棋，一方执黑棋，落子时只能将棋子置于交点上。
“气”是围棋中很重要的一个概念，某个棋子有几口气，是指其上下左右方向四个相邻的交叉点中，有几个交叉点没有棋子，由此可知：
1、在棋盘的边缘上的棋子最多有3口气（黑1），在棋盘角点的棋子最多有2口气（黑2），其它情况最多有4口气（白1）

2、所有同色棋子的气之和叫作该色棋子的气，需要注意的是，同色棋子重合的气点，对于该颜色棋子来说，只能计算一次气，比如下图中，黑棋一共4口气，而不是5口气，因为黑1和黑2中间红色三角标出的气是两个黑棋共有的，对于黑棋整体来说只能算一个气。

3、本题目只计算气，对于眼也按气计算，如果您不清楚“眼”的概念，可忽略，按照前面描述的规则计算即可。
现在，请根据输入的黑棋和白棋的坐标位置，计算黑棋和白起一共各有多少气？


输入描述:
输入包括两行数据，如：
0 5 8 9 9 10
5 0 9 9 9 8
1、每行数据以空格分隔，数据个数是2的整数倍，每两个数是一组，代表棋子在棋盘上的坐标；
2、坐标的原点在棋盘左上角点，第一个值是行号，范围从0到18；第二个值是列号，范围从0到18。
3、举例说明：第一行数据表示三个坐标（0，5）、（8，9）、（9，10）
4、第一行表示黑棋的坐标，第二行表示白棋的坐标。
5、题目保证输入两行数据，无空行且每行按前文要求是偶数个，每个坐标不会超出棋盘范围。
输出描述:
8 7
两个数字以空格分隔，第一个数代表黑棋的气数，第二个数代表白棋的气数。
备注:

示例1
输入
0 5 8 9 9 10
5 0 9 9 9 8
输出
8 7
说明
如果将输入数据放到棋盘上，数数黑棋一共8口气：

数数白棋一共7口气：


23
ACM编程 语言限制 【100分】 标题：机器人仓库搬砖 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), JavaScript V8(6.0.0), Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), bash(GNU bash4.3.46), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)
机器人搬砖，一共有N堆砖存放在N个不同的仓库中，第i堆砖中有bricks[i]块砖头，要求在8小时内搬完。机器人每小时能搬砖的数量取决于有多少能量格，机器人一个小时中只能在一个仓库中搬砖，机器人的能量格每小时补充一次且能量格只在这一个小时有效，为使得机器人损耗最小化尽量减小每次补充的能量格数。
为了保障在8小时内能完成搬砖任务，请计算每小时给机器人充能的最小能量格数。
备注：
1、无需考虑机器人补充能量格的耗时；
2、无需考虑机器人搬砖的耗时；
3、机器人每小时补充能量格只在这一个小时中有效；
输入描述:
程序输入为“30 12 25 8 19”一个整数数组，数组中的每个数字代表第i堆砖的个数，每堆砖的个数不超过100。

输出描述:
输出在8小时内完成搬砖任务，机器人每小时最少需要充多少个能量格；
如果8个小时内无论如何都完成不了任务，则输出“-1”；
示例1
输入
30 12 25 8 19
输出
15
示例2
输入
10 12 25 8 19 8 6 4 17 19 20 30
输出
-1
说明
砖的堆数为12堆存放在12个仓库中，机器人一个小时内只能在一个仓库搬砖，不可能完成任务。
24
ACM编程 语言限制 【100分】 标题：机场航班调度程序 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), JavaScript V8(6.0.0), Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), bash(GNU bash4.3.46), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)
XX市机场停放了多架飞机，每架飞机都有自己的航班号CA3385，CZ6678，SC6508等，航班号的前2个大写字母(或数字）代表航空公司的缩写，后面4个数字代表航班信息。但是XX市机场只有一条起飞用跑道，调度人员需要安排目前停留在机场的航班有序起飞。为保障航班的有序起飞，调度员首先按照航空公司的缩写（航班号前2个字母）对所有航班进行排序，同一航空公司的航班再按照航班号的后4个数字进行排序最终获得安排好的航班的起飞顺序。请编写一段代码根据输入的航班号信息帮助调度员输出航班的起飞顺序。
说明：
1、航空公司缩写排序按照从特殊符号$ & *, 0~9，A~Z排序；
输入描述:
第一行输入航班信息，多个航班号之间用逗号（“，”）分隔，输入的航班号不超过100个例如：
CA3385,CZ6678,SC6508,DU7523,HK4456,MK0987
备注：航班号为6位长度，后4位为纯数字，不考虑存在后4位重复的场景

输出描述:
CA3385,CZ6678,DU7523,HK4456,MK0987,SC6508
示例1
输入
CA3385,CZ6678,SC6508,DU7523,HK4456,MK0987
输出
CA3385,CZ6678,DU7523,HK4456,MK0987,SC6508
说明
输入目前停留在该机场的航班号，输出为按照调度排序后输出的有序的航班号
示例2
输入
MU1087,CA9908,3U0045,FM1703
输出
3U0045,CA9908,FM1703,MU1087
25
ACM编程 语言限制 【100分】 标题：API集群负载统计 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
某个产品的RESTful API集合部署在服务器集群的多个节点上，近期对客户端访问日志进行了采集，需要统计各个API的访问频次，根据热点信息在服务器节点之间做负载均衡，现在需要实现热点信息统计查询功能。
RESTful API的由多个层级构成，层级之间使用 / 连接，如 /A/B/C/D 这个地址，A属于第一级，B属于第二级，C属于第三级，D属于第四级。
现在负载均衡模块需要知道给定层级上某个名字出现的频次，未出现过用0次表示，实现这个功能。
输入描述:
第一行为N，表示访问历史日志的条数，。
接下来N行，每一行为一个RESTful API的URL地址，约束地址中仅包含英文字母和连接符/，最大层级为10，每层级字符串最大长度为10。
最后一行为层级L和要查询的关键字。    
输出描述:
输出给定层级上，关键字出现的频次，使用完全匹配方式（大小写敏感）。
示例1
输入
5
/huawei/computing/no/one
/huawei/computing
/huawei
/huawei/cloud/no/one
/huawei/wireless/no/one
2 computing
输出
2
说明
在第二层级上，computing出现了2次，因此输出2.
示例2
输入
5
/huawei/computing/no/one
/huawei/computing
/huawei
/huawei/cloud/no/one
/huawei/wireless/no/one
4 two
输出
0
说明
存在第四层级的URL上，没有出现two，因此频次是0
26
ACM编程 语言限制 【100分】 标题：测试用例执行计划 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
某个产品当前迭代周期内有N个特性（）需要进行覆盖测试，每个特性都被评估了对应的优先级，特性使用其ID作为下标进行标识。
设计了M个测试用例（），每个用例对应了一个覆盖特性的集合，测试用例使用其ID作为下标进行标识，测试用例的优先级定义为其覆盖的特性的优先级之和。
在开展测试之前，需要制定测试用例的执行顺序，规则为：优先级大的用例先执行，如果存在优先级相同的用例，用例ID小的先执行。
输入描述:
第一行输入为N和M，N表示特性的数量，M表示测试用例的数量，。
之后N行表示特性ID=1到特性ID=N的优先级。
再接下来M行表示测试用例ID=1到测试用例ID=M关联的特性的ID的列表。
输出描述:
按照执行顺序（优先级从大到小）输出测试用例的ID，每行一个ID。
备注:
测试用例覆盖的ID不重复。
示例1
输入
5 4
1
1
2
3
5
1 2 3
1 4
3 4 5
2 3 4
输出
3
4
1
2
说明
测试用例的优先级计算如下：
T_1=P_{F1}+P_{F2}+P_{F3}=1+1+2=4
T_2=P_{F1}+P_{F4}=1+3=4
T_3=P_{F3}+P_{F4}+P_{F5}=2+3+5=10
T_4=P_{F2}+P_{F3}+P_{F4}=1+2+3=6
按照优先级从小到大，以及相同优先级，ID小的先执行的规则，执行顺序为T3,T4,T1,T2
示例2
输入
3 3
3
1
5
1 2 3
1 2 3
1 2 3
输出
1
2
3
说明
测试用例的优先级计算如下：
T_1=P_{F1}+P_{F2}+P{F3}=3+1+5=9
T_2=P_{F1}+P_{F2}+P{F3}=3+1+5=9
T_3=P_{F1}+P_{F2}+P{F3}=3+1+5=9
每个优先级一样，按照ID从小到大执行，执行顺序为T1,T2,T3
27
ACM编程 语言限制 【100分】 标题：灰度图恢复 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
黑白图像常采用灰度图的方式存储，即图像的每个像素填充一个灰阶值，256阶灰度图是一个灰阶值取值范围为0-255的灰阶矩阵，0表示全黑、255表示全白，范围内的其他值表示不同的灰度，比如下面的图像及其对应的灰阶矩阵：

但在计算机中实际存储时，会使用压缩算法，其中一种压缩格式和描述如下：
10 10 255 34 0 1 255 8 0 3 255 6 0 5 255 4 0 7 255 2 0 9 255 21
1、所有数值以空格分隔
2、前两个数分别表示矩阵的行数和列数
3、从第三个数开始，每两个数一组，每组第一个数是灰阶值，第二个数表示该灰阶值从左到右，从上到下（可理解为将二维数组按行存储在一维矩阵中）的连续像素个数。比如题目所述例子，“255 34”表示有连续34个像素的灰阶值是255。
如此，图像软件在打开此格式灰度图的时候，就可以根据此算法从压缩数据恢复出原始灰度图矩阵。
请从输入的压缩数恢复灰度图原始矩阵，并返回指定像素的灰阶值。
输入描述:
10 10 255 34 0 1 255 8 0 3 255 6 0 5 255 4 0 7 255 2 0 9 255 21
3 4
输入包括两行，第一行是灰度图压缩数据，第二行表示一个像素位置的行号和列号，如：0 0 表示左上角像素。
输出描述:
0
输入数据表示的灰阶矩阵的指定像素的灰阶值。
备注:
1、系统保证输入的压缩数据是合法有效的，不会出现数据越界、数值不合法等无法恢复的场景；
2、系统保证输入的像素坐标是合法的，不会出现不在矩阵中的像素；
3、矩阵的行和列数范围为：(0,100]；
4、灰阶值取值范围：[0, 255]；
示例1
输入
10 10 56 34 99 1 87 8 99 3 255 6 99 5 255 4 99 7 255 2 99 9 255 21
3 4
输出
99
说明
将压缩数据恢复后的灰阶矩阵第3行第4列的像素灰阶值是99.
示例2
输入
10 10 255 34 0 1 255 8 0 3 255 6 0 5 255 4 0 7 255 2 0 9 255 21
3 5
输出
255
说明
将压缩数据恢复后的灰阶矩阵第3行第5列的像素灰阶值是255.
28
ACM编程 语言限制 【100分】 标题：计算三叉搜索树的高度 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
定义构造三叉搜索树规则如下：
    每个节点都存有一个数，当插入一个新的数时，从根节点向下寻找，直到找到一个合适的空节点插入。
    查找的规则是：
        1. 如果数小于节点的数减去500，则将数插入节点的左子树
        2. 如果数大于节点的数加上500，则将数插入节点的右子树
        3. 否则，将数插入节点的中子树
给你一系列数，请按以上规则，按顺序将数插入树中，构建出一棵三叉搜索树，最后输出树的高度。

输入描述:
第一行为一个数N，表示有N个数，1<=N<=10000
后面N行每一行一个整数，每个数的范围为[1,10000]

输出描述:
输出树的高度(根节点的高度为1)

示例1
输入
5
5000
2000
5000
8000
1800
输出
3
说明
最终构造出的树如下，高度为3：

示例2
输入
3
5000
4000
1800
输出
3
说明
最终构造出的树如下，高度为3：

29
ACM编程 语言限制 【100分】 标题：执行任务赚积分 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
现有N个任务需要处理，同一时间只能处理一个任务，处理每个任务所需要的时间固定为1。
每个任务都有最晚处理时间限制和积分值，在最晚处理时间点之前处理完成任务才可获得对应的积分奖励。
可用于处理任务的时间有限，请问在有限的时间内，可获得的最多积分。
输入描述:
第一行为一个数N，表示有N个任务，1<=N<=100
第二行为一个数T，表示可用于处理任务的时间。1<=T<=100
接下来N行，每行两个空格分隔的整数(SLA和V)，SLA表示任务的最晚处理时间，V表示任务对应的积分。1<=SLA<=100, 0<=V<=100000

输出描述:
可获得的最多积分

示例1
输入
4
3
1 2
1 3
1 4
1 5
输出
5
说明
虽然有3个单位的时间用于处理任务，可是所有任务在时刻1之后都无效。
所以在第1个时间单位内，选择处理有5个积分的任务。1-3时无任务处理。

示例2
输入
4
3
1 2
1 3
1 4
3 5
输出
9
说明
第1个时间单位内，处理任务3，获得4个积分
第2个时间单位内，处理任务4，获得5个积分
第3个时间单位内，无任务可处理
共获得9个积分
30
ACM编程 语言限制 【100分】 标题：寻找最富裕的小家庭 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
在一棵树中，每个节点代表一个家庭成员，节点的数字表示其个人的财富值，一个节点及其直接相连的子节点被定义为一个小家庭。
现给你一棵树，请计算出最富裕的小家庭的财富和。

输入描述:
第一行为一个数N，表示成员总数，成员编号1-N，1<=N<=1000
第二行为N个空格分隔的数，表示编号1-N的成员的财富值。0<=财富值<=1000000
接下来N-1行，每行两个空格分隔的整数(N1,N2)，表示N1是N2的父节点。

输出描述:
最富裕的小家庭的财富和
示例1
输入
4
100 200 300 500
1 2
1 3
2 4
输出
700
说明


成员1,2,3组成的小家庭财富值为600
成员2,4组成的小家庭财富值为700
示例2
输入
4
100 200 300 500
1 2
1 3
1 4
输出
1100
说明


成员1,2,3,4组成的小家庭财富值为1100
31
ACM编程 语言限制 【100分】 标题：最大坐标值 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
小明在玩一个游戏，游戏规则如下：
在游戏开始前，小明站在坐标轴原点处（坐标值为0）。
给定一组指令和一个幸运数，每个指令都是一个整数，小明按照指定的要求前进或者后退指定的步数。前进代表朝坐标轴的正方向走，后退代表朝坐标轴的负方向走。
幸运数为一个整数，如果某个指令正好和幸运数相等，则小明行进步数加1。

例如：
幸运数为3，指令为[2,3,0,-5]
指令为2，表示前进2步；
指令为3，正好和幸运数相等，前进3+1=4步；
指令为0，表示原地不动，既不前进，也不后退。
指令为-5，表示后退5步；

请你计算小明在整个游戏过程中，小明所处的最大坐标值。

输入描述:
第一行输入1个数字，代表指令的总个数n（1<=n<=100）。
第二行输入1个数字，代表幸运数m（-100<=m<=100）
第三行输入n个指令，每个指令值的取值范围为：-100<=指令值<=100。
输出描述:
输出在整个游戏过程中，小明所处的最大坐标值。异常情况下输出：12345
示例1
输入
2
1
-5 1
输出
0
说明
总共2个指令，幸运数为1，依照指令行进，依次如下：
游戏开始前，站在坐标轴原点，此时坐标值为0；
指令为-5，后退5步，此时坐标值为-5；
指令为1，正好等于幸运数，前进1+1=2步，此时坐标值为-3；
整个游戏过程中，小明所处的坐标值依次为[0,-5,-3]，最大坐标值为0。
示例2
输入
5
-5
-5 1 6 0 -7
输出
1
说明
总共5个指令，幸运数为-5，依照指令行进，依次如下：
游戏开始前，站在坐标轴原点，此时坐标值为0；
指令为-5，正好等于幸运数，后退5+1=6步，此时坐标值为-6；
指令为1，前进1步，此时坐标值为-5；
指令为6，前进6步，此时坐标值为1；
指令为0，既不前进，也不后退，此时坐标值为1；
指令为-7，后退7步，此时坐标值为-6；
整个游戏过程中，小明所处的坐标值依次为[0,-6,-5,1,1,-6]，最大坐标值为1。
32
ACM编程 语言限制 【100分】 标题：手机App防沉迷系统 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
智能手机方便了我们生活的同时，也侵占了我们不少的时间。“手机App防沉迷系统”能够让我们每天合理的规划手机App使用时间，在正确的时间做正确的事。
它的大概原理是这样的：
1、在一天24小时内，可注册每个App的允许使用时段；

2、一个时段只能使用一个App，举例说明：不能同时在09:00-10:00注册App2和App3；

3、App有优先级，数值越高，优先级越高。注册使用时段时，如果高优先级的App时间和低优先级的时段有冲突，则系统会自动注销低优先级的时段；如果App的优先级相同，则后添加的App不能注册。
举例1：
（1）注册App3前：

（2）App3注册时段和App2有冲突：

（3）App3优先级高，系统接受App3的注册，自动注销App2的注册：

举例2：
（1）注册App4：

（2）App4和App2及App3都有冲突，优先级比App2高，但比App3低，这种场景下App4注册不上，最终的注册效果如下：


4、一个App可以在一天内注册多个时段。

请编程实现，根据输入数据注册App，并根据输入的时间点，返回该时间点可用的App名称，如果该时间点没有注册任何App，请返回字符串"NA"。
输入描述:
输入分3部分：第一行表示注册的App数N（N≤100）；第二部分包括N行，每行表示一条App注册数据；最后一行输入一个时间点，程序即返回该时间点的可用App。
2
App1 1 09:00 10:00
App2 2 11:00 11:30
09:30
数据说明如下：
1、N行注册数据以空格分隔，四项数据依次表示：App名称、优先级、起始时间、结束时间
2、优先级1-5，数字值越大，优先级越高
3、时间格式HH:MM，小时和分钟都是两位，不足两位前面补0
4、起始时间需小于结束时间，否则注册不上
5、注册信息中的时间段包含起始时间点，不包含结束时间点
输出描述:
输出一个字符串，表示App名称，或NA表示空闲时间。
备注:
1、用例保证时间都介于00:00-24:00之间；
2、用例保证数据格式都是正确的，不用考虑数据输入行数不够、注册信息不完整、字符串非法、优先级超限、时间格式不正确的问题。
示例1
输入
1
App1 1 09:00 10:00
09:30
输出
App1
说明
App1注册在9点到10点间，9点半可用的应用名是App1
示例2
输入
2
App1 1 09:00 10:00
App2 2 09:10 09:30
09:20
输出
App2
说明
App1和App2的时段有冲突，App2的优先级比App1高，注册App2后，系统将App1的注册信息自动注销后，09:20时刻可用应用名是App2.
示例3
输入
2
App1 1 09:00 10:00
App2 2 09:10 09:30
09:50
输出
NA
说明
App1被注销后，09:50时刻没有应用注册，因此输出NA。
33
ACM编程 语言限制 【100分】 标题：CPU算力分配 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
现有两组服务器A和B，每组有多个算力不同的CPU，其中A[i]是A组第i个CPU的运算能力，B[i]是B组第i个CPU的运算能力。一组服务器的总算力是各CPU的算力之和。为了让两组服务器的算力相等，允许从每组各选出一个CPU进行一次交换，求两组服务器中，用于交换的CPU的算力，并且要求从A组服务器中选出的CPU，算力尽可能小。
输入描述:
第一行输入为L1和L2，以空格分隔，L1表示A组服务器中的CPU数量，L2表示B组服务器中的CPU数量。
第二行输入为A组服务器中各个CPU的算力值，以空格分隔。
第三行输入为B组服务器中各个CPU的算力值，以空格分隔。
1 <= L1 <= 10000
1 <= L2 <= 10000
1 <= A[i] <= 100000
1 <= B[i] <= 100000

输出描述:
对于每组测试数据，输出两个整数，以空格分隔，依次表示A组选出的CPU算力、B组选出的CPU算力。
要求从A组选出的CPU的算力尽可能小。
备注:
保证两组服务器的初始总算力不同。

答案肯定存在。
示例1
输入
2 2
1 1
2 2
输出
1 2
说明
从A组中选出算力为1的CPU，与B组中算力为2的进行交换，使两组服务器的算力都等于3。
示例2
输入
2 2
1 2
2 3
输出
1 2
示例3
输入
1 2
2
1 3
输出
2 3
示例4
输入
3 2
1 2 5
2 4
输出
5 4
34
ACM编程 语言限制 【100分】 标题：执行时长 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
为了充分发挥GPU算力，需要尽可能多的将任务交给GPU执行，现在有一个任务数组，数组元素表示在这1秒内新增的任务个数且每秒都有新增任务，假设GPU最多一次执行n个任务，一次执行耗时1秒，在保证GPU不空闲情况下，最少需要多长时间执行完成
输入描述:
第一个参数为GPU一次最多执行的任务个数，取值范围[1, 10000]
第二个参数为任务数组长度，取值范围[1, 10000]
第三个参数为任务数组，数字范围[1, 10000]

输出描述:
执行完所有任务最少需要多少秒
示例1
输入
3
5
1 2 3 4 5
输出
6
说明
一次最多执行3个任务，最少耗时6s
示例2
输入
4
5
5 4 1 1 1
输出
5
说明
一次最多执行4个任务，最少耗时5s
35
ACM编程 语言限制 【100分】 标题：求最多可以派出多少支团队 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
用数组代表每个人的能力，一个比赛活动要求参赛团队的最低能力值为N，每个团队可以由1人或2人组成，且1个人只能参加1个团队，请计算出最多可以派出多少支符合要求的团队？

输入描述:
5
3 1 5 7 9
8
第一行数组代表总人数，范围[1,500000]
第二行数组代表每个人的能力，每个元素的取值范围[1, 500000]，数组的大小范围[1,500000]
第三行数值为团队要求的最低能力值，范围[1, 500000]
输出描述:
3
最多可以派出的团队数量
示例1
输入
5
3 1 5 7 9
8
输出
3
说明
3,5组成一队，1,7组成一队，9自己一个队，故输出3
36
ACM编程 语言限制 【100分】 标题：查找众数及中位数 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
1.众数是指一组数据中出现次数量多的那个数，众数可以是多个
2.中位数是指把一组数据从小到大排列，最中间的那个数，如果这组数据的个数是奇数，那最中间那个就是中位数，如果这组数据的个数为偶数，那就把中间的两个数之和除以2，所得的结果就是中位数
3.查找整型数组中元素的众数并组成一个新的数组，求新数组的中位数

输入描述:
输入一个一维整型数组，数组大小取值范围 0<N<1000，数组中每个元素取值范围 0<E<1000
输出描述:
输出众数组成的新数组的中位数
示例1
输入
10 11 21 19 21 17 21 16 21 18 15
输出
21
示例2
输入
2 1 5 4 3 3 9 2 7 4 6 2 15 4 2 4
输出
3
示例3
输入
5 1 5 3 5 2 5 5 7 6 7 3 7 11 7 55 7 9 98 9 17 9 15 9 9 1 39
输出
7
37
ACM编程 语言限制 【100分】 标题：查找接口成功率最优时间段 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
服务之间交换的接口成功率作为服务调用关键质量特性，某个时间段内的接口失败率使用一个数组表示，数组中每个元素都是单位时间内失败率数值，数组中的数值为0~100的整数，给定一个数值(minAverageLost)表示某个时间段内平均失败率容忍值，即平均失败率小于等于minAverageLost，找出数组中最长时间段，如果未找到则直接返回NULL。
输入描述:
输入有两行内容，第一行为{minAverageLost}，第二行为{数组}，数组元素通过空格(" ")分隔，minAverageLost及数组中元素取值范围为0~100的整数，数组元素的个数不会超过100个。
输出描述:
找出平均值小于等于minAverageLost的最长时间段，输出数组下标对，格式{beginIndex}-{endIndx}(下标从0开始)，如果同时存在多个最长时间段，则输出多个下标对且下标对之间使用空格(" ")拼接，多个下标对按下标从小到大排序。
示例1
输入
1
0 1 2 3 4
输出
0-2
说明
A、输入解释：minAverageLost=1，数组[0, 1, 2, 3, 4]
B、前3个元素的平均值为1，因此数组第一个至第三个数组下标，即0-2
示例2
输入
2
0 0 100 2 2 99 0 2
输出
0-1 3-4 6-7
说明
A、输入解释：minAverageLost=2，数组[0, 0, 100, 2, 2, 99, 0, 2]
B、通过计算小于等于2的最长时间段为：数组下标为0-1即[0, 0]，数组下标为3-4即[2, 2]，数组下标为6-7即[0, 2]，这三个部分都满足平均值小于等2的要求，因此输出0-1 3-4 6-7
38
ACM编程 语言限制 【100分】 标题：计算面积 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
绘图机器的绘图笔初始位置在原点（0, 0），机器启动后其绘图笔按下面规则绘制直线：
1）尝试沿着横向坐标轴正向绘制直线，直到给定的终点值E。
2）期间可通过指令在纵坐标轴方向进行偏移，并同时绘制直线，偏移后按规则1 绘制直线；指令的格式为X offsetY，表示在横坐标X 沿纵坐标方向偏移，offsetY为正数表示正向偏移，为负数表示负向偏移。

给定了横坐标终点值E、以及若干条绘制指令，请计算绘制的直线和横坐标轴、以及 X=E 的直线组成图形的面积。

输入描述:
首行为两个整数 N E，表示有N条指令，机器运行的横坐标终点值E。
接下来N行，每行两个整数表示一条绘制指令X offsetY，用例保证横坐标X以递增排序方式出现，且不会出现相同横坐标X。
取值范围：0 < N <= 10000, 0 <= X <= E <=20000, -10000 <= offsetY <= 10000。
输出描述:
一个整数，表示计算得到的面积，用例保证，结果范围在0~4294967295内
示例1
输入
4 10
1 1
2 1
3 1
4 -2
输出
12
说明
通过操作机器最后绘制了如下图形（蓝色为绘制笔绘制的直线）

计算图中阴影部分面积，其值为1*1+2*1+3*1+1*6=12
示例2
输入
2 4
0 1
2 -2
输出
4
说明
通过操作机器最后绘制了如下图形

计算图中阴影部分面积，其值为1*2+1*2=4

39
ACM编程 语言限制 【100分】 标题：按身高和体重排队 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
某学校举行运动会，学生们按编号(1、2、3…n)进行标识，现需要按照身高由低到高排列，对身高相同的人，按体重由轻到重排列；对于身高体重都相同的人，维持原有的编号顺序关系。请输出排列后的学生编号。

输入描述:
两个序列，每个序列由n个正整数组成（0 < n <= 100）。第一个序列中的数值代表身高，第二个序列中的数值代表体重。

输出描述:
排列结果，每个数值都是原始序列中的学生编号，编号从1开始

示例1
输入
4
100 100 120 130
40 30 60 50
输出
2 1 3 4
说明
输出的第一个数字2表示此人原始编号为2，即身高为100，体重为30的这个人。由于他和编号为1的人身高一样，但体重更轻，因此要排在1前面。
示例2
输入
3
90 110 90
45 60 45
输出
1 3 2
说明
1和3的身高体重都相同，需要按照原有位置关系让1排在3前面，而不是3 1 2
40
ACM编程 语言限制 【100分】 标题：整数对最小和 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
给定两个整数数组array1、array2，数组元素按升序排列。假设从array1、array2中分别取出一个元素可构成一对元素，现在需要取出k对元素，并对取出的所有元素求和，计算和的最小值
注意：两对元素如果对应于array1、array2中的两个下标均相同，则视为同一对元素。

输入描述:
输入两行数组array1、array2，每行首个数字为数组大小size(0 < size <= 100);
0 < array1[i] <= 1000
0 < array2[i] <= 1000
接下来一行为正整数k
0 < k <= array1.size() * array2.size()
输出描述:
满足要求的最小和
示例1
输入
3 1 1 2
3 1 2 3
2
输出
4
说明
用例中，需要取2对元素
取第一个数组第0个元素与第二个数组第0个元素组成1对元素[1,1];
取第一个数组第1个元素与第二个数组第0个元素组成1对元素[1,1];
求和为1+1+1+1=4，为满足要求的最小和
41
ACM编程 语言限制 【100分】 标题：靠谱的车 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
程序员小明打了一辆出租车去上班。出于职业敏感，他注意到这辆出租车的计费表有点问题，总是偏大。

出租车司机解释说他不喜欢数字4，所以改装了计费表，任何数字位置遇到数字4就直接跳过，其余功能都正常。

比如：

1.     23再多一块钱就变为25；

2.     39再多一块钱变为50；

3.     399再多一块钱变为500；

小明识破了司机的伎俩，准备利用自己的学识打败司机的阴谋。

给出计费表的表面读数，返回实际产生的费用。


输入描述:
只有一行，数字N，表示里程表的读数。

(1<=N<=888888888)。

输出描述:
一个数字，表示实际产生的费用。以回车结束。

示例1
输入
5
输出
4
说明


5表示计费表的表面读数。

4表示实际产生的费用其实只有4块钱。





示例2
输入
17
输出
15
说明
17表示计费表的表面读数。

15表示实际产生的费用其实只有15块钱。

示例3
输入
100
输出
81
说明
100表示计费表的表面读数。

81表示实际产生的费用其实只有81块钱。

42
ACM编程 语言限制 【100分】 标题：英文输入法 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
主管期望你来实现英文输入法单词联想功能。需求如下：

依据用户输入的单词前缀，从已输入的英文语句中联想出用户想输入的单词，按字典序输出联想到的单词序列，如果联想不到，请输出用户输入的单词前缀。

注意：

1.  英文单词联想时，区分大小写

2.  缩略形式如”don't”，判定为两个单词，”don”和”t”

3.  输出的单词序列，不能有重复单词，且只能是英文单词，不能有标点符号

输入描述:
输入为两行。

首行输入一段由英文单词word和标点符号组成的语句str；

接下来一行为一个英文单词前缀pre。

0 < word.length() <= 20

0 < str.length <= 10000

0 < pre <= 20

输出描述:
输出符合要求的单词序列或单词前缀，存在多个时，单词之间以单个空格分割

示例1
输入
I love you
He
输出
He
说明
从用户已输入英文语句”I love you”中提炼出“I”、“love”、“you”三个单词，接下来用户输入“He”，从已输入信息中无法联想到任何符合要求的单词，因此输出用户输入的单词前缀。

示例2
输入
The furthest distance in the world, Is not between life and death, But when I stand in front of you, Yet you don't know that I love you.
f
输出
front furthest
说明
从用户已输入英文语句”The furthestdistance in the world, Is not between life and death, But when I stand in frontof you, Yet you dont know that I love you.”中提炼出的单词，符合“f”作为前缀的，有“furthest”和“front”，按字典序排序并在单词间添加空格后输出，结果为“frontfurthest”。

43
ACM编程 语言限制 【100分】 标题：素数之积 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
RSA加密算法在网络安全世界中无处不在，它利用了极大整数因数分解的困难度，数据越大，安全系数越高，给定一个32位正整数，请对其进行因数分解，找出是哪两个素数的乘积。

输入描述:
一个正整数num

0 < num <= 2147483647

输出描述:
如果成功找到，以单个空格分割，从小到大输出两个素数，分解失败，请输出-1 -1

示例1
输入
15
输出
3 5
说明
因数分解后，找到两个素数3和5，使得3*5=15，按从小到大排列后，输出3 5

示例2
输入
27
输出
-1 -1
说明
通过因数分解，找不到任何素数，使得他们的乘积为27，输出-1 -1

44
ACM编程 语言限制 【100分】 标题：提取字符串中的最长数学表达式并计算 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
提取字符串中的最长合法简单数学表达式，字符串长度最长的，并计算表达式的值。如果没有，则返回0
简单数学表达式只能包含以下内容
0-9数字，符号 +-*
说明：
1. 所有数字，计算结果都不超过long
2. 如果有多个长度一样的，请返回第一个表达式的结果
3. 数学表达式，必须是最长的，合法的
4. 操作符不能连续出现，如 +--+1 是不合法的

输入描述:
字符串
输出描述:
表达式值
示例1
输入
1-2abcd
输出
-1
45
ACM编程 语言限制 【100分】 标题：求字符串中所有整数的最小和 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
输入字符串s，输出s中包含所有整数的最小和
说明
1. 字符串s，只包含 a-z A-Z +- ；
2. 合法的整数包括
    1） 正整数 一个或者多个0-9组成，如 0 2 3 002 102
    2）负整数 负号 - 开头，数字部分由一个或者多个0-9组成，如 -0 -012 -23 -00023

输入描述:
包含数字的字符串
输出描述:
所有整数的最小和
示例1
输入
bb1234aa
输出
10
示例2
输入
bb12-34aa
输出
-31
说明
1+2+（-34） = 31
46
ACM编程 语言限制 【100分】 标题：停车场车辆统计 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
特定大小的停车场，数组cars[]表示，其中1表示有车，0表示没车。车辆大小不一，小车占一个车位（长度1），货车占两个车位（长度2），卡车占三个车位（长度3），统计停车场最少可以停多少辆车，返回具体的数目。
输入描述:
整型字符串数组cars[]，其中1表示有车，0表示没车，数组长度小于1000。
输出描述:
整型数字字符串，表示最少停车数目。
示例1
输入
1,0,1
输出
2
说明
1个小车占第1个车位

第二个车位空

1个小车占第3个车位

最少有两辆车
示例2
输入
1,1,0,0,1,1,1,0,1
输出
3
说明
1个货车占第1、2个车位

第3、4个车位空

1个卡车占第5、6、7个车位

第8个车位空

1个小车占第9个车位

最少3辆车
47
ACM编程 语言限制 【100分】 标题：剩余银饰的重量 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
有N块二手市场收集的银饰，每块银饰的重量都是正整数，收集到的银饰会被熔化用于打造新的饰品。
每一回合，从中选出三块 最重的 银饰，然后一起熔掉。假设银饰的重量分别为 x 、y和z，且 x <= y <= z。那么熔掉的可能结果如下：
如果 x == y == z，那么三块银饰都会被完全熔掉；
如果 x == y 且 y != z，会剩余重量为 z - y 的银块无法被熔掉；
如果 x != y 且 y == z，会剩余重量为 y - x 的银块无法被熔掉；
如果 x != y 且 y != z，会剩余重量为 z - y 与 y - x 差值 的银块无法被熔掉。
最后，如果剩余两块，返回较大的重量（若两块重量相同，返回任意一块皆可）；如果只剩下一块，返回该块的重量；如果没有剩下，就返回 0。
输入描述:
输入数据为两行
第一行为银饰数组长度n，1 ≤ n ≤ 40，
第二行为n块银饰的重量，重量的取值范围为[1，2000]，重量之间使用空格隔开
输出描述:
如果剩余两块，返回较大的重量（若两块重量相同，返回任意一块皆可）；如果只剩下一块，返回该块的重量；如果没有剩下，就返回 0。
示例1
输入
3
1 1 1
输出
0
说明
选出1 1 1，得到 0，最终数组转换为 []，最后没有剩下银块，返回0
示例2
输入
3
3 7 10
输出
1
说明
选出 3 7 10，需要计算 (7-3) 和 (10-7) 的差值，即(7-3)-(10-7)=1，所以数组转换为 [1]，剩余一块，返回该块重量，返回1
48
ACM编程 语言限制 【100分】 标题：分配土地 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
从前有个村庄，村民们喜欢在各种田地上插上小旗子，旗子上标识了各种不同的数字。某天集体村民决定将覆盖相同数字的最小矩阵形的土地的分配给为村里做出巨大贡献的村民，请问，此次分配土地，做出贡献的村民中最大会分配多大面积？
输入描述:
第一行输入m和n，m代表村子的土地的长，n代表土地的宽
第二行开始输入地图上的具体标识
输出描述:
输出需要分配的土地面积，即包含相同数字旗子的最小矩阵中的最大面积。
备注:
旗子上的数字为1-500，土地边长不超过500
未插旗子的土地用0标识
示例1
输入
3 3
1 0 1
0 0 0
0 1 0
输出
9
说明
土地上的旗子为1，其坐标分别为(0,0)，(2,1)以及(0,2)，为了覆盖所有旗子，矩阵需要覆盖的横坐标为0和2，纵坐标为0和2，所以面积为9，即(2-0+1)*(2-0+1)=9。
示例2
输入
3 3
1 0 2
0 0 0
0 3 4
输出
1
说明
由于不存在成对的小旗子，故而返回1，即一块土地的面积。
49
ACM编程 语言限制 【100分】 标题：来自异国的客人 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
有位客人来自异国，在该国使用m进制计数。该客人有个幸运数字n(n<m)，每次购物时，其总是喜欢计算本次支付的花费(折算为异国的价格后)中存在多少幸运数字。问：当其购买一个在我国价值k的产品时，其中包含多少幸运数字？
输入描述:
第一行输入为 k, n, m。
其中：
k 表示 该客人购买的物品价值（以十进制计算的价格）
n 表示 该客人的幸运数字
m 表示 该客人所在国度的采用的进制
输出描述:
输出幸运数字的个数，行末无空格。
备注:
当输入非法内容时，输出0
示例1
输入
10 2 4
输出
2
说明
10用4进制表示时为22，同时，异国客人的幸运数字是2，故而此处输出为2，表示有2个幸运数字。
示例2
输入
10 4 4
输出
0
说明
此时客人的幸运数字为4，但是由于该国最大为4进制，故而在该国的进制下不可能出现幸运数字，故而返回0
50
ACM编程 语言限制 【100分】 标题：考勤信息 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
公司用一个字符串来表示员工的出勤信息：
absent：缺勤
late：迟到
leaveearly：早退
present：正常上班
现需根据员工出勤信息，判断本次是否能获得出勤奖，能获得出勤奖的条件如下：
缺勤不超过一次；没有连续的迟到/早退；任意连续7次考勤，缺勤/迟到/早退不超过3次
输入描述:
用户的考勤数据字符串，记录条数 >= 1；输入字符串长度<10000；不存在非法输入
如：
2
present
present absent present present leaveearly present absent
输出描述:
根据考勤数据字符串，如果能得到考勤奖，输出"true"；否则输出"false"，对于输入示例的结果应为：
true false
示例1
输入
2
present
present present
输出
true true
示例2
输入
2
present
present absent present present leaveearly present absent
输出
true false



51
ACM编程 语言限制 【100分】 标题：密码解密 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
给定一段"密文"字符串s,其中字符都是经过"密码本"映射的，现需要将"密文"解密并且输出
   映射的规则 （'a'-'i')分别用('1'-'9')表示；('j'-'z')分别用('10*'-'26*')表示
   约束：映射始终唯一
输入描述:
“密文”字符串
输出描述:
明文字符串
备注:
翻译后的文本的长度在100以内
示例1
输入
20*19*20*
输出
tst
52
ACM编程 语言限制 【100分】 标题：数组去重和排序 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
给定一个乱序的数组，删除所有的重复元素，使得每个元素只出现一次，并且按照出现的次数从高到低进行排序，相同出现次数按照第一次出现顺序进行先后排序。
输入描述:
一个数组
输出描述:
去重排序后的数组
备注:
数组大小不超过100
数组元素值大小不超过100
示例1
输入
1,3,3,3,2,4,4,4,5
输出
3,4,1,2,5
53
ACM编程 语言限制 【100分】 标题：寻找身高相近的小朋友 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
小明今年升学到小学一年级，来到新班级后发现其他小朋友们身高参差不齐，然后就想基于各小朋友和自己的身高差对他们进行排序，请帮他实现排序。
输入描述:
第一行为正整数H和N，0<H<200，为小明的身高，0<N<50，为新班级其他小朋友个数。
第二行为N个正整数H1-HN，分别是其他小朋友的身高，取值范围0<Hi<200（1<=i<=N），且N个正整数各不相同。
输出描述:
输出排序结果，各正整数以空格分割。和小明身高差绝对值最小的小朋友排在前面，和小明身高差绝对值最大的小朋友排在最后，如果两个小朋友和小明身高差一样，则个子较小的小朋友排在前面。
示例1
输入
100 10
95 96 97 98 99 101 102 103 104 105
输出
99 101 98 102 97 103 96 104 95 105
说明
小明身高100，班级学生10个，身高分别为95 96 97 98 99 101 102 103 104 105，按身高差排序后结果为：99 101 98 102 97 103 96 104 95 105。
54
完善核心代码 语言限制 【100分】 标题：求幸存数之和 | 时间限制：1秒 | 内存限制：262144K
限定语言：不限
给一个正整数列 nums，一个跳数 jump，及幸存数量 left。运算过程为：从索引为0的位置开始向后跳，中间跳过 J 个数字，命中索引为J+1的数字，该数被敲出，并从该点起跳，以此类推，直到幸存left个数为止。然后返回幸存数之和。
约束：
1）0是第一个起跳点。
2）起跳点和命中点之间间隔 jump 个数字，已被敲出的数字不计入在内。
3）跳到末尾时无缝从头开始（循环查找），并可以多次循环。
4）若起始时 left>len(nums) 则无需跳数处理过程。

/**
* nums: 正整数数列，长度范围 [1,10000]
* jump: 跳数，范围 [1,10000]
* left: 幸存数量，范围 [0,10000]
* return: 幸存数之和
*/
int sumOfLeft(int[] nums,int jump,int left)
示例1
输入
[1,2,3,4,5,6,7,8,9],4,3
输出
13
说明
从1（索引为0）开始起跳,中间跳过 4 个数字,因此依次删除 6,2,8,5,4,7 。 剩余 1,3,9,返回和为13
55
ACM编程 语言限制 【100分】 标题：堆内存申请 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
有一个总空间为100字节的堆，现要从中新申请一块内存，内存分配原则为优先紧接着前一块已使用内存分配空间足够且最接近申请大小的空闲内存。
输入描述:
输入：
第1行是1个整数，表示期望申请的内存字节数；
第2到N行是用空格分割的两个整数，表示当前已分配的内存的情况，每一行表示一块已分配的连续内存空间，每行的第1和第2个整数分别表示偏移地址和内存块大小，如：
0 1
3 2
表示0偏移地址开始的1个字节和3偏移地址开始的2个字节已被分配，其余内存空闲。
输出描述:
输出:
若申请成功，输出申请到内存的偏移；若申请失败，输出-1。
备注:
1.若输入信息不合法或无效，则申请失败。
2.若没有足够的空间供分配，则申请失败。
3.堆内存信息有区域重叠或有非法值等都是无效输入。
示例1
输入
1
0 1
3 2
输出
1
说明
堆中已使用的两块内存是偏移从0开始1字节和偏移从3开始的2字节，空闲的两块内存是偏移从1开始2个字节和偏移从5开始95字节，根据分配原则，新申请的内存应从1开始分配1个字节，所以输出偏移为1.
56
ACM编程 语言限制 【100分】 标题：用连续自然数之和来表达整数 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
一个整数可以由连续的自然数之和来表示。给定一个整数，计算该整数有几种连续自然数之和的表达式，且打印出每种表达式。
输入描述:
一个目标整数T (1 <=T<= 1000)
输出描述:
该整数的所有表达式和表达式的个数。如果有多种表达式，输出要求为：

1.自然数个数最少的表达式优先输出

2.每个表达式中按自然数递增的顺序输出，具体的格式参见样例。在每个测试数据结束时，输出一行”Result:X”，其中X是最终的表达式个数。
示例1
输入
9
输出
9=9
9=4+5
9=2+3+4
Result:3
说明
整数 9 有三种表示方法，第1个表达式只有1个自然数，最先输出，第2个表达式有2个自然数，第2次序输出，第3个表达式有3个自然数，最后输出。每个表达式中的自然数都是按递增次序输出的。

数字与符号之间无空格

示例2
输入
10
输出
10=10
10=1+2+3+4
Result:2
57
ACM编程 语言限制 【100分】 标题：火星文计算 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)

已知火星人使用的运算符为#、$，其与地球人的等价公式如下： 
x#y = 4*x+3*y+2  
x$y = 2*x+y+3  
1、其中x、y是无符号整数 
2、地球人公式按C语言规则计算 
3、火星人公式中，#的优先级高于$，相同的运算符，按从左到右的顺序计算 
现有一段火星人的字符串报文，请你来翻译并计算结果。 


输入描述:
火星人字符串表达式（结尾不带回车换行）
输入的字符串说明：  字符串为仅由无符号整数和操作符（#、$）组成的计算表达式。例如：123#4$5#67$78。  
1、用例保证字符串中，操作数与操作符之间没有任何分隔符。  
2、用例保证操作数取值范围为32位无符号整数。  
3、保证输入以及计算结果不会出现整型溢出。  
4、保证输入的字符串为合法的求值报文，例如：123#4$5#67$78  
5、保证不会出现非法的求值报文，例如类似这样字符串：  
#4$5 //缺少操作数  
4$5# //缺少操作数  
4#$5 //缺少操作数  
4 $5 //有空格  
3+4-5*6/7 //有其它操作符  
12345678987654321$54321 //32位整数计算溢出
输出描述:
根据输入的火星人字符串输出计算结果（结尾不带回车换行）
示例1
输入
7#6$5#12
输出
157
说明
示例：  
7#6$5#12  
=(4*7+3*6+2)$5#12
=48$5#12
=48$(4*5+3*12+2)
=48$58
=2*48+58+3
=157 
58
ACM编程 语言限制 【100分】 标题：字符串变换最小字符串 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
给定一个字符串s，最多只能进行一次变换，返回变换后能得到的最小字符串（按照字典序进行比较）。
变换规则：交换字符串中任意两个不同位置的字符。
    

输入描述:
一串小写字母组成的字符串s
输出描述:
按照要求进行变换得到的最小字符串
备注:
s是都是小写字符组成
1<=s.length<=1000
示例1
输入
abcdef
输出
abcdef
说明
abcdef已经是最小字符串，不需要交换
示例2
输入
bcdefa
输出
acdefb
说明
a和b进行位置交换，可以等到最小字符串
59
ACM编程 语言限制 【100分】 标题：最长子字符串的长度（一） | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
给你一个字符串 s，字符串s首尾相连成一个环形 ，请你在环中找出 'o' 字符出现了偶数次最长子字符串的长度。
输入描述:
输入是一串小写字母组成的字符串
输出描述:
输出是一个整数
备注:
1 <= s.length <= 5 x 10^5

s 只包含小写英文字母。

示例1
输入
alolobo
输出
6
说明
最长子字符串之一是 "alolob"，它包含'o' 2个。
示例2
输入
looxdolx
输出
7
说明
最长子字符串是 "oxdolxl"，由于是首尾连接在一起的，所以最后一个 'x' 和开头的 'l'是连接在一起的，此字符串包含 2 个'o' 。
示例3
输入
bcbcbc
输出
6
说明
这个示例中，字符串 "bcbcbc" 本身就是最长的，因为  'o' 都出现了 0 次。
60
ACM编程 语言限制 【100分】 标题：字符串序列判定 | 时间限制：3秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), JavaScript V8(6.0.0), Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), C++14(g++5.4), bash(GNU bash4.3.46), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44)
输入两个字符串S和L，都只包含英文小写字母。S长度<=100，L长度<=500,000。判定S是否是L的有效字串。

判定规则：S中的每个字符在L中都能找到（可以不连续），且S在Ｌ中字符的前后顺序与S中顺序要保持一致。（例如，S="ace"是L="abcde"的一个子序列且有效字符是a、c、e，而"aec"不是有效子序列，且有效字符只有a、e）


输入描述:
输入两个字符串S和L，都只包含英文小写字母。S长度<=100，L长度<=500,000。

先输入S，再输入L，每个字符串占一行。



输出描述:
S串最后一个有效字符在L中的位置。（首位从0开始计算，无有效字符返回-1）

示例1
输入
ace
abcde
输出
4
示例2
输入
fgh
abcde
输出
-1
61
完善核心代码 语言限制 【100分】 标题：攀登者1 | 时间限制：1秒 | 内存限制：32768K
限定语言：不限
攀登者喜欢寻找各种地图，并且尝试攀登到最高的山峰。
地图表示为一维数组，数组的索引代表水平位置，数组的高度代表相对海拔高度。其中数组元素0代表地面。
例如[0,1,2,4,3,1,0,0,1,2,3,1,2,1,0], 代表如下图所示的地图，地图中有两个山脉位置分别为 1,2,3,4,5和8,9,10,11,12,13，最高峰高度分别为 4,3。最高峰位置分别为3,10。
一个山脉可能有多座山峰(高度大于相邻位置的高度，或在地图边界且高度大于相邻的高度)。
                4
  
              +---+ 
              |   | 
              |   | 3                       3 
              |   | 
              |   +---+                   ----- 
              |       |                   |   | 
            2 |       |                 2 |   |     2 
              |       |                   |   | 
          +---+       |               ----+   |   +---+ 
          |           |               |       |   |   | 
        1 |           | 1           1 |       | 1 |   | 1 
          |           |               |       |   |   | 
      +---+           +---+       +---+       +---+   +---+ 
      |                   |       |                       | 
    0 |                   | 0   0 |                       | 0 
      |                   |       |                       | 
  +---+                   +-------+                       +---+ 
  
    0   1   2   3   4   5   6   7   8   9  10  11  12  13  14
登山时会消耗登山者的体力(整数)，上山时，消耗相邻高度差两倍的体力，下坡时消耗相邻高度差一倍的体力，平地不消耗体力，登山者体力消耗到零时会有生命危险。
例如，上图所示的山峰，从索引0，走到索引1，高度差为1，需要消耗2X1=2的体力，从索引2高度2走到高度4索引3需要消耗2X2=4的体力。如果是从索引3走到索引4则消耗1X1=1的体力。
登山者想要知道一张地图中有多少座山峰

示例1
输入
[0,1,4,3,1,0,0,1,2,3,1,2,1,0]
输出
3
说明
山峰所在的索引分别为 2,10,12
62
ACM编程 语言限制 【100分】 标题：找朋友 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
在学校中，N个小朋友站成一队， 第i个小朋友的身高为height[i]，
第i个小朋友可以看到的第一个比自己身高更高的小朋友j，那么j是i的好朋友(要求j > i)。
请重新生成一个列表，对应位置的输出是每个小朋友的好朋友位置，如果没有看到好朋友，请在该位置用0代替。
小朋友人数范围是 [0, 40000]。
输入描述:
第一行输入N，N表示有N个小朋友
第二行输入N个小朋友的身高height[i]，都是整数
输出描述:
输出N个小朋友的好朋友的位置
示例1
输入
2
100 95
输出
0 0
说明
第一个小朋友身高100，站在队尾位置，向队首看，没有比他身高高的小朋友，所以输出第一个值为0。
第二个小朋友站在队首，前面也没有比他身高高的小朋友，所以输出第二个值为0。
示例2
输入
8
123 124 125 121 119 122 126 123
输出
1 2 6 5 5 6 0 0
说明
123的好朋友是1位置上的124
124的好朋友是2位置上的125
125的好朋友是6位置上的126
以此类推
63
ACM编程 语言限制 【100分】 标题：最大N个数与最小N个数的和 | 时间限制：1秒 | 内存限制：262144K
限定语言：C(clang11), C++(clang++11), Pascal(fpc 3.0.2), Java(javac 1.8), Python2(2.7.3), PHP(7.4.7), C#(mcs 5.4), ObjC(gcc 5.4), Python3(3.9), JavaScript Node(12.18.2), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave 5.2), pypy2(pypy2.7.13), pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6), TypeScript(4.1.2)
给定一个数组，编写一个函数来计算它的最大N个数与最小N个数的和。你需要对数组进行去重。


说明：
       *数组中数字范围[0, 1000]
       *最大N个数与最小N个数不能有重叠，如有重叠，输入非法返回-1
*输入非法返回-1
输入描述:
第一行输入M， M标识数组大小
第二行输入M个数，标识数组内容
第三行输入N，N表达需要计算的最大、最小N个数
输出描述:
输出最大N个数与最小N个数的和。
示例1
输入
5
95 88 83 64 100
2
输出
342
说明
最大2个数[100,95],最小2个数[83,64], 输出为342
示例2
输入
5
3 2 3 4 2
2
输出
-1
说明
最大2个数[4,3],最小2个数[3,2], 有重叠输出为-1
