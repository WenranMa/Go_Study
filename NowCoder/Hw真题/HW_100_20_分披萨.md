# HW_100_20_分披萨 

“吃货”和“馋嘴”两人到披萨店点了一份铁盘（圆形）披萨，并嘱咐店员将披萨按放射状切成大小相同的偶数扇形小块。但是粗心服务员将披萨切成了每块大小都完全不同奇数块，且肉眼能分辨出大小。由于两人都想吃到最多的披萨，他们商量了一个他们认为公平的分法：从“吃货”开始，轮流取披萨。除了第一块披萨可以任意选取以外，其他都必须从缺口开始选。他俩选披萨的思路不同。“馋嘴”每次都会选最大块的披萨，而且“吃货”知道“馋嘴”的想法。已知披萨小块的数量以及每块的大小，求“吃货”能分得的最大的披萨大小的总和。

### 输入描述:
第1行为一个正整数奇数N，表示披萨小块数量。3 <= N < 500。
接下来的第2行到第N+1行（共N行），每行为一个正整数，表示第i块披萨的大小。1 <= i <= N。披萨小块从某一块开始，按照一个方向依次顺序编号为1~N。每块披萨的大小范围为[1, 2147483647]。

### 输出描述:
“吃货”能分得的最大的披萨大小的总和。

### 示例1
输入

    5
    8
    2
    10
    5
    7

输出

    19

说明，此例子中，有5块披萨。每块大小依次为8、2、10、5、7。按照如下顺序拿披萨，可以使“吃货”拿到最多披萨：

    1、“吃货”拿大小为10的披萨
    2、“馋嘴”拿大小为5的披萨
    3、“吃货”拿大小为7的披萨
    4、“馋嘴”拿大小为8的披萨
    5、“吃货”拿大小为2的披萨
至此，披萨瓜分完毕，“吃货”拿到的披萨总大小为10+7+2=19。
可能存在多种拿法，以上只是其中一种。

### 解：

dp数组是一个长度为(n+n) * (n+n) 的二维列表，f[i][j]表示吃货将a[i...j]中所有的披萨吃完后，吃货得到的最多披萨量。需要保证披萨的数量是奇数块，即(j-i+1)%2=1。


```go
package main

import (
	"fmt"
)

func main() {
	var n int
	fmt.Scan(&n)
	var nums = make([]int, n)
	for i := 0; i < n; i++ {
		var val int
		fmt.Scan(&val)
		nums[i] = val
		//nums[i+n] = val // 由于披萨是环形的，将数组扩展一倍以方便处理环形结构
	}

	fmt.Println(maxPizza(nums, n))
}

func maxPizza(a []int, n int) int {
	a = append(a, a...)
	var f [][]int = make([][]int, 2*n)
	for i := 0; i < 2*n; i++ {
		f[i] = make([]int, 2*n)
	}

	// 初始化动态规划表，用于存储从i到j片披萨，吃货能吃到的最大披萨大小
	for i := 0; i < 2*n; i++ {
		// 当只有一块披萨时，直接取该块披萨的大小
		f[i][i] = a[i]
	}

	// k表示考虑的披萨块的长度，从3开始因为必须是奇数块，每次增加2
	for k := 3; k <= n; k += 2 {
		for i := 0; i < 2*n-k+1; i++ {
			j := i + k - 1
			// 选择a[i]时的处理逻辑：检查馋嘴接下来会选哪块，并更新状态
			if a[i+1] > a[j] {
				// 如果馋嘴选a[i+1]，则吃货的选择从i+2到j的披萨
				f[i][j] = max(f[i][j], f[i+2][j]+a[i])
			} else {
				// 如果馋嘴选a[j]，则吃货的选择从i+1到j-1的披萨
				f[i][j] = max(f[i][j], f[i+1][j-1]+a[i])
			}
			// 选择a[j]时的处理逻辑：同样检查馋嘴接下来会选哪块，并更新状态
			if a[i] > a[j-1] {
				// 如果馋嘴选a[i]，则吃货的选择从i+1到j-1的披萨
				f[i][j] = max(f[i][j], f[i+1][j-1]+a[j])
			} else {
				// 如果馋嘴选a[j-1]，则吃货的选择从i到j-2的披萨
				f[i][j] = max(f[i][j], f[i][j-2]+a[j])
			}
			//ppp(f)
		}
	}
	// 求解所有可能的环形起点的最大值
	var ans int = 0
	for i := 0; i < n; i++ {
		ans = max(ans, f[i][i+n-1])
	}
	return ans
}

func ppp(nums [][]int) {
	fmt.Println("---------------")
	for i := 0; i < len(nums); i++ {
		fmt.Println(nums[i])
	}
	fmt.Println("++++++++++++++++++")
}

```